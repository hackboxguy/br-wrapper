diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/Kconfig linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/Kconfig
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/Kconfig	2023-11-02 18:13:18.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/Kconfig	2024-06-14 10:43:31.765519390 +0200
@@ -12,6 +12,17 @@
 
 if INPUT_TOUCHSCREEN
 
+config TOUCHSCREEN_HIMAX_CHIPSET
+        bool "Himax touchpanel CHIPSET"
+        depends on I2C
+        help
+          Say Y here if you have a Himax CHIPSET touchscreen.
+          HIMAX controllers are multi touch controllers which can
+          report 10 touches ata a time.
+
+          If unsure, say N.
+source "drivers/input/touchscreen/hxchipset/Kconfig"
+
 config TOUCHSCREEN_88PM860X
 	tristate "Marvell 88PM860x touchscreen"
 	depends on MFD_88PM860X
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/Makefile linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/Makefile
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/Makefile	2023-11-02 18:13:18.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/Makefile	2024-06-14 10:43:31.765519390 +0200
@@ -6,8 +6,8 @@
 # Each configuration option enables a list of files.
 
 wm97xx-ts-y := wm97xx-core.o
-goodix_ts-y := goodix.o goodix_fwupload.o
 
+obj-$(CONFIG_TOUCHSCREEN_PROPERTIES)	+= of_touchscreen.o
 obj-$(CONFIG_TOUCHSCREEN_88PM860X)	+= 88pm860x-ts.o
 obj-$(CONFIG_TOUCHSCREEN_AD7877)	+= ad7877.o
 obj-$(CONFIG_TOUCHSCREEN_AD7879)	+= ad7879.o
@@ -35,7 +35,6 @@
 obj-$(CONFIG_TOUCHSCREEN_DYNAPRO)	+= dynapro.o
 obj-$(CONFIG_TOUCHSCREEN_EDT_FT5X06)	+= edt-ft5x06.o
 obj-$(CONFIG_TOUCHSCREEN_HAMPSHIRE)	+= hampshire.o
-obj-$(CONFIG_TOUCHSCREEN_HYCON_HY46XX)	+= hycon-hy46xx.o
 obj-$(CONFIG_TOUCHSCREEN_GUNZE)		+= gunze.o
 obj-$(CONFIG_TOUCHSCREEN_EETI)		+= eeti_ts.o
 obj-$(CONFIG_TOUCHSCREEN_EKTF2127)	+= ektf2127.o
@@ -45,11 +44,9 @@
 obj-$(CONFIG_TOUCHSCREEN_EGALAX_SERIAL)	+= egalax_ts_serial.o
 obj-$(CONFIG_TOUCHSCREEN_EXC3000)	+= exc3000.o
 obj-$(CONFIG_TOUCHSCREEN_FUJITSU)	+= fujitsu_ts.o
-obj-$(CONFIG_TOUCHSCREEN_GOODIX)	+= goodix_ts.o
+obj-$(CONFIG_TOUCHSCREEN_GOODIX)	+= goodix.o
 obj-$(CONFIG_TOUCHSCREEN_HIDEEP)	+= hideep.o
 obj-$(CONFIG_TOUCHSCREEN_ILI210X)	+= ili210x.o
-obj-$(CONFIG_TOUCHSCREEN_ILITEK)	+= ilitek_ts_i2c.o
-obj-$(CONFIG_TOUCHSCREEN_IMAGIS)	+= imagis.o
 obj-$(CONFIG_TOUCHSCREEN_IMX6UL_TSC)	+= imx6ul_tsc.o
 obj-$(CONFIG_TOUCHSCREEN_INEXIO)	+= inexio.o
 obj-$(CONFIG_TOUCHSCREEN_IPROC)		+= bcm_iproc_tsc.o
@@ -62,7 +59,6 @@
 obj-$(CONFIG_TOUCHSCREEN_MELFAS_MIP4)	+= melfas_mip4.o
 obj-$(CONFIG_TOUCHSCREEN_MIGOR)		+= migor_ts.o
 obj-$(CONFIG_TOUCHSCREEN_MMS114)	+= mms114.o
-obj-$(CONFIG_TOUCHSCREEN_MSG2638)	+= msg2638.o
 obj-$(CONFIG_TOUCHSCREEN_MTOUCH)	+= mtouch.o
 obj-$(CONFIG_TOUCHSCREEN_MK712)		+= mk712.o
 obj-$(CONFIG_TOUCHSCREEN_HP600)		+= hp680_ts_input.o
@@ -116,3 +112,4 @@
 obj-$(CONFIG_TOUCHSCREEN_RASPBERRYPI_FW)	+= raspberrypi-ts.o
 obj-$(CONFIG_TOUCHSCREEN_IQS5XX)	+= iqs5xx.o
 obj-$(CONFIG_TOUCHSCREEN_ZINITIX)	+= zinitix.o
+obj-$(CONFIG_TOUCHSCREEN_HIMAX_CHIPSET)	+= hxchipset/
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.built-in.a.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.built-in.a.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.built-in.a.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.built-in.a.cmd	2024-06-14 10:43:31.768852723 +0200
@@ -0,0 +1 @@
+cmd_drivers/input/touchscreen/hxchipset/built-in.a := rm -f drivers/input/touchscreen/hxchipset/built-in.a; /mnt/buildramdisk/br-output/host/bin/arm-buildroot-linux-uclibcgnueabihf-ar cDPrST drivers/input/touchscreen/hxchipset/built-in.a 
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_common.o.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_common.o.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_common.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_common.o.cmd	2024-06-14 10:43:31.768852723 +0200
@@ -0,0 +1,1211 @@
+cmd_drivers/input/touchscreen/hxchipset/himax_common.o := /mnt/buildramdisk/br-output/host/bin/arm-buildroot-linux-uclibcgnueabihf-gcc -Wp,-MMD,drivers/input/touchscreen/hxchipset/.himax_common.o.d -nostdinc -isystem /mnt/buildramdisk/br-output/host/lib/gcc/arm-buildroot-linux-uclibcgnueabihf/10.3.0/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -include ./include/linux/compiler_types.h -D__KERNEL__ -mlittle-endian -fmacro-prefix-map=./= -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=implicit-function-declaration -Werror=implicit-int -Werror=return-type -Wno-format-security -std=gnu89 -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mfpu=vfp -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-address-of-packed-member -O2 -fno-allow-store-data-races -Wframe-larger-than=1024 -fstack-protector-strong -Wimplicit-fallthrough -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -pg -Wdeclaration-after-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -Wno-zero-length-bounds -Wno-array-bounds -Wno-stringop-overflow -Wno-restrict -Wno-maybe-uninitialized -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init -Wno-packed-not-aligned -Wno-attribute-alias -DHX_CONFIG_FB -D__HIMAX_MOD__ -D__HIMAX_HX83193_MOD__ -D__HIMAX_MOD__  -DMODULE  -DKBUILD_BASENAME='"himax_common"' -DKBUILD_MODNAME='"himax_mmi"' -c -o drivers/input/touchscreen/hxchipset/himax_common.o drivers/input/touchscreen/hxchipset/himax_common.c
+
+source_drivers/input/touchscreen/hxchipset/himax_common.o := drivers/input/touchscreen/hxchipset/himax_common.c
+
+deps_drivers/input/touchscreen/hxchipset/himax_common.o := \
+    $(wildcard include/config/touchscreen/himax/self/test.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83195.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83192.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83193.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83194.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83180.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83181.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx8530.h) \
+    $(wildcard include/config/of.h) \
+    $(wildcard include/config/touchscreen/himax/debug.h) \
+  include/linux/kconfig.h \
+    $(wildcard include/config/cc/version/text.h) \
+    $(wildcard include/config/cpu/big/endian.h) \
+    $(wildcard include/config/booger.h) \
+    $(wildcard include/config/foo.h) \
+  include/linux/compiler_types.h \
+    $(wildcard include/config/have/arch/compiler/h.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/cc/has/asm/inline.h) \
+  include/linux/compiler_attributes.h \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arm64.h) \
+    $(wildcard include/config/retpoline.h) \
+    $(wildcard include/config/arch/use/builtin/bswap.h) \
+    $(wildcard include/config/kcov.h) \
+  drivers/input/touchscreen/hxchipset/himax_self_test.h \
+  drivers/input/touchscreen/hxchipset/himax_platform.h \
+  include/linux/delay.h \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/preempt/rt.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/panic/timeout.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  include/linux/limits.h \
+  include/uapi/linux/limits.h \
+  include/linux/types.h \
+    $(wildcard include/config/have/uid16.h) \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  include/uapi/linux/types.h \
+  arch/arm/include/uapi/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  include/uapi/asm-generic/int-ll64.h \
+  arch/arm/include/generated/uapi/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/uapi/asm-generic/bitsperlong.h \
+  include/uapi/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/uapi/linux/stddef.h \
+  include/linux/compiler_types.h \
+  arch/arm/include/uapi/asm/posix_types.h \
+  include/uapi/asm-generic/posix_types.h \
+  include/vdso/limits.h \
+  include/linux/linkage.h \
+    $(wildcard include/config/arch/use/sym/annotations.h) \
+  include/linux/stringify.h \
+  include/linux/export.h \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/module/rel/crcs.h) \
+    $(wildcard include/config/have/arch/prel32/relocations.h) \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/trim/unused/ksyms.h) \
+    $(wildcard include/config/unused/symbols.h) \
+  arch/arm/include/asm/linkage.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/stack/validation.h) \
+  arch/arm/include/generated/asm/rwonce.h \
+  include/asm-generic/rwonce.h \
+  include/linux/kasan-checks.h \
+    $(wildcard include/config/kasan.h) \
+  include/linux/kcsan-checks.h \
+    $(wildcard include/config/kcsan.h) \
+    $(wildcard include/config/kcsan/ignore/atomics.h) \
+  include/linux/bitops.h \
+  include/linux/bits.h \
+  include/linux/const.h \
+  include/vdso/const.h \
+  include/uapi/linux/const.h \
+  include/vdso/bits.h \
+  include/linux/build_bug.h \
+  arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  arch/arm/include/asm/irqflags.h \
+    $(wildcard include/config/cpu/v7m.h) \
+  arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/arm/thumb.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+  arch/arm/include/uapi/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+  arch/arm/include/asm/hwcap.h \
+  arch/arm/include/uapi/asm/hwcap.h \
+  include/asm-generic/irqflags.h \
+  arch/arm/include/asm/percpu.h \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/percpu.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+    $(wildcard include/config/amd/mem/encrypt.h) \
+  arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arm/heavy/mb.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+    $(wildcard include/config/cpu/spectre.h) \
+  include/asm-generic/barrier.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/builtin-__fls.h \
+  include/asm-generic/bitops/builtin-__ffs.h \
+  include/asm-generic/bitops/builtin-fls.h \
+  include/asm-generic/bitops/builtin-ffs.h \
+  include/asm-generic/bitops/ffz.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/atomic.h \
+  arch/arm/include/asm/atomic.h \
+    $(wildcard include/config/generic/atomic64.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/linux/prefetch.h \
+  arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/binfmt/elf/fdpic.h) \
+  arch/arm/include/asm/hw_breakpoint.h \
+  arch/arm/include/asm/unified.h \
+  arch/arm/include/asm/vdso/processor.h \
+    $(wildcard include/config/arm/errata/754327.h) \
+  arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/atomic-fallback.h \
+  include/asm-generic/atomic-long.h \
+  include/asm-generic/bitops/find.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+  include/asm-generic/bitops/le.h \
+  arch/arm/include/uapi/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/uapi/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  include/uapi/linux/swab.h \
+  arch/arm/include/asm/swab.h \
+  arch/arm/include/uapi/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/minmax.h \
+  include/linux/printk.h \
+    $(wildcard include/config/message/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/quiet.h) \
+    $(wildcard include/config/early/printk.h) \
+    $(wildcard include/config/printk/nmi.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/dynamic/debug/core.h) \
+  include/linux/init.h \
+    $(wildcard include/config/strict/kernel/rwx.h) \
+    $(wildcard include/config/strict/module/rwx.h) \
+  include/linux/kern_levels.h \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/uapi/linux/kernel.h \
+  include/uapi/linux/sysinfo.h \
+  include/linux/ratelimit_types.h \
+  include/uapi/linux/param.h \
+  arch/arm/include/generated/uapi/asm/param.h \
+  include/asm-generic/param.h \
+    $(wildcard include/config/hz.h) \
+  include/uapi/asm-generic/param.h \
+  include/linux/spinlock_types.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep_types.h \
+    $(wildcard include/config/prove/raw/lock/nesting.h) \
+    $(wildcard include/config/preempt/lock.h) \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+  include/linux/rwlock_types.h \
+  arch/arm/include/asm/div64.h \
+  arch/arm/include/asm/compiler.h \
+  include/asm-generic/div64.h \
+  arch/arm/include/asm/delay.h \
+  arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/xip/kernel.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+    $(wildcard include/config/xip/phys/addr.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  include/linux/pfn.h \
+  include/linux/fs.h \
+    $(wildcard include/config/read/only/thp/for/fs.h) \
+    $(wildcard include/config/fs/posix/acl.h) \
+    $(wildcard include/config/security.h) \
+    $(wildcard include/config/cgroup/writeback.h) \
+    $(wildcard include/config/ima.h) \
+    $(wildcard include/config/file/locking.h) \
+    $(wildcard include/config/fsnotify.h) \
+    $(wildcard include/config/fs/encryption.h) \
+    $(wildcard include/config/fs/verity.h) \
+    $(wildcard include/config/preemption.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/unicode.h) \
+    $(wildcard include/config/compat.h) \
+    $(wildcard include/config/quota.h) \
+    $(wildcard include/config/fs/dax.h) \
+    $(wildcard include/config/mandatory/file/locking.h) \
+    $(wildcard include/config/block.h) \
+    $(wildcard include/config/migration.h) \
+  include/linux/wait_bit.h \
+  include/linux/wait.h \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+    $(wildcard include/config/page/poisoning/zero.h) \
+  include/linux/spinlock.h \
+  include/linux/preempt.h \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/trace/preempt/toggle.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  arch/arm/include/generated/asm/preempt.h \
+  include/asm-generic/preempt.h \
+  include/linux/thread_info.h \
+    $(wildcard include/config/thread/info/in/task.h) \
+    $(wildcard include/config/have/arch/within/stack/frames.h) \
+    $(wildcard include/config/hardened/usercopy.h) \
+  include/linux/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/bug/on/data/corruption.h) \
+  arch/arm/include/asm/bug.h \
+    $(wildcard include/config/debug/bugverbose.h) \
+  arch/arm/include/asm/opcodes.h \
+    $(wildcard include/config/cpu/endian/be32.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  include/linux/instrumentation.h \
+    $(wildcard include/config/debug/entry.h) \
+  include/linux/restart_block.h \
+  include/linux/time64.h \
+  include/linux/math64.h \
+    $(wildcard include/config/arch/supports/int128.h) \
+  include/vdso/math64.h \
+  include/vdso/time64.h \
+  include/uapi/linux/time.h \
+  include/uapi/linux/time_types.h \
+  include/linux/errno.h \
+  include/uapi/linux/errno.h \
+  arch/arm/include/generated/uapi/asm/errno.h \
+  include/uapi/asm-generic/errno.h \
+  include/uapi/asm-generic/errno-base.h \
+  arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/stackprotector/per/task.h) \
+    $(wildcard include/config/crunch.h) \
+    $(wildcard include/config/arm/thumbee.h) \
+  arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+    $(wildcard include/config/kuser/helpers.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+  arch/arm/include/asm/glue.h \
+  arch/arm/include/asm/pgtable-2level-types.h \
+  include/asm-generic/getorder.h \
+  include/linux/bottom_half.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/debug/locking/api/selftests.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/up/late/init.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+    $(wildcard include/config/fortify/source.h) \
+  include/uapi/linux/string.h \
+  arch/arm/include/asm/string.h \
+    $(wildcard include/config/bcm2835/fast/memcpy.h) \
+  include/linux/smp_types.h \
+  include/linux/llist.h \
+    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
+  arch/arm/include/asm/smp.h \
+  arch/arm/include/generated/asm/mmiowb.h \
+  include/asm-generic/mmiowb.h \
+    $(wildcard include/config/mmiowb.h) \
+  arch/arm/include/asm/spinlock.h \
+  include/linux/rwlock.h \
+    $(wildcard include/config/preempt.h) \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  arch/arm/include/generated/asm/current.h \
+  include/asm-generic/current.h \
+  include/uapi/linux/wait.h \
+  include/linux/kdev_t.h \
+  include/uapi/linux/kdev_t.h \
+  include/linux/dcache.h \
+  include/linux/rculist.h \
+    $(wildcard include/config/prove/rcu/list.h) \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tasks/rcu/generic.h) \
+    $(wildcard include/config/rcu/stall/common.h) \
+    $(wildcard include/config/no/hz/full.h) \
+    $(wildcard include/config/rcu/nocb/cpu.h) \
+    $(wildcard include/config/tasks/rcu.h) \
+    $(wildcard include/config/tasks/trace/rcu.h) \
+    $(wildcard include/config/tasks/rude/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/prove/rcu.h) \
+    $(wildcard include/config/rcu/boost.h) \
+    $(wildcard include/config/arch/weak/release/acquire.h) \
+  include/linux/rcutree.h \
+  include/linux/rculist_bl.h \
+  include/linux/list_bl.h \
+  include/linux/bit_spinlock.h \
+  include/linux/seqlock.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/mutex/spin/on/owner.h) \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/osq_lock.h \
+  include/linux/debug_locks.h \
+  include/linux/ww_mutex.h \
+    $(wildcard include/config/debug/ww/mutex/slowpath.h) \
+  include/linux/lockref.h \
+    $(wildcard include/config/arch/use/cmpxchg/lockref.h) \
+  include/generated/bounds.h \
+  include/linux/stringhash.h \
+    $(wildcard include/config/dcache/word/access.h) \
+  include/linux/hash.h \
+    $(wildcard include/config/have/arch/hash.h) \
+  include/linux/path.h \
+  include/linux/stat.h \
+  arch/arm/include/uapi/asm/stat.h \
+  include/uapi/linux/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+    $(wildcard include/config/posix/timers.h) \
+  include/linux/time32.h \
+  include/linux/timex.h \
+  include/uapi/linux/timex.h \
+  arch/arm/include/asm/timex.h \
+  include/vdso/time32.h \
+  include/vdso/time.h \
+  include/linux/uidgid.h \
+    $(wildcard include/config/multiuser.h) \
+    $(wildcard include/config/user/ns.h) \
+  include/linux/highuid.h \
+  include/linux/list_lru.h \
+    $(wildcard include/config/memcg/kmem.h) \
+  include/linux/nodemask.h \
+    $(wildcard include/config/numa.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+    $(wildcard include/config/numa/keep/meminfo.h) \
+  include/linux/shrinker.h \
+    $(wildcard include/config/memcg.h) \
+  include/linux/radix-tree.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/vm/pgflags.h) \
+  include/linux/xarray.h \
+    $(wildcard include/config/xarray/multi.h) \
+  include/linux/gfp.h \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/zone/device.h) \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/contig/alloc.h) \
+    $(wildcard include/config/cma.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/isolation.h) \
+    $(wildcard include/config/zsmalloc.h) \
+    $(wildcard include/config/shadow/call/stack.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/transparent/hugepage.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/page/extension.h) \
+    $(wildcard include/config/deferred/struct/page/init.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/page-flags-layout.h \
+    $(wildcard include/config/numa/balancing.h) \
+    $(wildcard include/config/kasan/sw/tags.h) \
+  include/linux/mm_types.h \
+    $(wildcard include/config/have/aligned/struct/page.h) \
+    $(wildcard include/config/userfaultfd.h) \
+    $(wildcard include/config/swap.h) \
+    $(wildcard include/config/have/arch/compat/mmap/bases.h) \
+    $(wildcard include/config/membarrier.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+    $(wildcard include/config/arch/want/batched/unmap/tlb/flush.h) \
+    $(wildcard include/config/iommu/support.h) \
+  include/linux/mm_types_task.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/arch/enable/split/pmd/ptlock.h) \
+  include/linux/auxvec.h \
+  include/uapi/linux/auxvec.h \
+  arch/arm/include/asm/auxvec.h \
+  arch/arm/include/uapi/asm/auxvec.h \
+  include/linux/rbtree.h \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/spin/on/owner.h) \
+    $(wildcard include/config/debug/rwsems.h) \
+  include/linux/err.h \
+  include/linux/completion.h \
+  include/linux/swait.h \
+  include/linux/uprobes.h \
+    $(wildcard include/config/uprobes.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+    $(wildcard include/config/sysfs.h) \
+    $(wildcard include/config/wq/watchdog.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/debug/objects/timers.h) \
+    $(wildcard include/config/no/hz/common.h) \
+  include/linux/ktime.h \
+  include/linux/jiffies.h \
+  include/vdso/jiffies.h \
+  include/generated/timeconst.h \
+  include/vdso/ktime.h \
+  include/linux/timekeeping.h \
+  include/linux/timekeeping32.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+    $(wildcard include/config/vdso.h) \
+  include/linux/page-flags.h \
+    $(wildcard include/config/arch/uses/pg/uncached.h) \
+    $(wildcard include/config/memory/failure.h) \
+    $(wildcard include/config/idle/page/tracking.h) \
+    $(wildcard include/config/thp/swap.h) \
+    $(wildcard include/config/ksm.h) \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/arch/has/add/pages.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/have/bootmem/info/node.h) \
+  include/linux/notifier.h \
+    $(wildcard include/config/tree/srcu.h) \
+  include/linux/srcu.h \
+    $(wildcard include/config/tiny/srcu.h) \
+    $(wildcard include/config/srcu.h) \
+  include/linux/rcu_segcblist.h \
+  include/linux/srcutree.h \
+  include/linux/rcu_node_tree.h \
+    $(wildcard include/config/rcu/fanout.h) \
+    $(wildcard include/config/rcu/fanout/leaf.h) \
+  include/linux/topology.h \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+    $(wildcard include/config/sched/smt.h) \
+  include/linux/arch_topology.h \
+    $(wildcard include/config/generic/arch/topology.h) \
+  arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+    $(wildcard include/config/bl/switcher.h) \
+  include/asm-generic/topology.h \
+  include/linux/kconfig.h \
+  include/linux/local_lock.h \
+  include/linux/local_lock_internal.h \
+  include/linux/pid.h \
+  include/linux/refcount.h \
+  include/linux/capability.h \
+  include/uapi/linux/capability.h \
+  include/linux/semaphore.h \
+  include/linux/fcntl.h \
+    $(wildcard include/config/arch/32bit/off/t.h) \
+  include/uapi/linux/fcntl.h \
+  arch/arm/include/uapi/asm/fcntl.h \
+  include/uapi/asm-generic/fcntl.h \
+  include/uapi/linux/openat2.h \
+  include/linux/migrate_mode.h \
+  include/linux/percpu-rwsem.h \
+  include/linux/rcuwait.h \
+  include/linux/sched/signal.h \
+    $(wildcard include/config/sched/autogroup.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/stack/growsup.h) \
+  include/linux/signal.h \
+    $(wildcard include/config/proc/fs.h) \
+  include/linux/signal_types.h \
+    $(wildcard include/config/old/sigaction.h) \
+  include/uapi/linux/signal.h \
+  arch/arm/include/asm/signal.h \
+  arch/arm/include/uapi/asm/signal.h \
+  include/uapi/asm-generic/signal-defs.h \
+  arch/arm/include/uapi/asm/sigcontext.h \
+  arch/arm/include/generated/uapi/asm/siginfo.h \
+  include/uapi/asm-generic/siginfo.h \
+  include/linux/sched.h \
+    $(wildcard include/config/virt/cpu/accounting/native.h) \
+    $(wildcard include/config/sched/info.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/uclamp/task.h) \
+    $(wildcard include/config/uclamp/buckets/count.h) \
+    $(wildcard include/config/cgroup/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/psi.h) \
+    $(wildcard include/config/compat/brk.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/blk/cgroup.h) \
+    $(wildcard include/config/stackprotector.h) \
+    $(wildcard include/config/arch/has/scaled/cputime.h) \
+    $(wildcard include/config/virt/cpu/accounting/gen.h) \
+    $(wildcard include/config/posix/cputimers.h) \
+    $(wildcard include/config/posix/cpu/timers/task/work.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/io/uring.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/ubsan.h) \
+    $(wildcard include/config/ubsan/trap.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/x86/cpu/resctrl.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/rseq.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/kunit.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/bcache.h) \
+    $(wildcard include/config/vmap/stack.h) \
+    $(wildcard include/config/livepatch.h) \
+    $(wildcard include/config/gcc/plugin/stackleak.h) \
+    $(wildcard include/config/x86/mce.h) \
+    $(wildcard include/config/arch/task/struct/on/stack.h) \
+    $(wildcard include/config/debug/rseq.h) \
+  include/uapi/linux/sched.h \
+  include/linux/sem.h \
+  include/uapi/linux/sem.h \
+  include/linux/ipc.h \
+  include/linux/rhashtable-types.h \
+  include/uapi/linux/ipc.h \
+  arch/arm/include/generated/uapi/asm/ipcbuf.h \
+  include/uapi/asm-generic/ipcbuf.h \
+  arch/arm/include/generated/uapi/asm/sembuf.h \
+  include/uapi/asm-generic/sembuf.h \
+  include/linux/shm.h \
+  include/uapi/linux/shm.h \
+  include/uapi/asm-generic/hugetlb_encode.h \
+  arch/arm/include/generated/uapi/asm/shmbuf.h \
+  include/uapi/asm-generic/shmbuf.h \
+  arch/arm/include/asm/shmparam.h \
+  include/linux/kcov.h \
+  include/uapi/linux/kcov.h \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/plist.h) \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+    $(wildcard include/config/time/low/res.h) \
+    $(wildcard include/config/timerfd.h) \
+  include/linux/hrtimer_defs.h \
+  include/linux/timerqueue.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+    $(wildcard include/config/have/arch/seccomp/filter.h) \
+    $(wildcard include/config/seccomp/filter.h) \
+    $(wildcard include/config/checkpoint/restore.h) \
+  include/uapi/linux/seccomp.h \
+  arch/arm/include/generated/asm/seccomp.h \
+  include/asm-generic/seccomp.h \
+  include/uapi/linux/unistd.h \
+  arch/arm/include/asm/unistd.h \
+    $(wildcard include/config/oabi/compat.h) \
+  arch/arm/include/uapi/asm/unistd.h \
+  arch/arm/include/generated/uapi/asm/unistd-eabi.h \
+  arch/arm/include/generated/uapi/asm/unistd-common.h \
+  arch/arm/include/generated/asm/unistd-nr.h \
+  include/linux/resource.h \
+  include/uapi/linux/resource.h \
+  arch/arm/include/generated/uapi/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/uapi/asm-generic/resource.h \
+  include/linux/latencytop.h \
+  include/linux/sched/prio.h \
+  include/linux/sched/types.h \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/posix-timers.h \
+  include/linux/alarmtimer.h \
+    $(wildcard include/config/rtc/class.h) \
+  include/linux/task_work.h \
+  include/uapi/linux/rseq.h \
+  include/linux/kcsan.h \
+  include/linux/sched/jobctl.h \
+  include/linux/sched/task.h \
+    $(wildcard include/config/have/exit/thread.h) \
+    $(wildcard include/config/arch/wants/dynamic/task/struct.h) \
+    $(wildcard include/config/have/arch/thread/struct/whitelist.h) \
+  include/linux/uaccess.h \
+    $(wildcard include/config/set/fs.h) \
+  include/linux/fault-inject-usercopy.h \
+    $(wildcard include/config/fault/injection/usercopy.h) \
+  include/linux/instrumented.h \
+  arch/arm/include/asm/uaccess.h \
+    $(wildcard include/config/cpu/sw/domain/pan.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+    $(wildcard include/config/uaccess/with/memcpy.h) \
+  arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/cp15/mmu.h) \
+  arch/arm/include/generated/asm/extable.h \
+  include/asm-generic/extable.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+  include/linux/key.h \
+    $(wildcard include/config/key/notifications.h) \
+    $(wildcard include/config/net.h) \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/uapi/linux/sysctl.h \
+  include/linux/assoc_array.h \
+    $(wildcard include/config/associative/array.h) \
+  include/linux/sched/user.h \
+    $(wildcard include/config/fanotify.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/bpf/syscall.h) \
+    $(wildcard include/config/watch/queue.h) \
+  include/linux/ratelimit.h \
+  include/linux/rcu_sync.h \
+  include/linux/delayed_call.h \
+  include/linux/uuid.h \
+  include/uapi/linux/uuid.h \
+  include/linux/errseq.h \
+  include/linux/ioprio.h \
+  include/linux/sched/rt.h \
+  include/linux/iocontext.h \
+  include/linux/fs_types.h \
+  include/uapi/linux/fs.h \
+  include/uapi/linux/ioctl.h \
+  arch/arm/include/generated/uapi/asm/ioctl.h \
+  include/asm-generic/ioctl.h \
+  include/uapi/asm-generic/ioctl.h \
+  include/linux/quota.h \
+    $(wildcard include/config/quota/netlink/interface.h) \
+  include/linux/percpu_counter.h \
+  include/uapi/linux/dqblk_xfs.h \
+  include/linux/dqblk_v1.h \
+  include/linux/dqblk_v2.h \
+  include/linux/dqblk_qtree.h \
+  include/linux/projid.h \
+  include/uapi/linux/quota.h \
+  include/linux/nfs_fs_i.h \
+  include/linux/gpio.h \
+    $(wildcard include/config/gpiolib.h) \
+    $(wildcard include/config/arch/have/custom/gpio/h.h) \
+  arch/arm/include/asm/gpio.h \
+    $(wildcard include/config/arch/nr/gpio.h) \
+  include/asm-generic/gpio.h \
+  include/linux/gpio/driver.h \
+    $(wildcard include/config/irq/domain/hierarchy.h) \
+    $(wildcard include/config/gpio/generic.h) \
+    $(wildcard include/config/gpiolib/irqchip.h) \
+    $(wildcard include/config/of/gpio.h) \
+    $(wildcard include/config/pinctrl.h) \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/energy/model.h) \
+    $(wildcard include/config/generic/msi/irq/domain.h) \
+    $(wildcard include/config/generic/msi/irq.h) \
+    $(wildcard include/config/dma/ops.h) \
+    $(wildcard include/config/dma/declare/coherent.h) \
+    $(wildcard include/config/dma/cma.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/device.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu/all.h) \
+    $(wildcard include/config/dma/ops/bypass.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/dev_printk.h \
+  include/linux/energy_model.h \
+  include/linux/jump_label.h \
+    $(wildcard include/config/jump/label.h) \
+    $(wildcard include/config/have/arch/jump/label/relative.h) \
+  arch/arm/include/asm/jump_label.h \
+  include/linux/kobject.h \
+    $(wildcard include/config/uevent/helper.h) \
+    $(wildcard include/config/debug/kobject/release.h) \
+  include/linux/sysfs.h \
+  include/linux/kernfs.h \
+    $(wildcard include/config/kernfs.h) \
+  include/linux/idr.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/sched/cpufreq.h \
+    $(wildcard include/config/cpu/freq.h) \
+  include/linux/sched/topology.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/sched/idle.h \
+  include/linux/sched/sd_flags.h \
+  include/linux/ioport.h \
+    $(wildcard include/config/io/strict/devmem.h) \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/vt/console/sleep.h) \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  include/linux/overflow.h \
+  include/linux/device/bus.h \
+    $(wildcard include/config/acpi.h) \
+  include/linux/device/class.h \
+  include/linux/device/driver.h \
+  arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/arm/dma/use/iommu.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/irq.h \
+    $(wildcard include/config/generic/irq/effective/aff/mask.h) \
+    $(wildcard include/config/generic/irq/ipi.h) \
+    $(wildcard include/config/generic/irq/migration.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+    $(wildcard include/config/hardirqs/sw/resend.h) \
+    $(wildcard include/config/generic/irq/legacy/alloc/hwirq.h) \
+    $(wildcard include/config/generic/irq/legacy.h) \
+    $(wildcard include/config/generic/irq/multi/handler.h) \
+  include/linux/irqhandler.h \
+  include/linux/irqreturn.h \
+  include/linux/irqnr.h \
+  include/uapi/linux/irqnr.h \
+  include/linux/io.h \
+    $(wildcard include/config/have/arch/huge/vmap.h) \
+    $(wildcard include/config/has/ioport/map.h) \
+    $(wildcard include/config/pci.h) \
+  arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/asm-generic/io.h \
+    $(wildcard include/config/generic/iomap.h) \
+    $(wildcard include/config/generic/ioremap.h) \
+    $(wildcard include/config/virt/to/bus.h) \
+  include/linux/logic_pio.h \
+    $(wildcard include/config/indirect/pio.h) \
+  include/linux/fwnode.h \
+  include/linux/vmalloc.h \
+    $(wildcard include/config/kasan/vmalloc.h) \
+  arch/arm/include/asm/vmalloc.h \
+  include/linux/slab.h \
+    $(wildcard include/config/debug/slab.h) \
+    $(wildcard include/config/failslab.h) \
+    $(wildcard include/config/have/hardened/usercopy/allocator.h) \
+    $(wildcard include/config/slab.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+  include/linux/percpu-refcount.h \
+  include/linux/kasan.h \
+    $(wildcard include/config/kasan/generic.h) \
+    $(wildcard include/config/kasan/inline.h) \
+  arch/arm/include/asm/irq.h \
+    $(wildcard include/config/sparse/irq.h) \
+  arch/arm/include/generated/asm/irq_regs.h \
+  include/asm-generic/irq_regs.h \
+  include/linux/irqdesc.h \
+    $(wildcard include/config/generic/irq/debugfs.h) \
+    $(wildcard include/config/handle/domain/irq.h) \
+    $(wildcard include/config/irq/domain.h) \
+  arch/arm/include/asm/hw_irq.h \
+  include/linux/irqchip/chained_irq.h \
+  include/linux/irqdomain.h \
+  include/linux/of.h \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/promtree.h) \
+    $(wildcard include/config/of/kobj.h) \
+    $(wildcard include/config/of/numa.h) \
+    $(wildcard include/config/of/overlay.h) \
+  include/linux/mod_devicetable.h \
+  include/linux/property.h \
+  include/linux/pinctrl/pinctrl.h \
+    $(wildcard include/config/generic/pinconf.h) \
+  include/linux/seq_file.h \
+  include/linux/pinctrl/pinctrl-state.h \
+  include/linux/pinctrl/devinfo.h \
+  include/linux/pinctrl/consumer.h \
+  include/linux/pinctrl/pinconf-generic.h \
+  include/linux/pinctrl/machine.h \
+  include/linux/gpio/consumer.h \
+    $(wildcard include/config/gpio/sysfs.h) \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/slave.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+    $(wildcard include/config/i2c/mux.h) \
+  include/linux/acpi.h \
+    $(wildcard include/config/acpi/debugger.h) \
+    $(wildcard include/config/x86.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/acpi/processor/cstate.h) \
+    $(wildcard include/config/acpi/hotplug/cpu.h) \
+    $(wildcard include/config/acpi/hotplug/ioapic.h) \
+    $(wildcard include/config/x86/io/apic.h) \
+    $(wildcard include/config/acpi/wmi.h) \
+    $(wildcard include/config/acpi/numa.h) \
+    $(wildcard include/config/hibernation.h) \
+    $(wildcard include/config/acpi/hotplug/memory.h) \
+    $(wildcard include/config/acpi/container.h) \
+    $(wildcard include/config/acpi/gtdt.h) \
+    $(wildcard include/config/acpi/table/upgrade.h) \
+    $(wildcard include/config/acpi/watchdog.h) \
+    $(wildcard include/config/acpi/spcr/table.h) \
+    $(wildcard include/config/acpi/generic/gsi.h) \
+    $(wildcard include/config/acpi/lpit.h) \
+    $(wildcard include/config/acpi/pptt.h) \
+  include/linux/resource_ext.h \
+  include/acpi/acpi.h \
+  include/acpi/platform/acenv.h \
+  include/acpi/platform/acgcc.h \
+  include/acpi/platform/aclinux.h \
+    $(wildcard include/config/acpi/reduced/hardware/only.h) \
+    $(wildcard include/config/acpi/debug.h) \
+  include/linux/ctype.h \
+  include/acpi/acnames.h \
+  include/acpi/actypes.h \
+  include/acpi/acexcep.h \
+  include/acpi/actbl.h \
+  include/acpi/actbl1.h \
+  include/acpi/actbl2.h \
+  include/acpi/actbl3.h \
+  include/acpi/acrestyp.h \
+  include/acpi/platform/acenvex.h \
+  include/acpi/platform/aclinuxex.h \
+  include/acpi/platform/acgccex.h \
+  include/acpi/acoutput.h \
+  include/acpi/acpiosxf.h \
+  include/acpi/acpixf.h \
+  include/acpi/acconfig.h \
+  include/acpi/acbuffer.h \
+  include/acpi/acpi_numa.h \
+    $(wildcard include/config/acpi/hmat.h) \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/uapi/linux/i2c.h \
+  include/linux/interrupt.h \
+    $(wildcard include/config/irq/forced/threading.h) \
+    $(wildcard include/config/generic/irq/probe.h) \
+    $(wildcard include/config/irq/timings.h) \
+  include/linux/hardirq.h \
+  include/linux/context_tracking_state.h \
+    $(wildcard include/config/context/tracking.h) \
+  include/linux/static_key.h \
+  include/linux/ftrace_irq.h \
+    $(wildcard include/config/hwlat/tracer.h) \
+  include/linux/vtime.h \
+    $(wildcard include/config/virt/cpu/accounting.h) \
+    $(wildcard include/config/irq/time/accounting.h) \
+  arch/arm/include/asm/hardirq.h \
+  include/linux/irq_cpustat.h \
+  arch/arm/include/asm/sections.h \
+  include/asm-generic/sections.h \
+  drivers/input/touchscreen/hxchipset/himax_common.h \
+  include/linux/input.h \
+  include/uapi/linux/input.h \
+  include/uapi/linux/input-event-codes.h \
+  include/linux/module.h \
+    $(wildcard include/config/modules/tree/lookup.h) \
+    $(wildcard include/config/module/sig.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/bpf/events.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/kprobes.h) \
+    $(wildcard include/config/have/static/call/inline.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/function/error/injection.h) \
+  include/linux/kmod.h \
+  include/linux/umh.h \
+  include/linux/elf.h \
+    $(wildcard include/config/arch/use/gnu/property.h) \
+    $(wildcard include/config/arch/have/elf/prot.h) \
+  arch/arm/include/asm/elf.h \
+  arch/arm/include/asm/vdso_datapage.h \
+  include/vdso/datapage.h \
+    $(wildcard include/config/arch/has/vdso/data.h) \
+  include/uapi/asm-generic/errno-base.h \
+  include/vdso/clocksource.h \
+    $(wildcard include/config/generic/gettimeofday.h) \
+  arch/arm/include/asm/vdso/clocksource.h \
+  include/vdso/processor.h \
+  arch/arm/include/asm/vdso/gettimeofday.h \
+    $(wildcard include/config/arm/arch/timer.h) \
+  arch/arm/include/asm/vdso/cp15.h \
+    $(wildcard include/config/cpu/cp15.h) \
+  arch/arm/include/asm/user.h \
+  include/uapi/linux/elf.h \
+  include/uapi/linux/elf-em.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/rbtree_latch.h \
+  include/linux/error-injection.h \
+  include/asm-generic/error-injection.h \
+  include/linux/tracepoint-defs.h \
+  include/linux/static_call_types.h \
+    $(wildcard include/config/have/static/call.h) \
+  arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+    $(wildcard include/config/arm/module/plts.h) \
+  include/asm-generic/module.h \
+    $(wildcard include/config/have/mod/arch/specific.h) \
+    $(wildcard include/config/modules/use/elf/rel.h) \
+    $(wildcard include/config/modules/use/elf/rela.h) \
+  include/linux/async.h \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+    $(wildcard include/config/superh.h) \
+  include/linux/input/mt.h \
+  include/linux/firmware.h \
+    $(wildcard include/config/fw/loader.h) \
+  include/linux/buffer_head.h \
+  include/linux/pagemap.h \
+  include/linux/mm.h \
+    $(wildcard include/config/have/arch/mmap/rnd/bits.h) \
+    $(wildcard include/config/have/arch/mmap/rnd/compat/bits.h) \
+    $(wildcard include/config/mem/soft/dirty.h) \
+    $(wildcard include/config/arch/uses/high/vma/flags.h) \
+    $(wildcard include/config/arch/has/pkeys.h) \
+    $(wildcard include/config/ppc.h) \
+    $(wildcard include/config/parisc.h) \
+    $(wildcard include/config/sparc64.h) \
+    $(wildcard include/config/arm64/mte.h) \
+    $(wildcard include/config/shmem.h) \
+    $(wildcard include/config/dev/pagemap/ops.h) \
+    $(wildcard include/config/device/private.h) \
+    $(wildcard include/config/pci/p2pdma.h) \
+    $(wildcard include/config/arch/has/pte/special.h) \
+    $(wildcard include/config/arch/has/pte/devmap.h) \
+    $(wildcard include/config/debug/vm/rb.h) \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/init/on/alloc/default/on.h) \
+    $(wildcard include/config/init/on/free/default/on.h) \
+    $(wildcard include/config/debug/pagealloc.h) \
+    $(wildcard include/config/arch/has/set/direct/map.h) \
+    $(wildcard include/config/hugetlbfs.h) \
+    $(wildcard include/config/mapping/dirty/helpers.h) \
+  include/linux/mmap_lock.h \
+  include/linux/range.h \
+  include/linux/page_ext.h \
+  include/linux/stacktrace.h \
+    $(wildcard include/config/stacktrace.h) \
+    $(wildcard include/config/arch/stackwalk.h) \
+    $(wildcard include/config/have/reliable/stacktrace.h) \
+  include/linux/stackdepot.h \
+  include/linux/page_ref.h \
+    $(wildcard include/config/debug/page/ref.h) \
+  include/linux/memremap.h \
+  include/linux/pgtable.h \
+    $(wildcard include/config/pgtable/levels.h) \
+    $(wildcard include/config/highpte.h) \
+    $(wildcard include/config/have/arch/transparent/hugepage/pud.h) \
+    $(wildcard include/config/have/arch/soft/dirty.h) \
+    $(wildcard include/config/arch/enable/thp/migration.h) \
+    $(wildcard include/config/x86/espfix64.h) \
+  arch/arm/include/asm/pgtable.h \
+  arch/arm/include/asm/proc-fns.h \
+    $(wildcard include/config/big/little.h) \
+    $(wildcard include/config/harden/branch/predictor.h) \
+  arch/arm/include/asm/glue-proc.h \
+    $(wildcard include/config/cpu/arm7tdmi.h) \
+    $(wildcard include/config/cpu/arm720t.h) \
+    $(wildcard include/config/cpu/arm740t.h) \
+    $(wildcard include/config/cpu/arm9tdmi.h) \
+    $(wildcard include/config/cpu/arm920t.h) \
+    $(wildcard include/config/cpu/arm922t.h) \
+    $(wildcard include/config/cpu/arm925t.h) \
+    $(wildcard include/config/cpu/arm926t.h) \
+    $(wildcard include/config/cpu/arm940t.h) \
+    $(wildcard include/config/cpu/arm946e.h) \
+    $(wildcard include/config/cpu/arm1020.h) \
+    $(wildcard include/config/cpu/arm1020e.h) \
+    $(wildcard include/config/cpu/arm1022.h) \
+    $(wildcard include/config/cpu/arm1026.h) \
+    $(wildcard include/config/cpu/mohawk.h) \
+    $(wildcard include/config/cpu/feroceon.h) \
+    $(wildcard include/config/cpu/v6k.h) \
+    $(wildcard include/config/cpu/pj4b.h) \
+    $(wildcard include/config/cpu/v7.h) \
+  include/asm-generic/pgtable-nopud.h \
+  include/asm-generic/pgtable-nop4d.h \
+  arch/arm/include/asm/pgtable-hwdef.h \
+  arch/arm/include/asm/pgtable-2level-hwdef.h \
+  arch/arm/include/asm/tlbflush.h \
+    $(wildcard include/config/smp/on/up.h) \
+    $(wildcard include/config/cpu/tlb/v4wt.h) \
+    $(wildcard include/config/cpu/tlb/fa.h) \
+    $(wildcard include/config/cpu/tlb/v4wbi.h) \
+    $(wildcard include/config/cpu/tlb/feroceon.h) \
+    $(wildcard include/config/cpu/tlb/v4wb.h) \
+    $(wildcard include/config/cpu/tlb/v6.h) \
+    $(wildcard include/config/cpu/tlb/v7.h) \
+    $(wildcard include/config/arm/errata/720789.h) \
+    $(wildcard include/config/arm/errata/798181.h) \
+  arch/arm/include/asm/pgtable-2level.h \
+  include/asm-generic/pgtable_uffd.h \
+    $(wildcard include/config/have/arch/userfaultfd/wp.h) \
+  include/linux/huge_mm.h \
+  include/linux/sched/coredump.h \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+  include/linux/vmstat.h \
+    $(wildcard include/config/vm/event/counters.h) \
+    $(wildcard include/config/debug/tlbflush.h) \
+    $(wildcard include/config/debug/vm/vmacache.h) \
+  include/linux/vm_event_item.h \
+    $(wildcard include/config/memory/balloon.h) \
+    $(wildcard include/config/balloon/compaction.h) \
+  include/linux/highmem.h \
+    $(wildcard include/config/x86/32.h) \
+    $(wildcard include/config/debug/highmem.h) \
+  arch/arm/include/asm/cacheflush.h \
+    $(wildcard include/config/arm/errata/411920.h) \
+    $(wildcard include/config/cpu/cache/vipt.h) \
+    $(wildcard include/config/outer/cache.h) \
+    $(wildcard include/config/frame/pointer.h) \
+    $(wildcard include/config/cpu/icache/mismatch/workaround.h) \
+  arch/arm/include/asm/glue-cache.h \
+    $(wildcard include/config/cpu/cache/v4.h) \
+    $(wildcard include/config/cpu/cache/v4wb.h) \
+    $(wildcard include/config/cache/b15/rac.h) \
+  arch/arm/include/asm/cachetype.h \
+    $(wildcard include/config/cpu/cache/vivt.h) \
+  arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+  arch/arm/include/asm/kmap_types.h \
+  include/linux/hugetlb_inline.h \
+  include/linux/proc_fs.h \
+    $(wildcard include/config/proc/pid/arch/status.h) \
+  include/linux/kallsyms.h \
+    $(wildcard include/config/kallsyms/all.h) \
+  include/linux/of_gpio.h \
+  include/generated/uapi/linux/version.h \
+  include/linux/rtc.h \
+    $(wildcard include/config/rtc/intf/dev/uie/emul.h) \
+    $(wildcard include/config/rtc/hctosys/device.h) \
+    $(wildcard include/config/rtc/nvmem.h) \
+    $(wildcard include/config/rtc/intf/sysfs.h) \
+  include/linux/nvmem-provider.h \
+    $(wildcard include/config/nvmem.h) \
+  include/uapi/linux/rtc.h \
+  include/linux/cdev.h \
+  include/linux/poll.h \
+  include/uapi/linux/poll.h \
+  arch/arm/include/generated/uapi/asm/poll.h \
+  include/uapi/asm-generic/poll.h \
+  include/uapi/linux/eventpoll.h \
+  include/linux/fb.h \
+    $(wildcard include/config/gumstix/am200epd.h) \
+    $(wildcard include/config/fb/notify.h) \
+    $(wildcard include/config/fb/deferred/io.h) \
+    $(wildcard include/config/fb/tileblitting.h) \
+    $(wildcard include/config/fb/backlight.h) \
+    $(wildcard include/config/fb/foreign/endian.h) \
+    $(wildcard include/config/fb/both/endian.h) \
+    $(wildcard include/config/fb/big/endian.h) \
+    $(wildcard include/config/fb/little/endian.h) \
+  include/linux/kgdb.h \
+    $(wildcard include/config/have/arch/kgdb.h) \
+    $(wildcard include/config/kgdb.h) \
+    $(wildcard include/config/serial/kgdb/nmi.h) \
+    $(wildcard include/config/kgdb/honour/blocklist.h) \
+  include/linux/kprobes.h \
+    $(wildcard include/config/kretprobes.h) \
+    $(wildcard include/config/kprobes/sanity/test.h) \
+    $(wildcard include/config/optprobes.h) \
+    $(wildcard include/config/kprobes/on/ftrace.h) \
+  include/linux/ftrace.h \
+    $(wildcard include/config/function/tracer.h) \
+    $(wildcard include/config/dynamic/ftrace.h) \
+    $(wildcard include/config/dynamic/ftrace/with/regs.h) \
+    $(wildcard include/config/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/have/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/stack/tracer.h) \
+    $(wildcard include/config/function/profiler.h) \
+    $(wildcard include/config/ftrace/syscalls.h) \
+  include/linux/trace_clock.h \
+  arch/arm/include/generated/asm/trace_clock.h \
+  include/asm-generic/trace_clock.h \
+  include/linux/ptrace.h \
+  include/linux/pid_namespace.h \
+    $(wildcard include/config/pid/ns.h) \
+  include/linux/nsproxy.h \
+  include/linux/ns_common.h \
+  include/uapi/linux/ptrace.h \
+  arch/arm/include/asm/ftrace.h \
+  arch/arm/include/asm/kprobes.h \
+  include/asm-generic/kprobes.h \
+  arch/arm/include/asm/probes.h \
+  arch/arm/include/asm/kgdb.h \
+  include/uapi/linux/fb.h \
+  include/linux/backlight.h \
+    $(wildcard include/config/backlight/class/device.h) \
+  drivers/input/touchscreen/hxchipset/himax_ic_core.h \
+
+drivers/input/touchscreen/hxchipset/himax_common.o: $(deps_drivers/input/touchscreen/hxchipset/himax_common.o)
+
+$(deps_drivers/input/touchscreen/hxchipset/himax_common.o):
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_common.o.d linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_common.o.d
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_common.o.d	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_common.o.d	2024-06-14 10:43:31.768852723 +0200
@@ -0,0 +1,274 @@
+himax_common.o: drivers/input/touchscreen/hxchipset/himax_common.c \
+ include/linux/kconfig.h include/generated/autoconf.h \
+ include/linux/compiler_types.h include/linux/compiler_attributes.h \
+ include/linux/compiler-gcc.h \
+ drivers/input/touchscreen/hxchipset/himax_self_test.h \
+ drivers/input/touchscreen/hxchipset/himax_platform.h \
+ include/linux/delay.h include/linux/kernel.h include/linux/limits.h \
+ include/uapi/linux/limits.h include/linux/types.h \
+ include/uapi/linux/types.h arch/arm/include/uapi/asm/types.h \
+ include/asm-generic/int-ll64.h include/uapi/asm-generic/int-ll64.h \
+ arch/arm/include/generated/uapi/asm/bitsperlong.h \
+ include/asm-generic/bitsperlong.h include/uapi/asm-generic/bitsperlong.h \
+ include/uapi/linux/posix_types.h include/linux/stddef.h \
+ include/uapi/linux/stddef.h include/linux/compiler_types.h \
+ arch/arm/include/uapi/asm/posix_types.h \
+ include/uapi/asm-generic/posix_types.h include/vdso/limits.h \
+ include/linux/linkage.h include/linux/stringify.h include/linux/export.h \
+ arch/arm/include/asm/linkage.h include/linux/compiler.h \
+ arch/arm/include/generated/asm/rwonce.h include/asm-generic/rwonce.h \
+ include/linux/kasan-checks.h include/linux/kcsan-checks.h \
+ include/linux/bitops.h include/linux/bits.h include/linux/const.h \
+ include/vdso/const.h include/uapi/linux/const.h include/vdso/bits.h \
+ include/linux/build_bug.h arch/arm/include/asm/bitops.h \
+ include/linux/irqflags.h include/linux/typecheck.h \
+ arch/arm/include/asm/irqflags.h arch/arm/include/asm/ptrace.h \
+ arch/arm/include/uapi/asm/ptrace.h arch/arm/include/asm/hwcap.h \
+ arch/arm/include/uapi/asm/hwcap.h include/asm-generic/irqflags.h \
+ arch/arm/include/asm/percpu.h include/asm-generic/percpu.h \
+ include/linux/threads.h include/linux/percpu-defs.h \
+ arch/arm/include/asm/barrier.h include/asm-generic/barrier.h \
+ include/asm-generic/bitops/non-atomic.h \
+ include/asm-generic/bitops/builtin-__fls.h \
+ include/asm-generic/bitops/builtin-__ffs.h \
+ include/asm-generic/bitops/builtin-fls.h \
+ include/asm-generic/bitops/builtin-ffs.h \
+ include/asm-generic/bitops/ffz.h include/asm-generic/bitops/fls64.h \
+ include/asm-generic/bitops/sched.h include/asm-generic/bitops/hweight.h \
+ include/asm-generic/bitops/arch_hweight.h \
+ include/asm-generic/bitops/const_hweight.h \
+ include/asm-generic/bitops/lock.h include/linux/atomic.h \
+ arch/arm/include/asm/atomic.h include/linux/prefetch.h \
+ arch/arm/include/asm/processor.h arch/arm/include/asm/hw_breakpoint.h \
+ arch/arm/include/asm/unified.h arch/arm/include/asm/vdso/processor.h \
+ arch/arm/include/asm/cache.h arch/arm/include/asm/cmpxchg.h \
+ include/asm-generic/cmpxchg-local.h include/linux/atomic-fallback.h \
+ include/asm-generic/atomic-long.h include/asm-generic/bitops/find.h \
+ include/asm-generic/bitops/le.h arch/arm/include/uapi/asm/byteorder.h \
+ include/linux/byteorder/little_endian.h \
+ include/uapi/linux/byteorder/little_endian.h include/linux/swab.h \
+ include/uapi/linux/swab.h arch/arm/include/asm/swab.h \
+ arch/arm/include/uapi/asm/swab.h include/linux/byteorder/generic.h \
+ include/asm-generic/bitops/ext2-atomic-setbit.h include/linux/log2.h \
+ include/linux/minmax.h include/linux/printk.h include/linux/init.h \
+ include/linux/kern_levels.h include/linux/cache.h \
+ include/uapi/linux/kernel.h include/uapi/linux/sysinfo.h \
+ include/linux/ratelimit_types.h include/uapi/linux/param.h \
+ arch/arm/include/generated/uapi/asm/param.h include/asm-generic/param.h \
+ include/uapi/asm-generic/param.h include/linux/spinlock_types.h \
+ arch/arm/include/asm/spinlock_types.h include/linux/lockdep_types.h \
+ include/linux/rwlock_types.h arch/arm/include/asm/div64.h \
+ arch/arm/include/asm/compiler.h include/asm-generic/div64.h \
+ arch/arm/include/asm/delay.h arch/arm/include/asm/memory.h \
+ include/linux/sizes.h include/asm-generic/memory_model.h \
+ include/linux/pfn.h include/linux/fs.h include/linux/wait_bit.h \
+ include/linux/wait.h include/linux/list.h include/linux/poison.h \
+ include/linux/spinlock.h include/linux/preempt.h \
+ arch/arm/include/generated/asm/preempt.h include/asm-generic/preempt.h \
+ include/linux/thread_info.h include/linux/bug.h \
+ arch/arm/include/asm/bug.h arch/arm/include/asm/opcodes.h \
+ include/asm-generic/bug.h include/linux/instrumentation.h \
+ include/linux/restart_block.h include/linux/time64.h \
+ include/linux/math64.h include/vdso/math64.h include/vdso/time64.h \
+ include/uapi/linux/time.h include/uapi/linux/time_types.h \
+ include/linux/errno.h include/uapi/linux/errno.h \
+ arch/arm/include/generated/uapi/asm/errno.h \
+ include/uapi/asm-generic/errno.h include/uapi/asm-generic/errno-base.h \
+ arch/arm/include/asm/thread_info.h arch/arm/include/asm/fpstate.h \
+ arch/arm/include/asm/page.h arch/arm/include/asm/glue.h \
+ arch/arm/include/asm/pgtable-2level-types.h \
+ include/asm-generic/getorder.h include/linux/bottom_half.h \
+ include/linux/lockdep.h include/linux/smp.h include/linux/cpumask.h \
+ include/linux/bitmap.h include/linux/string.h \
+ include/uapi/linux/string.h arch/arm/include/asm/string.h \
+ include/linux/smp_types.h include/linux/llist.h \
+ arch/arm/include/asm/smp.h arch/arm/include/generated/asm/mmiowb.h \
+ include/asm-generic/mmiowb.h arch/arm/include/asm/spinlock.h \
+ include/linux/rwlock.h include/linux/spinlock_api_smp.h \
+ include/linux/rwlock_api_smp.h arch/arm/include/generated/asm/current.h \
+ include/asm-generic/current.h include/uapi/linux/wait.h \
+ include/linux/kdev_t.h include/uapi/linux/kdev_t.h \
+ include/linux/dcache.h include/linux/rculist.h include/linux/rcupdate.h \
+ include/linux/rcutree.h include/linux/rculist_bl.h \
+ include/linux/list_bl.h include/linux/bit_spinlock.h \
+ include/linux/seqlock.h include/linux/mutex.h include/linux/osq_lock.h \
+ include/linux/debug_locks.h include/linux/ww_mutex.h \
+ include/linux/lockref.h include/generated/bounds.h \
+ include/linux/stringhash.h include/linux/hash.h include/linux/path.h \
+ include/linux/stat.h arch/arm/include/uapi/asm/stat.h \
+ include/uapi/linux/stat.h include/linux/time.h include/linux/time32.h \
+ include/linux/timex.h include/uapi/linux/timex.h \
+ arch/arm/include/asm/timex.h include/vdso/time32.h include/vdso/time.h \
+ include/linux/uidgid.h include/linux/highuid.h include/linux/list_lru.h \
+ include/linux/nodemask.h include/linux/numa.h include/linux/shrinker.h \
+ include/linux/radix-tree.h include/linux/percpu.h \
+ include/linux/mmdebug.h include/linux/xarray.h include/linux/gfp.h \
+ include/linux/mmzone.h include/linux/pageblock-flags.h \
+ include/linux/page-flags-layout.h include/linux/mm_types.h \
+ include/linux/mm_types_task.h include/linux/auxvec.h \
+ include/uapi/linux/auxvec.h arch/arm/include/asm/auxvec.h \
+ arch/arm/include/uapi/asm/auxvec.h include/linux/rbtree.h \
+ include/linux/rwsem.h include/linux/err.h include/linux/completion.h \
+ include/linux/swait.h include/linux/uprobes.h include/linux/workqueue.h \
+ include/linux/timer.h include/linux/ktime.h include/linux/jiffies.h \
+ include/vdso/jiffies.h include/generated/timeconst.h \
+ include/vdso/ktime.h include/linux/timekeeping.h \
+ include/linux/timekeeping32.h include/linux/debugobjects.h \
+ arch/arm/include/asm/mmu.h include/linux/page-flags.h \
+ include/linux/memory_hotplug.h include/linux/notifier.h \
+ include/linux/srcu.h include/linux/rcu_segcblist.h \
+ include/linux/srcutree.h include/linux/rcu_node_tree.h \
+ include/linux/topology.h include/linux/arch_topology.h \
+ arch/arm/include/asm/topology.h include/asm-generic/topology.h \
+ include/linux/kconfig.h include/linux/local_lock.h \
+ include/linux/local_lock_internal.h include/linux/pid.h \
+ include/linux/refcount.h include/linux/capability.h \
+ include/uapi/linux/capability.h include/linux/semaphore.h \
+ include/linux/fcntl.h include/uapi/linux/fcntl.h \
+ arch/arm/include/uapi/asm/fcntl.h include/uapi/asm-generic/fcntl.h \
+ include/uapi/linux/openat2.h include/linux/migrate_mode.h \
+ include/linux/percpu-rwsem.h include/linux/rcuwait.h \
+ include/linux/sched/signal.h include/linux/signal.h \
+ include/linux/signal_types.h include/uapi/linux/signal.h \
+ arch/arm/include/asm/signal.h arch/arm/include/uapi/asm/signal.h \
+ include/uapi/asm-generic/signal-defs.h \
+ arch/arm/include/uapi/asm/sigcontext.h \
+ arch/arm/include/generated/uapi/asm/siginfo.h \
+ include/uapi/asm-generic/siginfo.h include/linux/sched.h \
+ include/uapi/linux/sched.h include/linux/sem.h include/uapi/linux/sem.h \
+ include/linux/ipc.h include/linux/rhashtable-types.h \
+ include/uapi/linux/ipc.h arch/arm/include/generated/uapi/asm/ipcbuf.h \
+ include/uapi/asm-generic/ipcbuf.h \
+ arch/arm/include/generated/uapi/asm/sembuf.h \
+ include/uapi/asm-generic/sembuf.h include/linux/shm.h \
+ include/uapi/linux/shm.h include/uapi/asm-generic/hugetlb_encode.h \
+ arch/arm/include/generated/uapi/asm/shmbuf.h \
+ include/uapi/asm-generic/shmbuf.h arch/arm/include/asm/shmparam.h \
+ include/linux/kcov.h include/uapi/linux/kcov.h include/linux/plist.h \
+ include/linux/hrtimer.h include/linux/hrtimer_defs.h \
+ include/linux/timerqueue.h include/linux/seccomp.h \
+ include/uapi/linux/seccomp.h arch/arm/include/generated/asm/seccomp.h \
+ include/asm-generic/seccomp.h include/uapi/linux/unistd.h \
+ arch/arm/include/asm/unistd.h arch/arm/include/uapi/asm/unistd.h \
+ arch/arm/include/generated/uapi/asm/unistd-eabi.h \
+ arch/arm/include/generated/uapi/asm/unistd-common.h \
+ arch/arm/include/generated/asm/unistd-nr.h include/linux/resource.h \
+ include/uapi/linux/resource.h \
+ arch/arm/include/generated/uapi/asm/resource.h \
+ include/asm-generic/resource.h include/uapi/asm-generic/resource.h \
+ include/linux/latencytop.h include/linux/sched/prio.h \
+ include/linux/sched/types.h include/linux/task_io_accounting.h \
+ include/linux/posix-timers.h include/linux/alarmtimer.h \
+ include/linux/task_work.h include/uapi/linux/rseq.h \
+ include/linux/kcsan.h include/linux/sched/jobctl.h \
+ include/linux/sched/task.h include/linux/uaccess.h \
+ include/linux/fault-inject-usercopy.h include/linux/instrumented.h \
+ arch/arm/include/asm/uaccess.h arch/arm/include/asm/domain.h \
+ arch/arm/include/generated/asm/extable.h include/asm-generic/extable.h \
+ include/linux/cred.h include/linux/key.h include/linux/sysctl.h \
+ include/uapi/linux/sysctl.h include/linux/assoc_array.h \
+ include/linux/sched/user.h include/linux/ratelimit.h \
+ include/linux/rcu_sync.h include/linux/delayed_call.h \
+ include/linux/uuid.h include/uapi/linux/uuid.h include/linux/errseq.h \
+ include/linux/ioprio.h include/linux/sched/rt.h \
+ include/linux/iocontext.h include/linux/fs_types.h \
+ include/uapi/linux/fs.h include/uapi/linux/ioctl.h \
+ arch/arm/include/generated/uapi/asm/ioctl.h include/asm-generic/ioctl.h \
+ include/uapi/asm-generic/ioctl.h include/linux/quota.h \
+ include/linux/percpu_counter.h include/uapi/linux/dqblk_xfs.h \
+ include/linux/dqblk_v1.h include/linux/dqblk_v2.h \
+ include/linux/dqblk_qtree.h include/linux/projid.h \
+ include/uapi/linux/quota.h include/linux/nfs_fs_i.h include/linux/gpio.h \
+ arch/arm/include/asm/gpio.h include/asm-generic/gpio.h \
+ include/linux/gpio/driver.h include/linux/device.h \
+ include/linux/dev_printk.h include/linux/energy_model.h \
+ include/linux/jump_label.h arch/arm/include/asm/jump_label.h \
+ include/linux/kobject.h include/linux/sysfs.h include/linux/kernfs.h \
+ include/linux/idr.h include/linux/kobject_ns.h include/linux/kref.h \
+ include/linux/sched/cpufreq.h include/linux/sched/topology.h \
+ include/linux/sched/idle.h include/linux/sched/sd_flags.h \
+ include/linux/ioport.h include/linux/klist.h include/linux/pm.h \
+ include/linux/overflow.h include/linux/device/bus.h \
+ include/linux/device/class.h include/linux/device/driver.h \
+ arch/arm/include/asm/device.h include/linux/pm_wakeup.h \
+ include/linux/irq.h include/linux/irqhandler.h include/linux/irqreturn.h \
+ include/linux/irqnr.h include/uapi/linux/irqnr.h include/linux/io.h \
+ arch/arm/include/asm/io.h include/asm-generic/pci_iomap.h \
+ include/asm-generic/io.h include/linux/logic_pio.h \
+ include/linux/fwnode.h include/linux/vmalloc.h \
+ arch/arm/include/asm/vmalloc.h include/linux/slab.h \
+ include/linux/percpu-refcount.h include/linux/kasan.h \
+ arch/arm/include/asm/irq.h arch/arm/include/generated/asm/irq_regs.h \
+ include/asm-generic/irq_regs.h include/linux/irqdesc.h \
+ arch/arm/include/asm/hw_irq.h include/linux/irqchip/chained_irq.h \
+ include/linux/irqdomain.h include/linux/of.h \
+ include/linux/mod_devicetable.h include/linux/property.h \
+ include/linux/pinctrl/pinctrl.h include/linux/seq_file.h \
+ include/linux/pinctrl/pinctrl-state.h include/linux/pinctrl/devinfo.h \
+ include/linux/pinctrl/consumer.h include/linux/pinctrl/pinconf-generic.h \
+ include/linux/pinctrl/machine.h include/linux/gpio/consumer.h \
+ include/linux/i2c.h include/linux/acpi.h include/linux/resource_ext.h \
+ include/acpi/acpi.h include/acpi/platform/acenv.h \
+ include/acpi/platform/acgcc.h include/acpi/platform/aclinux.h \
+ include/linux/ctype.h include/acpi/acnames.h include/acpi/actypes.h \
+ include/acpi/acexcep.h include/acpi/actbl.h include/acpi/actbl1.h \
+ include/acpi/actbl2.h include/acpi/actbl3.h include/acpi/acrestyp.h \
+ include/acpi/platform/acenvex.h include/acpi/platform/aclinuxex.h \
+ include/acpi/platform/acgccex.h include/acpi/acoutput.h \
+ include/acpi/acpiosxf.h include/acpi/acpixf.h include/acpi/acconfig.h \
+ include/acpi/acbuffer.h include/acpi/acpi_numa.h include/linux/rtmutex.h \
+ include/uapi/linux/i2c.h include/linux/interrupt.h \
+ include/linux/hardirq.h include/linux/context_tracking_state.h \
+ include/linux/static_key.h include/linux/ftrace_irq.h \
+ include/linux/vtime.h arch/arm/include/asm/hardirq.h \
+ include/linux/irq_cpustat.h arch/arm/include/asm/sections.h \
+ include/asm-generic/sections.h \
+ drivers/input/touchscreen/hxchipset/himax_common.h include/linux/input.h \
+ include/uapi/linux/input.h include/uapi/linux/input-event-codes.h \
+ include/linux/module.h include/linux/kmod.h include/linux/umh.h \
+ include/linux/elf.h arch/arm/include/asm/elf.h \
+ arch/arm/include/asm/vdso_datapage.h include/vdso/datapage.h \
+ include/uapi/asm-generic/errno-base.h include/vdso/clocksource.h \
+ arch/arm/include/asm/vdso/clocksource.h include/vdso/processor.h \
+ arch/arm/include/asm/vdso/gettimeofday.h \
+ arch/arm/include/asm/vdso/cp15.h arch/arm/include/asm/user.h \
+ include/uapi/linux/elf.h include/uapi/linux/elf-em.h \
+ include/linux/moduleparam.h include/linux/rbtree_latch.h \
+ include/linux/error-injection.h include/asm-generic/error-injection.h \
+ include/linux/tracepoint-defs.h include/linux/static_call_types.h \
+ arch/arm/include/asm/module.h include/asm-generic/module.h \
+ include/linux/async.h include/linux/platform_device.h \
+ include/linux/input/mt.h include/linux/firmware.h \
+ include/linux/buffer_head.h include/linux/pagemap.h include/linux/mm.h \
+ include/linux/mmap_lock.h include/linux/range.h include/linux/page_ext.h \
+ include/linux/stacktrace.h include/linux/stackdepot.h \
+ include/linux/page_ref.h include/linux/memremap.h \
+ include/linux/pgtable.h arch/arm/include/asm/pgtable.h \
+ arch/arm/include/asm/proc-fns.h arch/arm/include/asm/glue-proc.h \
+ include/asm-generic/pgtable-nopud.h include/asm-generic/pgtable-nop4d.h \
+ arch/arm/include/asm/pgtable-hwdef.h \
+ arch/arm/include/asm/pgtable-2level-hwdef.h \
+ arch/arm/include/asm/tlbflush.h arch/arm/include/asm/pgtable-2level.h \
+ include/asm-generic/pgtable_uffd.h include/linux/huge_mm.h \
+ include/linux/sched/coredump.h include/linux/vmstat.h \
+ include/linux/vm_event_item.h include/linux/highmem.h \
+ arch/arm/include/asm/cacheflush.h arch/arm/include/asm/glue-cache.h \
+ arch/arm/include/asm/cachetype.h arch/arm/include/asm/outercache.h \
+ arch/arm/include/asm/kmap_types.h include/linux/hugetlb_inline.h \
+ include/linux/proc_fs.h include/linux/kallsyms.h include/linux/of_gpio.h \
+ include/generated/uapi/linux/version.h include/linux/rtc.h \
+ include/linux/nvmem-provider.h include/uapi/linux/rtc.h \
+ include/linux/cdev.h include/linux/poll.h include/uapi/linux/poll.h \
+ arch/arm/include/generated/uapi/asm/poll.h \
+ include/uapi/asm-generic/poll.h include/uapi/linux/eventpoll.h \
+ include/linux/fb.h include/linux/kgdb.h include/linux/kprobes.h \
+ include/linux/ftrace.h include/linux/trace_clock.h \
+ arch/arm/include/generated/asm/trace_clock.h \
+ include/asm-generic/trace_clock.h include/linux/ptrace.h \
+ include/linux/pid_namespace.h include/linux/nsproxy.h \
+ include/linux/ns_common.h include/uapi/linux/ptrace.h \
+ arch/arm/include/asm/ftrace.h arch/arm/include/asm/kprobes.h \
+ include/asm-generic/kprobes.h arch/arm/include/asm/probes.h \
+ arch/arm/include/asm/kgdb.h include/uapi/linux/fb.h \
+ include/linux/backlight.h \
+ drivers/input/touchscreen/hxchipset/himax_ic_core.h
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_debug.o.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_debug.o.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_debug.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_debug.o.cmd	2024-06-14 10:43:31.768852723 +0200
@@ -0,0 +1,1211 @@
+cmd_drivers/input/touchscreen/hxchipset/himax_debug.o := /mnt/buildramdisk/br-output/host/bin/arm-buildroot-linux-uclibcgnueabihf-gcc -Wp,-MMD,drivers/input/touchscreen/hxchipset/.himax_debug.o.d -nostdinc -isystem /mnt/buildramdisk/br-output/host/lib/gcc/arm-buildroot-linux-uclibcgnueabihf/10.3.0/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -include ./include/linux/compiler_types.h -D__KERNEL__ -mlittle-endian -fmacro-prefix-map=./= -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=implicit-function-declaration -Werror=implicit-int -Werror=return-type -Wno-format-security -std=gnu89 -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mfpu=vfp -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-address-of-packed-member -O2 -fno-allow-store-data-races -Wframe-larger-than=1024 -fstack-protector-strong -Wimplicit-fallthrough -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -pg -Wdeclaration-after-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -Wno-zero-length-bounds -Wno-array-bounds -Wno-stringop-overflow -Wno-restrict -Wno-maybe-uninitialized -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init -Wno-packed-not-aligned -Wno-attribute-alias -DHX_CONFIG_FB -D__HIMAX_MOD__ -D__HIMAX_HX83193_MOD__ -D__HIMAX_MOD__  -DMODULE  -DKBUILD_BASENAME='"himax_debug"' -DKBUILD_MODNAME='"himax_mmi"' -c -o drivers/input/touchscreen/hxchipset/himax_debug.o drivers/input/touchscreen/hxchipset/himax_debug.c
+
+source_drivers/input/touchscreen/hxchipset/himax_debug.o := drivers/input/touchscreen/hxchipset/himax_debug.c
+
+deps_drivers/input/touchscreen/hxchipset/himax_debug.o := \
+    $(wildcard include/config/touchscreen/himax/ic/hx8530.h) \
+  include/linux/kconfig.h \
+    $(wildcard include/config/cc/version/text.h) \
+    $(wildcard include/config/cpu/big/endian.h) \
+    $(wildcard include/config/booger.h) \
+    $(wildcard include/config/foo.h) \
+  include/linux/compiler_types.h \
+    $(wildcard include/config/have/arch/compiler/h.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/cc/has/asm/inline.h) \
+  include/linux/compiler_attributes.h \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arm64.h) \
+    $(wildcard include/config/retpoline.h) \
+    $(wildcard include/config/arch/use/builtin/bswap.h) \
+    $(wildcard include/config/kcov.h) \
+  drivers/input/touchscreen/hxchipset/himax_debug.h \
+  drivers/input/touchscreen/hxchipset/himax_platform.h \
+    $(wildcard include/config/touchscreen/himax/debug.h) \
+  include/linux/delay.h \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/preempt/rt.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/panic/timeout.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  include/linux/limits.h \
+  include/uapi/linux/limits.h \
+  include/linux/types.h \
+    $(wildcard include/config/have/uid16.h) \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  include/uapi/linux/types.h \
+  arch/arm/include/uapi/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  include/uapi/asm-generic/int-ll64.h \
+  arch/arm/include/generated/uapi/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/uapi/asm-generic/bitsperlong.h \
+  include/uapi/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/uapi/linux/stddef.h \
+  include/linux/compiler_types.h \
+  arch/arm/include/uapi/asm/posix_types.h \
+  include/uapi/asm-generic/posix_types.h \
+  include/vdso/limits.h \
+  include/linux/linkage.h \
+    $(wildcard include/config/arch/use/sym/annotations.h) \
+  include/linux/stringify.h \
+  include/linux/export.h \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/module/rel/crcs.h) \
+    $(wildcard include/config/have/arch/prel32/relocations.h) \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/trim/unused/ksyms.h) \
+    $(wildcard include/config/unused/symbols.h) \
+  arch/arm/include/asm/linkage.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/stack/validation.h) \
+  arch/arm/include/generated/asm/rwonce.h \
+  include/asm-generic/rwonce.h \
+  include/linux/kasan-checks.h \
+    $(wildcard include/config/kasan.h) \
+  include/linux/kcsan-checks.h \
+    $(wildcard include/config/kcsan.h) \
+    $(wildcard include/config/kcsan/ignore/atomics.h) \
+  include/linux/bitops.h \
+  include/linux/bits.h \
+  include/linux/const.h \
+  include/vdso/const.h \
+  include/uapi/linux/const.h \
+  include/vdso/bits.h \
+  include/linux/build_bug.h \
+  arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  arch/arm/include/asm/irqflags.h \
+    $(wildcard include/config/cpu/v7m.h) \
+  arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/arm/thumb.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+  arch/arm/include/uapi/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+  arch/arm/include/asm/hwcap.h \
+  arch/arm/include/uapi/asm/hwcap.h \
+  include/asm-generic/irqflags.h \
+  arch/arm/include/asm/percpu.h \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/percpu.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+    $(wildcard include/config/amd/mem/encrypt.h) \
+  arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arm/heavy/mb.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+    $(wildcard include/config/cpu/spectre.h) \
+  include/asm-generic/barrier.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/builtin-__fls.h \
+  include/asm-generic/bitops/builtin-__ffs.h \
+  include/asm-generic/bitops/builtin-fls.h \
+  include/asm-generic/bitops/builtin-ffs.h \
+  include/asm-generic/bitops/ffz.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/atomic.h \
+  arch/arm/include/asm/atomic.h \
+    $(wildcard include/config/generic/atomic64.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/linux/prefetch.h \
+  arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/binfmt/elf/fdpic.h) \
+  arch/arm/include/asm/hw_breakpoint.h \
+  arch/arm/include/asm/unified.h \
+  arch/arm/include/asm/vdso/processor.h \
+    $(wildcard include/config/arm/errata/754327.h) \
+  arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/atomic-fallback.h \
+  include/asm-generic/atomic-long.h \
+  include/asm-generic/bitops/find.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+  include/asm-generic/bitops/le.h \
+  arch/arm/include/uapi/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/uapi/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  include/uapi/linux/swab.h \
+  arch/arm/include/asm/swab.h \
+  arch/arm/include/uapi/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/minmax.h \
+  include/linux/printk.h \
+    $(wildcard include/config/message/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/quiet.h) \
+    $(wildcard include/config/early/printk.h) \
+    $(wildcard include/config/printk/nmi.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/dynamic/debug/core.h) \
+  include/linux/init.h \
+    $(wildcard include/config/strict/kernel/rwx.h) \
+    $(wildcard include/config/strict/module/rwx.h) \
+  include/linux/kern_levels.h \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/uapi/linux/kernel.h \
+  include/uapi/linux/sysinfo.h \
+  include/linux/ratelimit_types.h \
+  include/uapi/linux/param.h \
+  arch/arm/include/generated/uapi/asm/param.h \
+  include/asm-generic/param.h \
+    $(wildcard include/config/hz.h) \
+  include/uapi/asm-generic/param.h \
+  include/linux/spinlock_types.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep_types.h \
+    $(wildcard include/config/prove/raw/lock/nesting.h) \
+    $(wildcard include/config/preempt/lock.h) \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+  include/linux/rwlock_types.h \
+  arch/arm/include/asm/div64.h \
+  arch/arm/include/asm/compiler.h \
+  include/asm-generic/div64.h \
+  arch/arm/include/asm/delay.h \
+  arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/xip/kernel.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+    $(wildcard include/config/xip/phys/addr.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  include/linux/pfn.h \
+  include/linux/fs.h \
+    $(wildcard include/config/read/only/thp/for/fs.h) \
+    $(wildcard include/config/fs/posix/acl.h) \
+    $(wildcard include/config/security.h) \
+    $(wildcard include/config/cgroup/writeback.h) \
+    $(wildcard include/config/ima.h) \
+    $(wildcard include/config/file/locking.h) \
+    $(wildcard include/config/fsnotify.h) \
+    $(wildcard include/config/fs/encryption.h) \
+    $(wildcard include/config/fs/verity.h) \
+    $(wildcard include/config/preemption.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/unicode.h) \
+    $(wildcard include/config/compat.h) \
+    $(wildcard include/config/quota.h) \
+    $(wildcard include/config/fs/dax.h) \
+    $(wildcard include/config/mandatory/file/locking.h) \
+    $(wildcard include/config/block.h) \
+    $(wildcard include/config/migration.h) \
+  include/linux/wait_bit.h \
+  include/linux/wait.h \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+    $(wildcard include/config/page/poisoning/zero.h) \
+  include/linux/spinlock.h \
+  include/linux/preempt.h \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/trace/preempt/toggle.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  arch/arm/include/generated/asm/preempt.h \
+  include/asm-generic/preempt.h \
+  include/linux/thread_info.h \
+    $(wildcard include/config/thread/info/in/task.h) \
+    $(wildcard include/config/have/arch/within/stack/frames.h) \
+    $(wildcard include/config/hardened/usercopy.h) \
+  include/linux/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/bug/on/data/corruption.h) \
+  arch/arm/include/asm/bug.h \
+    $(wildcard include/config/debug/bugverbose.h) \
+  arch/arm/include/asm/opcodes.h \
+    $(wildcard include/config/cpu/endian/be32.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  include/linux/instrumentation.h \
+    $(wildcard include/config/debug/entry.h) \
+  include/linux/restart_block.h \
+  include/linux/time64.h \
+  include/linux/math64.h \
+    $(wildcard include/config/arch/supports/int128.h) \
+  include/vdso/math64.h \
+  include/vdso/time64.h \
+  include/uapi/linux/time.h \
+  include/uapi/linux/time_types.h \
+  include/linux/errno.h \
+  include/uapi/linux/errno.h \
+  arch/arm/include/generated/uapi/asm/errno.h \
+  include/uapi/asm-generic/errno.h \
+  include/uapi/asm-generic/errno-base.h \
+  arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/stackprotector/per/task.h) \
+    $(wildcard include/config/crunch.h) \
+    $(wildcard include/config/arm/thumbee.h) \
+  arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+    $(wildcard include/config/kuser/helpers.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+  arch/arm/include/asm/glue.h \
+  arch/arm/include/asm/pgtable-2level-types.h \
+  include/asm-generic/getorder.h \
+  include/linux/bottom_half.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/debug/locking/api/selftests.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/up/late/init.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+    $(wildcard include/config/fortify/source.h) \
+  include/uapi/linux/string.h \
+  arch/arm/include/asm/string.h \
+    $(wildcard include/config/bcm2835/fast/memcpy.h) \
+  include/linux/smp_types.h \
+  include/linux/llist.h \
+    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
+  arch/arm/include/asm/smp.h \
+  arch/arm/include/generated/asm/mmiowb.h \
+  include/asm-generic/mmiowb.h \
+    $(wildcard include/config/mmiowb.h) \
+  arch/arm/include/asm/spinlock.h \
+  include/linux/rwlock.h \
+    $(wildcard include/config/preempt.h) \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  arch/arm/include/generated/asm/current.h \
+  include/asm-generic/current.h \
+  include/uapi/linux/wait.h \
+  include/linux/kdev_t.h \
+  include/uapi/linux/kdev_t.h \
+  include/linux/dcache.h \
+  include/linux/rculist.h \
+    $(wildcard include/config/prove/rcu/list.h) \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tasks/rcu/generic.h) \
+    $(wildcard include/config/rcu/stall/common.h) \
+    $(wildcard include/config/no/hz/full.h) \
+    $(wildcard include/config/rcu/nocb/cpu.h) \
+    $(wildcard include/config/tasks/rcu.h) \
+    $(wildcard include/config/tasks/trace/rcu.h) \
+    $(wildcard include/config/tasks/rude/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/prove/rcu.h) \
+    $(wildcard include/config/rcu/boost.h) \
+    $(wildcard include/config/arch/weak/release/acquire.h) \
+  include/linux/rcutree.h \
+  include/linux/rculist_bl.h \
+  include/linux/list_bl.h \
+  include/linux/bit_spinlock.h \
+  include/linux/seqlock.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/mutex/spin/on/owner.h) \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/osq_lock.h \
+  include/linux/debug_locks.h \
+  include/linux/ww_mutex.h \
+    $(wildcard include/config/debug/ww/mutex/slowpath.h) \
+  include/linux/lockref.h \
+    $(wildcard include/config/arch/use/cmpxchg/lockref.h) \
+  include/generated/bounds.h \
+  include/linux/stringhash.h \
+    $(wildcard include/config/dcache/word/access.h) \
+  include/linux/hash.h \
+    $(wildcard include/config/have/arch/hash.h) \
+  include/linux/path.h \
+  include/linux/stat.h \
+  arch/arm/include/uapi/asm/stat.h \
+  include/uapi/linux/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+    $(wildcard include/config/posix/timers.h) \
+  include/linux/time32.h \
+  include/linux/timex.h \
+  include/uapi/linux/timex.h \
+  arch/arm/include/asm/timex.h \
+  include/vdso/time32.h \
+  include/vdso/time.h \
+  include/linux/uidgid.h \
+    $(wildcard include/config/multiuser.h) \
+    $(wildcard include/config/user/ns.h) \
+  include/linux/highuid.h \
+  include/linux/list_lru.h \
+    $(wildcard include/config/memcg/kmem.h) \
+  include/linux/nodemask.h \
+    $(wildcard include/config/numa.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+    $(wildcard include/config/numa/keep/meminfo.h) \
+  include/linux/shrinker.h \
+    $(wildcard include/config/memcg.h) \
+  include/linux/radix-tree.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/vm/pgflags.h) \
+  include/linux/xarray.h \
+    $(wildcard include/config/xarray/multi.h) \
+  include/linux/gfp.h \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/zone/device.h) \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/contig/alloc.h) \
+    $(wildcard include/config/cma.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/isolation.h) \
+    $(wildcard include/config/zsmalloc.h) \
+    $(wildcard include/config/shadow/call/stack.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/transparent/hugepage.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/page/extension.h) \
+    $(wildcard include/config/deferred/struct/page/init.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/page-flags-layout.h \
+    $(wildcard include/config/numa/balancing.h) \
+    $(wildcard include/config/kasan/sw/tags.h) \
+  include/linux/mm_types.h \
+    $(wildcard include/config/have/aligned/struct/page.h) \
+    $(wildcard include/config/userfaultfd.h) \
+    $(wildcard include/config/swap.h) \
+    $(wildcard include/config/have/arch/compat/mmap/bases.h) \
+    $(wildcard include/config/membarrier.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+    $(wildcard include/config/arch/want/batched/unmap/tlb/flush.h) \
+    $(wildcard include/config/iommu/support.h) \
+  include/linux/mm_types_task.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/arch/enable/split/pmd/ptlock.h) \
+  include/linux/auxvec.h \
+  include/uapi/linux/auxvec.h \
+  arch/arm/include/asm/auxvec.h \
+  arch/arm/include/uapi/asm/auxvec.h \
+  include/linux/rbtree.h \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/spin/on/owner.h) \
+    $(wildcard include/config/debug/rwsems.h) \
+  include/linux/err.h \
+  include/linux/completion.h \
+  include/linux/swait.h \
+  include/linux/uprobes.h \
+    $(wildcard include/config/uprobes.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+    $(wildcard include/config/sysfs.h) \
+    $(wildcard include/config/wq/watchdog.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/debug/objects/timers.h) \
+    $(wildcard include/config/no/hz/common.h) \
+  include/linux/ktime.h \
+  include/linux/jiffies.h \
+  include/vdso/jiffies.h \
+  include/generated/timeconst.h \
+  include/vdso/ktime.h \
+  include/linux/timekeeping.h \
+  include/linux/timekeeping32.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+    $(wildcard include/config/vdso.h) \
+  include/linux/page-flags.h \
+    $(wildcard include/config/arch/uses/pg/uncached.h) \
+    $(wildcard include/config/memory/failure.h) \
+    $(wildcard include/config/idle/page/tracking.h) \
+    $(wildcard include/config/thp/swap.h) \
+    $(wildcard include/config/ksm.h) \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/arch/has/add/pages.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/have/bootmem/info/node.h) \
+  include/linux/notifier.h \
+    $(wildcard include/config/tree/srcu.h) \
+  include/linux/srcu.h \
+    $(wildcard include/config/tiny/srcu.h) \
+    $(wildcard include/config/srcu.h) \
+  include/linux/rcu_segcblist.h \
+  include/linux/srcutree.h \
+  include/linux/rcu_node_tree.h \
+    $(wildcard include/config/rcu/fanout.h) \
+    $(wildcard include/config/rcu/fanout/leaf.h) \
+  include/linux/topology.h \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+    $(wildcard include/config/sched/smt.h) \
+  include/linux/arch_topology.h \
+    $(wildcard include/config/generic/arch/topology.h) \
+  arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+    $(wildcard include/config/bl/switcher.h) \
+  include/asm-generic/topology.h \
+  include/linux/kconfig.h \
+  include/linux/local_lock.h \
+  include/linux/local_lock_internal.h \
+  include/linux/pid.h \
+  include/linux/refcount.h \
+  include/linux/capability.h \
+  include/uapi/linux/capability.h \
+  include/linux/semaphore.h \
+  include/linux/fcntl.h \
+    $(wildcard include/config/arch/32bit/off/t.h) \
+  include/uapi/linux/fcntl.h \
+  arch/arm/include/uapi/asm/fcntl.h \
+  include/uapi/asm-generic/fcntl.h \
+  include/uapi/linux/openat2.h \
+  include/linux/migrate_mode.h \
+  include/linux/percpu-rwsem.h \
+  include/linux/rcuwait.h \
+  include/linux/sched/signal.h \
+    $(wildcard include/config/sched/autogroup.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/stack/growsup.h) \
+  include/linux/signal.h \
+    $(wildcard include/config/proc/fs.h) \
+  include/linux/signal_types.h \
+    $(wildcard include/config/old/sigaction.h) \
+  include/uapi/linux/signal.h \
+  arch/arm/include/asm/signal.h \
+  arch/arm/include/uapi/asm/signal.h \
+  include/uapi/asm-generic/signal-defs.h \
+  arch/arm/include/uapi/asm/sigcontext.h \
+  arch/arm/include/generated/uapi/asm/siginfo.h \
+  include/uapi/asm-generic/siginfo.h \
+  include/linux/sched.h \
+    $(wildcard include/config/virt/cpu/accounting/native.h) \
+    $(wildcard include/config/sched/info.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/uclamp/task.h) \
+    $(wildcard include/config/uclamp/buckets/count.h) \
+    $(wildcard include/config/cgroup/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/psi.h) \
+    $(wildcard include/config/compat/brk.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/blk/cgroup.h) \
+    $(wildcard include/config/stackprotector.h) \
+    $(wildcard include/config/arch/has/scaled/cputime.h) \
+    $(wildcard include/config/virt/cpu/accounting/gen.h) \
+    $(wildcard include/config/posix/cputimers.h) \
+    $(wildcard include/config/posix/cpu/timers/task/work.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/io/uring.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/ubsan.h) \
+    $(wildcard include/config/ubsan/trap.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/x86/cpu/resctrl.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/rseq.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/kunit.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/bcache.h) \
+    $(wildcard include/config/vmap/stack.h) \
+    $(wildcard include/config/livepatch.h) \
+    $(wildcard include/config/gcc/plugin/stackleak.h) \
+    $(wildcard include/config/x86/mce.h) \
+    $(wildcard include/config/arch/task/struct/on/stack.h) \
+    $(wildcard include/config/debug/rseq.h) \
+  include/uapi/linux/sched.h \
+  include/linux/sem.h \
+  include/uapi/linux/sem.h \
+  include/linux/ipc.h \
+  include/linux/rhashtable-types.h \
+  include/uapi/linux/ipc.h \
+  arch/arm/include/generated/uapi/asm/ipcbuf.h \
+  include/uapi/asm-generic/ipcbuf.h \
+  arch/arm/include/generated/uapi/asm/sembuf.h \
+  include/uapi/asm-generic/sembuf.h \
+  include/linux/shm.h \
+  include/uapi/linux/shm.h \
+  include/uapi/asm-generic/hugetlb_encode.h \
+  arch/arm/include/generated/uapi/asm/shmbuf.h \
+  include/uapi/asm-generic/shmbuf.h \
+  arch/arm/include/asm/shmparam.h \
+  include/linux/kcov.h \
+  include/uapi/linux/kcov.h \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/plist.h) \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+    $(wildcard include/config/time/low/res.h) \
+    $(wildcard include/config/timerfd.h) \
+  include/linux/hrtimer_defs.h \
+  include/linux/timerqueue.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+    $(wildcard include/config/have/arch/seccomp/filter.h) \
+    $(wildcard include/config/seccomp/filter.h) \
+    $(wildcard include/config/checkpoint/restore.h) \
+  include/uapi/linux/seccomp.h \
+  arch/arm/include/generated/asm/seccomp.h \
+  include/asm-generic/seccomp.h \
+  include/uapi/linux/unistd.h \
+  arch/arm/include/asm/unistd.h \
+    $(wildcard include/config/oabi/compat.h) \
+  arch/arm/include/uapi/asm/unistd.h \
+  arch/arm/include/generated/uapi/asm/unistd-eabi.h \
+  arch/arm/include/generated/uapi/asm/unistd-common.h \
+  arch/arm/include/generated/asm/unistd-nr.h \
+  include/linux/resource.h \
+  include/uapi/linux/resource.h \
+  arch/arm/include/generated/uapi/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/uapi/asm-generic/resource.h \
+  include/linux/latencytop.h \
+  include/linux/sched/prio.h \
+  include/linux/sched/types.h \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/posix-timers.h \
+  include/linux/alarmtimer.h \
+    $(wildcard include/config/rtc/class.h) \
+  include/linux/task_work.h \
+  include/uapi/linux/rseq.h \
+  include/linux/kcsan.h \
+  include/linux/sched/jobctl.h \
+  include/linux/sched/task.h \
+    $(wildcard include/config/have/exit/thread.h) \
+    $(wildcard include/config/arch/wants/dynamic/task/struct.h) \
+    $(wildcard include/config/have/arch/thread/struct/whitelist.h) \
+  include/linux/uaccess.h \
+    $(wildcard include/config/set/fs.h) \
+  include/linux/fault-inject-usercopy.h \
+    $(wildcard include/config/fault/injection/usercopy.h) \
+  include/linux/instrumented.h \
+  arch/arm/include/asm/uaccess.h \
+    $(wildcard include/config/cpu/sw/domain/pan.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+    $(wildcard include/config/uaccess/with/memcpy.h) \
+  arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/cp15/mmu.h) \
+  arch/arm/include/generated/asm/extable.h \
+  include/asm-generic/extable.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+  include/linux/key.h \
+    $(wildcard include/config/key/notifications.h) \
+    $(wildcard include/config/net.h) \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/uapi/linux/sysctl.h \
+  include/linux/assoc_array.h \
+    $(wildcard include/config/associative/array.h) \
+  include/linux/sched/user.h \
+    $(wildcard include/config/fanotify.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/bpf/syscall.h) \
+    $(wildcard include/config/watch/queue.h) \
+  include/linux/ratelimit.h \
+  include/linux/rcu_sync.h \
+  include/linux/delayed_call.h \
+  include/linux/uuid.h \
+  include/uapi/linux/uuid.h \
+  include/linux/errseq.h \
+  include/linux/ioprio.h \
+  include/linux/sched/rt.h \
+  include/linux/iocontext.h \
+  include/linux/fs_types.h \
+  include/uapi/linux/fs.h \
+  include/uapi/linux/ioctl.h \
+  arch/arm/include/generated/uapi/asm/ioctl.h \
+  include/asm-generic/ioctl.h \
+  include/uapi/asm-generic/ioctl.h \
+  include/linux/quota.h \
+    $(wildcard include/config/quota/netlink/interface.h) \
+  include/linux/percpu_counter.h \
+  include/uapi/linux/dqblk_xfs.h \
+  include/linux/dqblk_v1.h \
+  include/linux/dqblk_v2.h \
+  include/linux/dqblk_qtree.h \
+  include/linux/projid.h \
+  include/uapi/linux/quota.h \
+  include/linux/nfs_fs_i.h \
+  include/linux/gpio.h \
+    $(wildcard include/config/gpiolib.h) \
+    $(wildcard include/config/arch/have/custom/gpio/h.h) \
+  arch/arm/include/asm/gpio.h \
+    $(wildcard include/config/arch/nr/gpio.h) \
+  include/asm-generic/gpio.h \
+  include/linux/gpio/driver.h \
+    $(wildcard include/config/irq/domain/hierarchy.h) \
+    $(wildcard include/config/gpio/generic.h) \
+    $(wildcard include/config/gpiolib/irqchip.h) \
+    $(wildcard include/config/of/gpio.h) \
+    $(wildcard include/config/of.h) \
+    $(wildcard include/config/pinctrl.h) \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/energy/model.h) \
+    $(wildcard include/config/generic/msi/irq/domain.h) \
+    $(wildcard include/config/generic/msi/irq.h) \
+    $(wildcard include/config/dma/ops.h) \
+    $(wildcard include/config/dma/declare/coherent.h) \
+    $(wildcard include/config/dma/cma.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/device.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu/all.h) \
+    $(wildcard include/config/dma/ops/bypass.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/dev_printk.h \
+  include/linux/energy_model.h \
+  include/linux/jump_label.h \
+    $(wildcard include/config/jump/label.h) \
+    $(wildcard include/config/have/arch/jump/label/relative.h) \
+  arch/arm/include/asm/jump_label.h \
+  include/linux/kobject.h \
+    $(wildcard include/config/uevent/helper.h) \
+    $(wildcard include/config/debug/kobject/release.h) \
+  include/linux/sysfs.h \
+  include/linux/kernfs.h \
+    $(wildcard include/config/kernfs.h) \
+  include/linux/idr.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/sched/cpufreq.h \
+    $(wildcard include/config/cpu/freq.h) \
+  include/linux/sched/topology.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/sched/idle.h \
+  include/linux/sched/sd_flags.h \
+  include/linux/ioport.h \
+    $(wildcard include/config/io/strict/devmem.h) \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/vt/console/sleep.h) \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  include/linux/overflow.h \
+  include/linux/device/bus.h \
+    $(wildcard include/config/acpi.h) \
+  include/linux/device/class.h \
+  include/linux/device/driver.h \
+  arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/arm/dma/use/iommu.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/irq.h \
+    $(wildcard include/config/generic/irq/effective/aff/mask.h) \
+    $(wildcard include/config/generic/irq/ipi.h) \
+    $(wildcard include/config/generic/irq/migration.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+    $(wildcard include/config/hardirqs/sw/resend.h) \
+    $(wildcard include/config/generic/irq/legacy/alloc/hwirq.h) \
+    $(wildcard include/config/generic/irq/legacy.h) \
+    $(wildcard include/config/generic/irq/multi/handler.h) \
+  include/linux/irqhandler.h \
+  include/linux/irqreturn.h \
+  include/linux/irqnr.h \
+  include/uapi/linux/irqnr.h \
+  include/linux/io.h \
+    $(wildcard include/config/have/arch/huge/vmap.h) \
+    $(wildcard include/config/has/ioport/map.h) \
+    $(wildcard include/config/pci.h) \
+  arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/asm-generic/io.h \
+    $(wildcard include/config/generic/iomap.h) \
+    $(wildcard include/config/generic/ioremap.h) \
+    $(wildcard include/config/virt/to/bus.h) \
+  include/linux/logic_pio.h \
+    $(wildcard include/config/indirect/pio.h) \
+  include/linux/fwnode.h \
+  include/linux/vmalloc.h \
+    $(wildcard include/config/kasan/vmalloc.h) \
+  arch/arm/include/asm/vmalloc.h \
+  include/linux/slab.h \
+    $(wildcard include/config/debug/slab.h) \
+    $(wildcard include/config/failslab.h) \
+    $(wildcard include/config/have/hardened/usercopy/allocator.h) \
+    $(wildcard include/config/slab.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+  include/linux/percpu-refcount.h \
+  include/linux/kasan.h \
+    $(wildcard include/config/kasan/generic.h) \
+    $(wildcard include/config/kasan/inline.h) \
+  arch/arm/include/asm/irq.h \
+    $(wildcard include/config/sparse/irq.h) \
+  arch/arm/include/generated/asm/irq_regs.h \
+  include/asm-generic/irq_regs.h \
+  include/linux/irqdesc.h \
+    $(wildcard include/config/generic/irq/debugfs.h) \
+    $(wildcard include/config/handle/domain/irq.h) \
+    $(wildcard include/config/irq/domain.h) \
+  arch/arm/include/asm/hw_irq.h \
+  include/linux/irqchip/chained_irq.h \
+  include/linux/irqdomain.h \
+  include/linux/of.h \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/promtree.h) \
+    $(wildcard include/config/of/kobj.h) \
+    $(wildcard include/config/of/numa.h) \
+    $(wildcard include/config/of/overlay.h) \
+  include/linux/mod_devicetable.h \
+  include/linux/property.h \
+  include/linux/pinctrl/pinctrl.h \
+    $(wildcard include/config/generic/pinconf.h) \
+  include/linux/seq_file.h \
+  include/linux/pinctrl/pinctrl-state.h \
+  include/linux/pinctrl/devinfo.h \
+  include/linux/pinctrl/consumer.h \
+  include/linux/pinctrl/pinconf-generic.h \
+  include/linux/pinctrl/machine.h \
+  include/linux/gpio/consumer.h \
+    $(wildcard include/config/gpio/sysfs.h) \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/slave.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+    $(wildcard include/config/i2c/mux.h) \
+  include/linux/acpi.h \
+    $(wildcard include/config/acpi/debugger.h) \
+    $(wildcard include/config/x86.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/acpi/processor/cstate.h) \
+    $(wildcard include/config/acpi/hotplug/cpu.h) \
+    $(wildcard include/config/acpi/hotplug/ioapic.h) \
+    $(wildcard include/config/x86/io/apic.h) \
+    $(wildcard include/config/acpi/wmi.h) \
+    $(wildcard include/config/acpi/numa.h) \
+    $(wildcard include/config/hibernation.h) \
+    $(wildcard include/config/acpi/hotplug/memory.h) \
+    $(wildcard include/config/acpi/container.h) \
+    $(wildcard include/config/acpi/gtdt.h) \
+    $(wildcard include/config/acpi/table/upgrade.h) \
+    $(wildcard include/config/acpi/watchdog.h) \
+    $(wildcard include/config/acpi/spcr/table.h) \
+    $(wildcard include/config/acpi/generic/gsi.h) \
+    $(wildcard include/config/acpi/lpit.h) \
+    $(wildcard include/config/acpi/pptt.h) \
+  include/linux/resource_ext.h \
+  include/acpi/acpi.h \
+  include/acpi/platform/acenv.h \
+  include/acpi/platform/acgcc.h \
+  include/acpi/platform/aclinux.h \
+    $(wildcard include/config/acpi/reduced/hardware/only.h) \
+    $(wildcard include/config/acpi/debug.h) \
+  include/linux/ctype.h \
+  include/acpi/acnames.h \
+  include/acpi/actypes.h \
+  include/acpi/acexcep.h \
+  include/acpi/actbl.h \
+  include/acpi/actbl1.h \
+  include/acpi/actbl2.h \
+  include/acpi/actbl3.h \
+  include/acpi/acrestyp.h \
+  include/acpi/platform/acenvex.h \
+  include/acpi/platform/aclinuxex.h \
+  include/acpi/platform/acgccex.h \
+  include/acpi/acoutput.h \
+  include/acpi/acpiosxf.h \
+  include/acpi/acpixf.h \
+  include/acpi/acconfig.h \
+  include/acpi/acbuffer.h \
+  include/acpi/acpi_numa.h \
+    $(wildcard include/config/acpi/hmat.h) \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/uapi/linux/i2c.h \
+  include/linux/interrupt.h \
+    $(wildcard include/config/irq/forced/threading.h) \
+    $(wildcard include/config/generic/irq/probe.h) \
+    $(wildcard include/config/irq/timings.h) \
+  include/linux/hardirq.h \
+  include/linux/context_tracking_state.h \
+    $(wildcard include/config/context/tracking.h) \
+  include/linux/static_key.h \
+  include/linux/ftrace_irq.h \
+    $(wildcard include/config/hwlat/tracer.h) \
+  include/linux/vtime.h \
+    $(wildcard include/config/virt/cpu/accounting.h) \
+    $(wildcard include/config/irq/time/accounting.h) \
+  arch/arm/include/asm/hardirq.h \
+  include/linux/irq_cpustat.h \
+  arch/arm/include/asm/sections.h \
+  include/asm-generic/sections.h \
+  drivers/input/touchscreen/hxchipset/himax_common.h \
+    $(wildcard include/config/touchscreen/himax/ic/hx83192.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83193.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83194.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83195.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83180.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83181.h) \
+    $(wildcard include/config/touchscreen/himax/self/test.h) \
+  include/linux/input.h \
+  include/uapi/linux/input.h \
+  include/uapi/linux/input-event-codes.h \
+  include/linux/module.h \
+    $(wildcard include/config/modules/tree/lookup.h) \
+    $(wildcard include/config/module/sig.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/bpf/events.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/kprobes.h) \
+    $(wildcard include/config/have/static/call/inline.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/function/error/injection.h) \
+  include/linux/kmod.h \
+  include/linux/umh.h \
+  include/linux/elf.h \
+    $(wildcard include/config/arch/use/gnu/property.h) \
+    $(wildcard include/config/arch/have/elf/prot.h) \
+  arch/arm/include/asm/elf.h \
+  arch/arm/include/asm/vdso_datapage.h \
+  include/vdso/datapage.h \
+    $(wildcard include/config/arch/has/vdso/data.h) \
+  include/uapi/asm-generic/errno-base.h \
+  include/vdso/clocksource.h \
+    $(wildcard include/config/generic/gettimeofday.h) \
+  arch/arm/include/asm/vdso/clocksource.h \
+  include/vdso/processor.h \
+  arch/arm/include/asm/vdso/gettimeofday.h \
+    $(wildcard include/config/arm/arch/timer.h) \
+  arch/arm/include/asm/vdso/cp15.h \
+    $(wildcard include/config/cpu/cp15.h) \
+  arch/arm/include/asm/user.h \
+  include/uapi/linux/elf.h \
+  include/uapi/linux/elf-em.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/rbtree_latch.h \
+  include/linux/error-injection.h \
+  include/asm-generic/error-injection.h \
+  include/linux/tracepoint-defs.h \
+  include/linux/static_call_types.h \
+    $(wildcard include/config/have/static/call.h) \
+  arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+    $(wildcard include/config/arm/module/plts.h) \
+  include/asm-generic/module.h \
+    $(wildcard include/config/have/mod/arch/specific.h) \
+    $(wildcard include/config/modules/use/elf/rel.h) \
+    $(wildcard include/config/modules/use/elf/rela.h) \
+  include/linux/async.h \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+    $(wildcard include/config/superh.h) \
+  include/linux/input/mt.h \
+  include/linux/firmware.h \
+    $(wildcard include/config/fw/loader.h) \
+  include/linux/buffer_head.h \
+  include/linux/pagemap.h \
+  include/linux/mm.h \
+    $(wildcard include/config/have/arch/mmap/rnd/bits.h) \
+    $(wildcard include/config/have/arch/mmap/rnd/compat/bits.h) \
+    $(wildcard include/config/mem/soft/dirty.h) \
+    $(wildcard include/config/arch/uses/high/vma/flags.h) \
+    $(wildcard include/config/arch/has/pkeys.h) \
+    $(wildcard include/config/ppc.h) \
+    $(wildcard include/config/parisc.h) \
+    $(wildcard include/config/sparc64.h) \
+    $(wildcard include/config/arm64/mte.h) \
+    $(wildcard include/config/shmem.h) \
+    $(wildcard include/config/dev/pagemap/ops.h) \
+    $(wildcard include/config/device/private.h) \
+    $(wildcard include/config/pci/p2pdma.h) \
+    $(wildcard include/config/arch/has/pte/special.h) \
+    $(wildcard include/config/arch/has/pte/devmap.h) \
+    $(wildcard include/config/debug/vm/rb.h) \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/init/on/alloc/default/on.h) \
+    $(wildcard include/config/init/on/free/default/on.h) \
+    $(wildcard include/config/debug/pagealloc.h) \
+    $(wildcard include/config/arch/has/set/direct/map.h) \
+    $(wildcard include/config/hugetlbfs.h) \
+    $(wildcard include/config/mapping/dirty/helpers.h) \
+  include/linux/mmap_lock.h \
+  include/linux/range.h \
+  include/linux/page_ext.h \
+  include/linux/stacktrace.h \
+    $(wildcard include/config/stacktrace.h) \
+    $(wildcard include/config/arch/stackwalk.h) \
+    $(wildcard include/config/have/reliable/stacktrace.h) \
+  include/linux/stackdepot.h \
+  include/linux/page_ref.h \
+    $(wildcard include/config/debug/page/ref.h) \
+  include/linux/memremap.h \
+  include/linux/pgtable.h \
+    $(wildcard include/config/pgtable/levels.h) \
+    $(wildcard include/config/highpte.h) \
+    $(wildcard include/config/have/arch/transparent/hugepage/pud.h) \
+    $(wildcard include/config/have/arch/soft/dirty.h) \
+    $(wildcard include/config/arch/enable/thp/migration.h) \
+    $(wildcard include/config/x86/espfix64.h) \
+  arch/arm/include/asm/pgtable.h \
+  arch/arm/include/asm/proc-fns.h \
+    $(wildcard include/config/big/little.h) \
+    $(wildcard include/config/harden/branch/predictor.h) \
+  arch/arm/include/asm/glue-proc.h \
+    $(wildcard include/config/cpu/arm7tdmi.h) \
+    $(wildcard include/config/cpu/arm720t.h) \
+    $(wildcard include/config/cpu/arm740t.h) \
+    $(wildcard include/config/cpu/arm9tdmi.h) \
+    $(wildcard include/config/cpu/arm920t.h) \
+    $(wildcard include/config/cpu/arm922t.h) \
+    $(wildcard include/config/cpu/arm925t.h) \
+    $(wildcard include/config/cpu/arm926t.h) \
+    $(wildcard include/config/cpu/arm940t.h) \
+    $(wildcard include/config/cpu/arm946e.h) \
+    $(wildcard include/config/cpu/arm1020.h) \
+    $(wildcard include/config/cpu/arm1020e.h) \
+    $(wildcard include/config/cpu/arm1022.h) \
+    $(wildcard include/config/cpu/arm1026.h) \
+    $(wildcard include/config/cpu/mohawk.h) \
+    $(wildcard include/config/cpu/feroceon.h) \
+    $(wildcard include/config/cpu/v6k.h) \
+    $(wildcard include/config/cpu/pj4b.h) \
+    $(wildcard include/config/cpu/v7.h) \
+  include/asm-generic/pgtable-nopud.h \
+  include/asm-generic/pgtable-nop4d.h \
+  arch/arm/include/asm/pgtable-hwdef.h \
+  arch/arm/include/asm/pgtable-2level-hwdef.h \
+  arch/arm/include/asm/tlbflush.h \
+    $(wildcard include/config/smp/on/up.h) \
+    $(wildcard include/config/cpu/tlb/v4wt.h) \
+    $(wildcard include/config/cpu/tlb/fa.h) \
+    $(wildcard include/config/cpu/tlb/v4wbi.h) \
+    $(wildcard include/config/cpu/tlb/feroceon.h) \
+    $(wildcard include/config/cpu/tlb/v4wb.h) \
+    $(wildcard include/config/cpu/tlb/v6.h) \
+    $(wildcard include/config/cpu/tlb/v7.h) \
+    $(wildcard include/config/arm/errata/720789.h) \
+    $(wildcard include/config/arm/errata/798181.h) \
+  arch/arm/include/asm/pgtable-2level.h \
+  include/asm-generic/pgtable_uffd.h \
+    $(wildcard include/config/have/arch/userfaultfd/wp.h) \
+  include/linux/huge_mm.h \
+  include/linux/sched/coredump.h \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+  include/linux/vmstat.h \
+    $(wildcard include/config/vm/event/counters.h) \
+    $(wildcard include/config/debug/tlbflush.h) \
+    $(wildcard include/config/debug/vm/vmacache.h) \
+  include/linux/vm_event_item.h \
+    $(wildcard include/config/memory/balloon.h) \
+    $(wildcard include/config/balloon/compaction.h) \
+  include/linux/highmem.h \
+    $(wildcard include/config/x86/32.h) \
+    $(wildcard include/config/debug/highmem.h) \
+  arch/arm/include/asm/cacheflush.h \
+    $(wildcard include/config/arm/errata/411920.h) \
+    $(wildcard include/config/cpu/cache/vipt.h) \
+    $(wildcard include/config/outer/cache.h) \
+    $(wildcard include/config/frame/pointer.h) \
+    $(wildcard include/config/cpu/icache/mismatch/workaround.h) \
+  arch/arm/include/asm/glue-cache.h \
+    $(wildcard include/config/cpu/cache/v4.h) \
+    $(wildcard include/config/cpu/cache/v4wb.h) \
+    $(wildcard include/config/cache/b15/rac.h) \
+  arch/arm/include/asm/cachetype.h \
+    $(wildcard include/config/cpu/cache/vivt.h) \
+  arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+  arch/arm/include/asm/kmap_types.h \
+  include/linux/hugetlb_inline.h \
+  include/linux/proc_fs.h \
+    $(wildcard include/config/proc/pid/arch/status.h) \
+  include/linux/kallsyms.h \
+    $(wildcard include/config/kallsyms/all.h) \
+  include/linux/of_gpio.h \
+  include/generated/uapi/linux/version.h \
+  include/linux/rtc.h \
+    $(wildcard include/config/rtc/intf/dev/uie/emul.h) \
+    $(wildcard include/config/rtc/hctosys/device.h) \
+    $(wildcard include/config/rtc/nvmem.h) \
+    $(wildcard include/config/rtc/intf/sysfs.h) \
+  include/linux/nvmem-provider.h \
+    $(wildcard include/config/nvmem.h) \
+  include/uapi/linux/rtc.h \
+  include/linux/cdev.h \
+  include/linux/poll.h \
+  include/uapi/linux/poll.h \
+  arch/arm/include/generated/uapi/asm/poll.h \
+  include/uapi/asm-generic/poll.h \
+  include/uapi/linux/eventpoll.h \
+  include/linux/fb.h \
+    $(wildcard include/config/gumstix/am200epd.h) \
+    $(wildcard include/config/fb/notify.h) \
+    $(wildcard include/config/fb/deferred/io.h) \
+    $(wildcard include/config/fb/tileblitting.h) \
+    $(wildcard include/config/fb/backlight.h) \
+    $(wildcard include/config/fb/foreign/endian.h) \
+    $(wildcard include/config/fb/both/endian.h) \
+    $(wildcard include/config/fb/big/endian.h) \
+    $(wildcard include/config/fb/little/endian.h) \
+  include/linux/kgdb.h \
+    $(wildcard include/config/have/arch/kgdb.h) \
+    $(wildcard include/config/kgdb.h) \
+    $(wildcard include/config/serial/kgdb/nmi.h) \
+    $(wildcard include/config/kgdb/honour/blocklist.h) \
+  include/linux/kprobes.h \
+    $(wildcard include/config/kretprobes.h) \
+    $(wildcard include/config/kprobes/sanity/test.h) \
+    $(wildcard include/config/optprobes.h) \
+    $(wildcard include/config/kprobes/on/ftrace.h) \
+  include/linux/ftrace.h \
+    $(wildcard include/config/function/tracer.h) \
+    $(wildcard include/config/dynamic/ftrace.h) \
+    $(wildcard include/config/dynamic/ftrace/with/regs.h) \
+    $(wildcard include/config/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/have/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/stack/tracer.h) \
+    $(wildcard include/config/function/profiler.h) \
+    $(wildcard include/config/ftrace/syscalls.h) \
+  include/linux/trace_clock.h \
+  arch/arm/include/generated/asm/trace_clock.h \
+  include/asm-generic/trace_clock.h \
+  include/linux/ptrace.h \
+  include/linux/pid_namespace.h \
+    $(wildcard include/config/pid/ns.h) \
+  include/linux/nsproxy.h \
+  include/linux/ns_common.h \
+  include/uapi/linux/ptrace.h \
+  arch/arm/include/asm/ftrace.h \
+  arch/arm/include/asm/kprobes.h \
+  include/asm-generic/kprobes.h \
+  arch/arm/include/asm/probes.h \
+  arch/arm/include/asm/kgdb.h \
+  include/uapi/linux/fb.h \
+  include/linux/backlight.h \
+    $(wildcard include/config/backlight/class/device.h) \
+  drivers/input/touchscreen/hxchipset/himax_ic_core.h \
+
+drivers/input/touchscreen/hxchipset/himax_debug.o: $(deps_drivers/input/touchscreen/hxchipset/himax_debug.o)
+
+$(deps_drivers/input/touchscreen/hxchipset/himax_debug.o):
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_debug.o.d linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_debug.o.d
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_debug.o.d	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_debug.o.d	2024-06-14 10:43:31.768852723 +0200
@@ -0,0 +1,274 @@
+himax_debug.o: drivers/input/touchscreen/hxchipset/himax_debug.c \
+ include/linux/kconfig.h include/generated/autoconf.h \
+ include/linux/compiler_types.h include/linux/compiler_attributes.h \
+ include/linux/compiler-gcc.h \
+ drivers/input/touchscreen/hxchipset/himax_debug.h \
+ drivers/input/touchscreen/hxchipset/himax_platform.h \
+ include/linux/delay.h include/linux/kernel.h include/linux/limits.h \
+ include/uapi/linux/limits.h include/linux/types.h \
+ include/uapi/linux/types.h arch/arm/include/uapi/asm/types.h \
+ include/asm-generic/int-ll64.h include/uapi/asm-generic/int-ll64.h \
+ arch/arm/include/generated/uapi/asm/bitsperlong.h \
+ include/asm-generic/bitsperlong.h include/uapi/asm-generic/bitsperlong.h \
+ include/uapi/linux/posix_types.h include/linux/stddef.h \
+ include/uapi/linux/stddef.h include/linux/compiler_types.h \
+ arch/arm/include/uapi/asm/posix_types.h \
+ include/uapi/asm-generic/posix_types.h include/vdso/limits.h \
+ include/linux/linkage.h include/linux/stringify.h include/linux/export.h \
+ arch/arm/include/asm/linkage.h include/linux/compiler.h \
+ arch/arm/include/generated/asm/rwonce.h include/asm-generic/rwonce.h \
+ include/linux/kasan-checks.h include/linux/kcsan-checks.h \
+ include/linux/bitops.h include/linux/bits.h include/linux/const.h \
+ include/vdso/const.h include/uapi/linux/const.h include/vdso/bits.h \
+ include/linux/build_bug.h arch/arm/include/asm/bitops.h \
+ include/linux/irqflags.h include/linux/typecheck.h \
+ arch/arm/include/asm/irqflags.h arch/arm/include/asm/ptrace.h \
+ arch/arm/include/uapi/asm/ptrace.h arch/arm/include/asm/hwcap.h \
+ arch/arm/include/uapi/asm/hwcap.h include/asm-generic/irqflags.h \
+ arch/arm/include/asm/percpu.h include/asm-generic/percpu.h \
+ include/linux/threads.h include/linux/percpu-defs.h \
+ arch/arm/include/asm/barrier.h include/asm-generic/barrier.h \
+ include/asm-generic/bitops/non-atomic.h \
+ include/asm-generic/bitops/builtin-__fls.h \
+ include/asm-generic/bitops/builtin-__ffs.h \
+ include/asm-generic/bitops/builtin-fls.h \
+ include/asm-generic/bitops/builtin-ffs.h \
+ include/asm-generic/bitops/ffz.h include/asm-generic/bitops/fls64.h \
+ include/asm-generic/bitops/sched.h include/asm-generic/bitops/hweight.h \
+ include/asm-generic/bitops/arch_hweight.h \
+ include/asm-generic/bitops/const_hweight.h \
+ include/asm-generic/bitops/lock.h include/linux/atomic.h \
+ arch/arm/include/asm/atomic.h include/linux/prefetch.h \
+ arch/arm/include/asm/processor.h arch/arm/include/asm/hw_breakpoint.h \
+ arch/arm/include/asm/unified.h arch/arm/include/asm/vdso/processor.h \
+ arch/arm/include/asm/cache.h arch/arm/include/asm/cmpxchg.h \
+ include/asm-generic/cmpxchg-local.h include/linux/atomic-fallback.h \
+ include/asm-generic/atomic-long.h include/asm-generic/bitops/find.h \
+ include/asm-generic/bitops/le.h arch/arm/include/uapi/asm/byteorder.h \
+ include/linux/byteorder/little_endian.h \
+ include/uapi/linux/byteorder/little_endian.h include/linux/swab.h \
+ include/uapi/linux/swab.h arch/arm/include/asm/swab.h \
+ arch/arm/include/uapi/asm/swab.h include/linux/byteorder/generic.h \
+ include/asm-generic/bitops/ext2-atomic-setbit.h include/linux/log2.h \
+ include/linux/minmax.h include/linux/printk.h include/linux/init.h \
+ include/linux/kern_levels.h include/linux/cache.h \
+ include/uapi/linux/kernel.h include/uapi/linux/sysinfo.h \
+ include/linux/ratelimit_types.h include/uapi/linux/param.h \
+ arch/arm/include/generated/uapi/asm/param.h include/asm-generic/param.h \
+ include/uapi/asm-generic/param.h include/linux/spinlock_types.h \
+ arch/arm/include/asm/spinlock_types.h include/linux/lockdep_types.h \
+ include/linux/rwlock_types.h arch/arm/include/asm/div64.h \
+ arch/arm/include/asm/compiler.h include/asm-generic/div64.h \
+ arch/arm/include/asm/delay.h arch/arm/include/asm/memory.h \
+ include/linux/sizes.h include/asm-generic/memory_model.h \
+ include/linux/pfn.h include/linux/fs.h include/linux/wait_bit.h \
+ include/linux/wait.h include/linux/list.h include/linux/poison.h \
+ include/linux/spinlock.h include/linux/preempt.h \
+ arch/arm/include/generated/asm/preempt.h include/asm-generic/preempt.h \
+ include/linux/thread_info.h include/linux/bug.h \
+ arch/arm/include/asm/bug.h arch/arm/include/asm/opcodes.h \
+ include/asm-generic/bug.h include/linux/instrumentation.h \
+ include/linux/restart_block.h include/linux/time64.h \
+ include/linux/math64.h include/vdso/math64.h include/vdso/time64.h \
+ include/uapi/linux/time.h include/uapi/linux/time_types.h \
+ include/linux/errno.h include/uapi/linux/errno.h \
+ arch/arm/include/generated/uapi/asm/errno.h \
+ include/uapi/asm-generic/errno.h include/uapi/asm-generic/errno-base.h \
+ arch/arm/include/asm/thread_info.h arch/arm/include/asm/fpstate.h \
+ arch/arm/include/asm/page.h arch/arm/include/asm/glue.h \
+ arch/arm/include/asm/pgtable-2level-types.h \
+ include/asm-generic/getorder.h include/linux/bottom_half.h \
+ include/linux/lockdep.h include/linux/smp.h include/linux/cpumask.h \
+ include/linux/bitmap.h include/linux/string.h \
+ include/uapi/linux/string.h arch/arm/include/asm/string.h \
+ include/linux/smp_types.h include/linux/llist.h \
+ arch/arm/include/asm/smp.h arch/arm/include/generated/asm/mmiowb.h \
+ include/asm-generic/mmiowb.h arch/arm/include/asm/spinlock.h \
+ include/linux/rwlock.h include/linux/spinlock_api_smp.h \
+ include/linux/rwlock_api_smp.h arch/arm/include/generated/asm/current.h \
+ include/asm-generic/current.h include/uapi/linux/wait.h \
+ include/linux/kdev_t.h include/uapi/linux/kdev_t.h \
+ include/linux/dcache.h include/linux/rculist.h include/linux/rcupdate.h \
+ include/linux/rcutree.h include/linux/rculist_bl.h \
+ include/linux/list_bl.h include/linux/bit_spinlock.h \
+ include/linux/seqlock.h include/linux/mutex.h include/linux/osq_lock.h \
+ include/linux/debug_locks.h include/linux/ww_mutex.h \
+ include/linux/lockref.h include/generated/bounds.h \
+ include/linux/stringhash.h include/linux/hash.h include/linux/path.h \
+ include/linux/stat.h arch/arm/include/uapi/asm/stat.h \
+ include/uapi/linux/stat.h include/linux/time.h include/linux/time32.h \
+ include/linux/timex.h include/uapi/linux/timex.h \
+ arch/arm/include/asm/timex.h include/vdso/time32.h include/vdso/time.h \
+ include/linux/uidgid.h include/linux/highuid.h include/linux/list_lru.h \
+ include/linux/nodemask.h include/linux/numa.h include/linux/shrinker.h \
+ include/linux/radix-tree.h include/linux/percpu.h \
+ include/linux/mmdebug.h include/linux/xarray.h include/linux/gfp.h \
+ include/linux/mmzone.h include/linux/pageblock-flags.h \
+ include/linux/page-flags-layout.h include/linux/mm_types.h \
+ include/linux/mm_types_task.h include/linux/auxvec.h \
+ include/uapi/linux/auxvec.h arch/arm/include/asm/auxvec.h \
+ arch/arm/include/uapi/asm/auxvec.h include/linux/rbtree.h \
+ include/linux/rwsem.h include/linux/err.h include/linux/completion.h \
+ include/linux/swait.h include/linux/uprobes.h include/linux/workqueue.h \
+ include/linux/timer.h include/linux/ktime.h include/linux/jiffies.h \
+ include/vdso/jiffies.h include/generated/timeconst.h \
+ include/vdso/ktime.h include/linux/timekeeping.h \
+ include/linux/timekeeping32.h include/linux/debugobjects.h \
+ arch/arm/include/asm/mmu.h include/linux/page-flags.h \
+ include/linux/memory_hotplug.h include/linux/notifier.h \
+ include/linux/srcu.h include/linux/rcu_segcblist.h \
+ include/linux/srcutree.h include/linux/rcu_node_tree.h \
+ include/linux/topology.h include/linux/arch_topology.h \
+ arch/arm/include/asm/topology.h include/asm-generic/topology.h \
+ include/linux/kconfig.h include/linux/local_lock.h \
+ include/linux/local_lock_internal.h include/linux/pid.h \
+ include/linux/refcount.h include/linux/capability.h \
+ include/uapi/linux/capability.h include/linux/semaphore.h \
+ include/linux/fcntl.h include/uapi/linux/fcntl.h \
+ arch/arm/include/uapi/asm/fcntl.h include/uapi/asm-generic/fcntl.h \
+ include/uapi/linux/openat2.h include/linux/migrate_mode.h \
+ include/linux/percpu-rwsem.h include/linux/rcuwait.h \
+ include/linux/sched/signal.h include/linux/signal.h \
+ include/linux/signal_types.h include/uapi/linux/signal.h \
+ arch/arm/include/asm/signal.h arch/arm/include/uapi/asm/signal.h \
+ include/uapi/asm-generic/signal-defs.h \
+ arch/arm/include/uapi/asm/sigcontext.h \
+ arch/arm/include/generated/uapi/asm/siginfo.h \
+ include/uapi/asm-generic/siginfo.h include/linux/sched.h \
+ include/uapi/linux/sched.h include/linux/sem.h include/uapi/linux/sem.h \
+ include/linux/ipc.h include/linux/rhashtable-types.h \
+ include/uapi/linux/ipc.h arch/arm/include/generated/uapi/asm/ipcbuf.h \
+ include/uapi/asm-generic/ipcbuf.h \
+ arch/arm/include/generated/uapi/asm/sembuf.h \
+ include/uapi/asm-generic/sembuf.h include/linux/shm.h \
+ include/uapi/linux/shm.h include/uapi/asm-generic/hugetlb_encode.h \
+ arch/arm/include/generated/uapi/asm/shmbuf.h \
+ include/uapi/asm-generic/shmbuf.h arch/arm/include/asm/shmparam.h \
+ include/linux/kcov.h include/uapi/linux/kcov.h include/linux/plist.h \
+ include/linux/hrtimer.h include/linux/hrtimer_defs.h \
+ include/linux/timerqueue.h include/linux/seccomp.h \
+ include/uapi/linux/seccomp.h arch/arm/include/generated/asm/seccomp.h \
+ include/asm-generic/seccomp.h include/uapi/linux/unistd.h \
+ arch/arm/include/asm/unistd.h arch/arm/include/uapi/asm/unistd.h \
+ arch/arm/include/generated/uapi/asm/unistd-eabi.h \
+ arch/arm/include/generated/uapi/asm/unistd-common.h \
+ arch/arm/include/generated/asm/unistd-nr.h include/linux/resource.h \
+ include/uapi/linux/resource.h \
+ arch/arm/include/generated/uapi/asm/resource.h \
+ include/asm-generic/resource.h include/uapi/asm-generic/resource.h \
+ include/linux/latencytop.h include/linux/sched/prio.h \
+ include/linux/sched/types.h include/linux/task_io_accounting.h \
+ include/linux/posix-timers.h include/linux/alarmtimer.h \
+ include/linux/task_work.h include/uapi/linux/rseq.h \
+ include/linux/kcsan.h include/linux/sched/jobctl.h \
+ include/linux/sched/task.h include/linux/uaccess.h \
+ include/linux/fault-inject-usercopy.h include/linux/instrumented.h \
+ arch/arm/include/asm/uaccess.h arch/arm/include/asm/domain.h \
+ arch/arm/include/generated/asm/extable.h include/asm-generic/extable.h \
+ include/linux/cred.h include/linux/key.h include/linux/sysctl.h \
+ include/uapi/linux/sysctl.h include/linux/assoc_array.h \
+ include/linux/sched/user.h include/linux/ratelimit.h \
+ include/linux/rcu_sync.h include/linux/delayed_call.h \
+ include/linux/uuid.h include/uapi/linux/uuid.h include/linux/errseq.h \
+ include/linux/ioprio.h include/linux/sched/rt.h \
+ include/linux/iocontext.h include/linux/fs_types.h \
+ include/uapi/linux/fs.h include/uapi/linux/ioctl.h \
+ arch/arm/include/generated/uapi/asm/ioctl.h include/asm-generic/ioctl.h \
+ include/uapi/asm-generic/ioctl.h include/linux/quota.h \
+ include/linux/percpu_counter.h include/uapi/linux/dqblk_xfs.h \
+ include/linux/dqblk_v1.h include/linux/dqblk_v2.h \
+ include/linux/dqblk_qtree.h include/linux/projid.h \
+ include/uapi/linux/quota.h include/linux/nfs_fs_i.h include/linux/gpio.h \
+ arch/arm/include/asm/gpio.h include/asm-generic/gpio.h \
+ include/linux/gpio/driver.h include/linux/device.h \
+ include/linux/dev_printk.h include/linux/energy_model.h \
+ include/linux/jump_label.h arch/arm/include/asm/jump_label.h \
+ include/linux/kobject.h include/linux/sysfs.h include/linux/kernfs.h \
+ include/linux/idr.h include/linux/kobject_ns.h include/linux/kref.h \
+ include/linux/sched/cpufreq.h include/linux/sched/topology.h \
+ include/linux/sched/idle.h include/linux/sched/sd_flags.h \
+ include/linux/ioport.h include/linux/klist.h include/linux/pm.h \
+ include/linux/overflow.h include/linux/device/bus.h \
+ include/linux/device/class.h include/linux/device/driver.h \
+ arch/arm/include/asm/device.h include/linux/pm_wakeup.h \
+ include/linux/irq.h include/linux/irqhandler.h include/linux/irqreturn.h \
+ include/linux/irqnr.h include/uapi/linux/irqnr.h include/linux/io.h \
+ arch/arm/include/asm/io.h include/asm-generic/pci_iomap.h \
+ include/asm-generic/io.h include/linux/logic_pio.h \
+ include/linux/fwnode.h include/linux/vmalloc.h \
+ arch/arm/include/asm/vmalloc.h include/linux/slab.h \
+ include/linux/percpu-refcount.h include/linux/kasan.h \
+ arch/arm/include/asm/irq.h arch/arm/include/generated/asm/irq_regs.h \
+ include/asm-generic/irq_regs.h include/linux/irqdesc.h \
+ arch/arm/include/asm/hw_irq.h include/linux/irqchip/chained_irq.h \
+ include/linux/irqdomain.h include/linux/of.h \
+ include/linux/mod_devicetable.h include/linux/property.h \
+ include/linux/pinctrl/pinctrl.h include/linux/seq_file.h \
+ include/linux/pinctrl/pinctrl-state.h include/linux/pinctrl/devinfo.h \
+ include/linux/pinctrl/consumer.h include/linux/pinctrl/pinconf-generic.h \
+ include/linux/pinctrl/machine.h include/linux/gpio/consumer.h \
+ include/linux/i2c.h include/linux/acpi.h include/linux/resource_ext.h \
+ include/acpi/acpi.h include/acpi/platform/acenv.h \
+ include/acpi/platform/acgcc.h include/acpi/platform/aclinux.h \
+ include/linux/ctype.h include/acpi/acnames.h include/acpi/actypes.h \
+ include/acpi/acexcep.h include/acpi/actbl.h include/acpi/actbl1.h \
+ include/acpi/actbl2.h include/acpi/actbl3.h include/acpi/acrestyp.h \
+ include/acpi/platform/acenvex.h include/acpi/platform/aclinuxex.h \
+ include/acpi/platform/acgccex.h include/acpi/acoutput.h \
+ include/acpi/acpiosxf.h include/acpi/acpixf.h include/acpi/acconfig.h \
+ include/acpi/acbuffer.h include/acpi/acpi_numa.h include/linux/rtmutex.h \
+ include/uapi/linux/i2c.h include/linux/interrupt.h \
+ include/linux/hardirq.h include/linux/context_tracking_state.h \
+ include/linux/static_key.h include/linux/ftrace_irq.h \
+ include/linux/vtime.h arch/arm/include/asm/hardirq.h \
+ include/linux/irq_cpustat.h arch/arm/include/asm/sections.h \
+ include/asm-generic/sections.h \
+ drivers/input/touchscreen/hxchipset/himax_common.h include/linux/input.h \
+ include/uapi/linux/input.h include/uapi/linux/input-event-codes.h \
+ include/linux/module.h include/linux/kmod.h include/linux/umh.h \
+ include/linux/elf.h arch/arm/include/asm/elf.h \
+ arch/arm/include/asm/vdso_datapage.h include/vdso/datapage.h \
+ include/uapi/asm-generic/errno-base.h include/vdso/clocksource.h \
+ arch/arm/include/asm/vdso/clocksource.h include/vdso/processor.h \
+ arch/arm/include/asm/vdso/gettimeofday.h \
+ arch/arm/include/asm/vdso/cp15.h arch/arm/include/asm/user.h \
+ include/uapi/linux/elf.h include/uapi/linux/elf-em.h \
+ include/linux/moduleparam.h include/linux/rbtree_latch.h \
+ include/linux/error-injection.h include/asm-generic/error-injection.h \
+ include/linux/tracepoint-defs.h include/linux/static_call_types.h \
+ arch/arm/include/asm/module.h include/asm-generic/module.h \
+ include/linux/async.h include/linux/platform_device.h \
+ include/linux/input/mt.h include/linux/firmware.h \
+ include/linux/buffer_head.h include/linux/pagemap.h include/linux/mm.h \
+ include/linux/mmap_lock.h include/linux/range.h include/linux/page_ext.h \
+ include/linux/stacktrace.h include/linux/stackdepot.h \
+ include/linux/page_ref.h include/linux/memremap.h \
+ include/linux/pgtable.h arch/arm/include/asm/pgtable.h \
+ arch/arm/include/asm/proc-fns.h arch/arm/include/asm/glue-proc.h \
+ include/asm-generic/pgtable-nopud.h include/asm-generic/pgtable-nop4d.h \
+ arch/arm/include/asm/pgtable-hwdef.h \
+ arch/arm/include/asm/pgtable-2level-hwdef.h \
+ arch/arm/include/asm/tlbflush.h arch/arm/include/asm/pgtable-2level.h \
+ include/asm-generic/pgtable_uffd.h include/linux/huge_mm.h \
+ include/linux/sched/coredump.h include/linux/vmstat.h \
+ include/linux/vm_event_item.h include/linux/highmem.h \
+ arch/arm/include/asm/cacheflush.h arch/arm/include/asm/glue-cache.h \
+ arch/arm/include/asm/cachetype.h arch/arm/include/asm/outercache.h \
+ arch/arm/include/asm/kmap_types.h include/linux/hugetlb_inline.h \
+ include/linux/proc_fs.h include/linux/kallsyms.h include/linux/of_gpio.h \
+ include/generated/uapi/linux/version.h include/linux/rtc.h \
+ include/linux/nvmem-provider.h include/uapi/linux/rtc.h \
+ include/linux/cdev.h include/linux/poll.h include/uapi/linux/poll.h \
+ arch/arm/include/generated/uapi/asm/poll.h \
+ include/uapi/asm-generic/poll.h include/uapi/linux/eventpoll.h \
+ include/linux/fb.h include/linux/kgdb.h include/linux/kprobes.h \
+ include/linux/ftrace.h include/linux/trace_clock.h \
+ arch/arm/include/generated/asm/trace_clock.h \
+ include/asm-generic/trace_clock.h include/linux/ptrace.h \
+ include/linux/pid_namespace.h include/linux/nsproxy.h \
+ include/linux/ns_common.h include/uapi/linux/ptrace.h \
+ arch/arm/include/asm/ftrace.h arch/arm/include/asm/kprobes.h \
+ include/asm-generic/kprobes.h arch/arm/include/asm/probes.h \
+ arch/arm/include/asm/kgdb.h include/uapi/linux/fb.h \
+ include/linux/backlight.h \
+ drivers/input/touchscreen/hxchipset/himax_ic_core.h
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_ic_HX83193.o.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_ic_HX83193.o.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_ic_HX83193.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_ic_HX83193.o.cmd	2024-06-14 10:43:31.772186056 +0200
@@ -0,0 +1,1210 @@
+cmd_drivers/input/touchscreen/hxchipset/himax_ic_HX83193.o := /mnt/buildramdisk/br-output/host/bin/arm-buildroot-linux-uclibcgnueabihf-gcc -Wp,-MMD,drivers/input/touchscreen/hxchipset/.himax_ic_HX83193.o.d -nostdinc -isystem /mnt/buildramdisk/br-output/host/lib/gcc/arm-buildroot-linux-uclibcgnueabihf/10.3.0/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -include ./include/linux/compiler_types.h -D__KERNEL__ -mlittle-endian -fmacro-prefix-map=./= -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=implicit-function-declaration -Werror=implicit-int -Werror=return-type -Wno-format-security -std=gnu89 -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mfpu=vfp -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-address-of-packed-member -O2 -fno-allow-store-data-races -Wframe-larger-than=1024 -fstack-protector-strong -Wimplicit-fallthrough -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -pg -Wdeclaration-after-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -Wno-zero-length-bounds -Wno-array-bounds -Wno-stringop-overflow -Wno-restrict -Wno-maybe-uninitialized -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init -Wno-packed-not-aligned -Wno-attribute-alias -DHX_CONFIG_FB -D__HIMAX_MOD__ -D__HIMAX_HX83193_MOD__ -D__HIMAX_MOD__  -DMODULE  -DKBUILD_BASENAME='"himax_ic_HX83193"' -DKBUILD_MODNAME='"himax_mmi"' -c -o drivers/input/touchscreen/hxchipset/himax_ic_HX83193.o drivers/input/touchscreen/hxchipset/himax_ic_HX83193.c
+
+source_drivers/input/touchscreen/hxchipset/himax_ic_HX83193.o := drivers/input/touchscreen/hxchipset/himax_ic_HX83193.c
+
+deps_drivers/input/touchscreen/hxchipset/himax_ic_HX83193.o := \
+  include/linux/kconfig.h \
+    $(wildcard include/config/cc/version/text.h) \
+    $(wildcard include/config/cpu/big/endian.h) \
+    $(wildcard include/config/booger.h) \
+    $(wildcard include/config/foo.h) \
+  include/linux/compiler_types.h \
+    $(wildcard include/config/have/arch/compiler/h.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/cc/has/asm/inline.h) \
+  include/linux/compiler_attributes.h \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arm64.h) \
+    $(wildcard include/config/retpoline.h) \
+    $(wildcard include/config/arch/use/builtin/bswap.h) \
+    $(wildcard include/config/kcov.h) \
+  drivers/input/touchscreen/hxchipset/himax_platform.h \
+    $(wildcard include/config/touchscreen/himax/debug.h) \
+  include/linux/delay.h \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/preempt/rt.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/panic/timeout.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  include/linux/limits.h \
+  include/uapi/linux/limits.h \
+  include/linux/types.h \
+    $(wildcard include/config/have/uid16.h) \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  include/uapi/linux/types.h \
+  arch/arm/include/uapi/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  include/uapi/asm-generic/int-ll64.h \
+  arch/arm/include/generated/uapi/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/uapi/asm-generic/bitsperlong.h \
+  include/uapi/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/uapi/linux/stddef.h \
+  include/linux/compiler_types.h \
+  arch/arm/include/uapi/asm/posix_types.h \
+  include/uapi/asm-generic/posix_types.h \
+  include/vdso/limits.h \
+  include/linux/linkage.h \
+    $(wildcard include/config/arch/use/sym/annotations.h) \
+  include/linux/stringify.h \
+  include/linux/export.h \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/module/rel/crcs.h) \
+    $(wildcard include/config/have/arch/prel32/relocations.h) \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/trim/unused/ksyms.h) \
+    $(wildcard include/config/unused/symbols.h) \
+  arch/arm/include/asm/linkage.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/stack/validation.h) \
+  arch/arm/include/generated/asm/rwonce.h \
+  include/asm-generic/rwonce.h \
+  include/linux/kasan-checks.h \
+    $(wildcard include/config/kasan.h) \
+  include/linux/kcsan-checks.h \
+    $(wildcard include/config/kcsan.h) \
+    $(wildcard include/config/kcsan/ignore/atomics.h) \
+  include/linux/bitops.h \
+  include/linux/bits.h \
+  include/linux/const.h \
+  include/vdso/const.h \
+  include/uapi/linux/const.h \
+  include/vdso/bits.h \
+  include/linux/build_bug.h \
+  arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  arch/arm/include/asm/irqflags.h \
+    $(wildcard include/config/cpu/v7m.h) \
+  arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/arm/thumb.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+  arch/arm/include/uapi/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+  arch/arm/include/asm/hwcap.h \
+  arch/arm/include/uapi/asm/hwcap.h \
+  include/asm-generic/irqflags.h \
+  arch/arm/include/asm/percpu.h \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/percpu.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+    $(wildcard include/config/amd/mem/encrypt.h) \
+  arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arm/heavy/mb.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+    $(wildcard include/config/cpu/spectre.h) \
+  include/asm-generic/barrier.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/builtin-__fls.h \
+  include/asm-generic/bitops/builtin-__ffs.h \
+  include/asm-generic/bitops/builtin-fls.h \
+  include/asm-generic/bitops/builtin-ffs.h \
+  include/asm-generic/bitops/ffz.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/atomic.h \
+  arch/arm/include/asm/atomic.h \
+    $(wildcard include/config/generic/atomic64.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/linux/prefetch.h \
+  arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/binfmt/elf/fdpic.h) \
+  arch/arm/include/asm/hw_breakpoint.h \
+  arch/arm/include/asm/unified.h \
+  arch/arm/include/asm/vdso/processor.h \
+    $(wildcard include/config/arm/errata/754327.h) \
+  arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/atomic-fallback.h \
+  include/asm-generic/atomic-long.h \
+  include/asm-generic/bitops/find.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+  include/asm-generic/bitops/le.h \
+  arch/arm/include/uapi/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/uapi/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  include/uapi/linux/swab.h \
+  arch/arm/include/asm/swab.h \
+  arch/arm/include/uapi/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/minmax.h \
+  include/linux/printk.h \
+    $(wildcard include/config/message/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/quiet.h) \
+    $(wildcard include/config/early/printk.h) \
+    $(wildcard include/config/printk/nmi.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/dynamic/debug/core.h) \
+  include/linux/init.h \
+    $(wildcard include/config/strict/kernel/rwx.h) \
+    $(wildcard include/config/strict/module/rwx.h) \
+  include/linux/kern_levels.h \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/uapi/linux/kernel.h \
+  include/uapi/linux/sysinfo.h \
+  include/linux/ratelimit_types.h \
+  include/uapi/linux/param.h \
+  arch/arm/include/generated/uapi/asm/param.h \
+  include/asm-generic/param.h \
+    $(wildcard include/config/hz.h) \
+  include/uapi/asm-generic/param.h \
+  include/linux/spinlock_types.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep_types.h \
+    $(wildcard include/config/prove/raw/lock/nesting.h) \
+    $(wildcard include/config/preempt/lock.h) \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+  include/linux/rwlock_types.h \
+  arch/arm/include/asm/div64.h \
+  arch/arm/include/asm/compiler.h \
+  include/asm-generic/div64.h \
+  arch/arm/include/asm/delay.h \
+  arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/xip/kernel.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+    $(wildcard include/config/xip/phys/addr.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  include/linux/pfn.h \
+  include/linux/fs.h \
+    $(wildcard include/config/read/only/thp/for/fs.h) \
+    $(wildcard include/config/fs/posix/acl.h) \
+    $(wildcard include/config/security.h) \
+    $(wildcard include/config/cgroup/writeback.h) \
+    $(wildcard include/config/ima.h) \
+    $(wildcard include/config/file/locking.h) \
+    $(wildcard include/config/fsnotify.h) \
+    $(wildcard include/config/fs/encryption.h) \
+    $(wildcard include/config/fs/verity.h) \
+    $(wildcard include/config/preemption.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/unicode.h) \
+    $(wildcard include/config/compat.h) \
+    $(wildcard include/config/quota.h) \
+    $(wildcard include/config/fs/dax.h) \
+    $(wildcard include/config/mandatory/file/locking.h) \
+    $(wildcard include/config/block.h) \
+    $(wildcard include/config/migration.h) \
+  include/linux/wait_bit.h \
+  include/linux/wait.h \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+    $(wildcard include/config/page/poisoning/zero.h) \
+  include/linux/spinlock.h \
+  include/linux/preempt.h \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/trace/preempt/toggle.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  arch/arm/include/generated/asm/preempt.h \
+  include/asm-generic/preempt.h \
+  include/linux/thread_info.h \
+    $(wildcard include/config/thread/info/in/task.h) \
+    $(wildcard include/config/have/arch/within/stack/frames.h) \
+    $(wildcard include/config/hardened/usercopy.h) \
+  include/linux/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/bug/on/data/corruption.h) \
+  arch/arm/include/asm/bug.h \
+    $(wildcard include/config/debug/bugverbose.h) \
+  arch/arm/include/asm/opcodes.h \
+    $(wildcard include/config/cpu/endian/be32.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  include/linux/instrumentation.h \
+    $(wildcard include/config/debug/entry.h) \
+  include/linux/restart_block.h \
+  include/linux/time64.h \
+  include/linux/math64.h \
+    $(wildcard include/config/arch/supports/int128.h) \
+  include/vdso/math64.h \
+  include/vdso/time64.h \
+  include/uapi/linux/time.h \
+  include/uapi/linux/time_types.h \
+  include/linux/errno.h \
+  include/uapi/linux/errno.h \
+  arch/arm/include/generated/uapi/asm/errno.h \
+  include/uapi/asm-generic/errno.h \
+  include/uapi/asm-generic/errno-base.h \
+  arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/stackprotector/per/task.h) \
+    $(wildcard include/config/crunch.h) \
+    $(wildcard include/config/arm/thumbee.h) \
+  arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+    $(wildcard include/config/kuser/helpers.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+  arch/arm/include/asm/glue.h \
+  arch/arm/include/asm/pgtable-2level-types.h \
+  include/asm-generic/getorder.h \
+  include/linux/bottom_half.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/debug/locking/api/selftests.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/up/late/init.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+    $(wildcard include/config/fortify/source.h) \
+  include/uapi/linux/string.h \
+  arch/arm/include/asm/string.h \
+    $(wildcard include/config/bcm2835/fast/memcpy.h) \
+  include/linux/smp_types.h \
+  include/linux/llist.h \
+    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
+  arch/arm/include/asm/smp.h \
+  arch/arm/include/generated/asm/mmiowb.h \
+  include/asm-generic/mmiowb.h \
+    $(wildcard include/config/mmiowb.h) \
+  arch/arm/include/asm/spinlock.h \
+  include/linux/rwlock.h \
+    $(wildcard include/config/preempt.h) \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  arch/arm/include/generated/asm/current.h \
+  include/asm-generic/current.h \
+  include/uapi/linux/wait.h \
+  include/linux/kdev_t.h \
+  include/uapi/linux/kdev_t.h \
+  include/linux/dcache.h \
+  include/linux/rculist.h \
+    $(wildcard include/config/prove/rcu/list.h) \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tasks/rcu/generic.h) \
+    $(wildcard include/config/rcu/stall/common.h) \
+    $(wildcard include/config/no/hz/full.h) \
+    $(wildcard include/config/rcu/nocb/cpu.h) \
+    $(wildcard include/config/tasks/rcu.h) \
+    $(wildcard include/config/tasks/trace/rcu.h) \
+    $(wildcard include/config/tasks/rude/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/prove/rcu.h) \
+    $(wildcard include/config/rcu/boost.h) \
+    $(wildcard include/config/arch/weak/release/acquire.h) \
+  include/linux/rcutree.h \
+  include/linux/rculist_bl.h \
+  include/linux/list_bl.h \
+  include/linux/bit_spinlock.h \
+  include/linux/seqlock.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/mutex/spin/on/owner.h) \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/osq_lock.h \
+  include/linux/debug_locks.h \
+  include/linux/ww_mutex.h \
+    $(wildcard include/config/debug/ww/mutex/slowpath.h) \
+  include/linux/lockref.h \
+    $(wildcard include/config/arch/use/cmpxchg/lockref.h) \
+  include/generated/bounds.h \
+  include/linux/stringhash.h \
+    $(wildcard include/config/dcache/word/access.h) \
+  include/linux/hash.h \
+    $(wildcard include/config/have/arch/hash.h) \
+  include/linux/path.h \
+  include/linux/stat.h \
+  arch/arm/include/uapi/asm/stat.h \
+  include/uapi/linux/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+    $(wildcard include/config/posix/timers.h) \
+  include/linux/time32.h \
+  include/linux/timex.h \
+  include/uapi/linux/timex.h \
+  arch/arm/include/asm/timex.h \
+  include/vdso/time32.h \
+  include/vdso/time.h \
+  include/linux/uidgid.h \
+    $(wildcard include/config/multiuser.h) \
+    $(wildcard include/config/user/ns.h) \
+  include/linux/highuid.h \
+  include/linux/list_lru.h \
+    $(wildcard include/config/memcg/kmem.h) \
+  include/linux/nodemask.h \
+    $(wildcard include/config/numa.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+    $(wildcard include/config/numa/keep/meminfo.h) \
+  include/linux/shrinker.h \
+    $(wildcard include/config/memcg.h) \
+  include/linux/radix-tree.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/vm/pgflags.h) \
+  include/linux/xarray.h \
+    $(wildcard include/config/xarray/multi.h) \
+  include/linux/gfp.h \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/zone/device.h) \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/contig/alloc.h) \
+    $(wildcard include/config/cma.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/isolation.h) \
+    $(wildcard include/config/zsmalloc.h) \
+    $(wildcard include/config/shadow/call/stack.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/transparent/hugepage.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/page/extension.h) \
+    $(wildcard include/config/deferred/struct/page/init.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/page-flags-layout.h \
+    $(wildcard include/config/numa/balancing.h) \
+    $(wildcard include/config/kasan/sw/tags.h) \
+  include/linux/mm_types.h \
+    $(wildcard include/config/have/aligned/struct/page.h) \
+    $(wildcard include/config/userfaultfd.h) \
+    $(wildcard include/config/swap.h) \
+    $(wildcard include/config/have/arch/compat/mmap/bases.h) \
+    $(wildcard include/config/membarrier.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+    $(wildcard include/config/arch/want/batched/unmap/tlb/flush.h) \
+    $(wildcard include/config/iommu/support.h) \
+  include/linux/mm_types_task.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/arch/enable/split/pmd/ptlock.h) \
+  include/linux/auxvec.h \
+  include/uapi/linux/auxvec.h \
+  arch/arm/include/asm/auxvec.h \
+  arch/arm/include/uapi/asm/auxvec.h \
+  include/linux/rbtree.h \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/spin/on/owner.h) \
+    $(wildcard include/config/debug/rwsems.h) \
+  include/linux/err.h \
+  include/linux/completion.h \
+  include/linux/swait.h \
+  include/linux/uprobes.h \
+    $(wildcard include/config/uprobes.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+    $(wildcard include/config/sysfs.h) \
+    $(wildcard include/config/wq/watchdog.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/debug/objects/timers.h) \
+    $(wildcard include/config/no/hz/common.h) \
+  include/linux/ktime.h \
+  include/linux/jiffies.h \
+  include/vdso/jiffies.h \
+  include/generated/timeconst.h \
+  include/vdso/ktime.h \
+  include/linux/timekeeping.h \
+  include/linux/timekeeping32.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+    $(wildcard include/config/vdso.h) \
+  include/linux/page-flags.h \
+    $(wildcard include/config/arch/uses/pg/uncached.h) \
+    $(wildcard include/config/memory/failure.h) \
+    $(wildcard include/config/idle/page/tracking.h) \
+    $(wildcard include/config/thp/swap.h) \
+    $(wildcard include/config/ksm.h) \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/arch/has/add/pages.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/have/bootmem/info/node.h) \
+  include/linux/notifier.h \
+    $(wildcard include/config/tree/srcu.h) \
+  include/linux/srcu.h \
+    $(wildcard include/config/tiny/srcu.h) \
+    $(wildcard include/config/srcu.h) \
+  include/linux/rcu_segcblist.h \
+  include/linux/srcutree.h \
+  include/linux/rcu_node_tree.h \
+    $(wildcard include/config/rcu/fanout.h) \
+    $(wildcard include/config/rcu/fanout/leaf.h) \
+  include/linux/topology.h \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+    $(wildcard include/config/sched/smt.h) \
+  include/linux/arch_topology.h \
+    $(wildcard include/config/generic/arch/topology.h) \
+  arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+    $(wildcard include/config/bl/switcher.h) \
+  include/asm-generic/topology.h \
+  include/linux/kconfig.h \
+  include/linux/local_lock.h \
+  include/linux/local_lock_internal.h \
+  include/linux/pid.h \
+  include/linux/refcount.h \
+  include/linux/capability.h \
+  include/uapi/linux/capability.h \
+  include/linux/semaphore.h \
+  include/linux/fcntl.h \
+    $(wildcard include/config/arch/32bit/off/t.h) \
+  include/uapi/linux/fcntl.h \
+  arch/arm/include/uapi/asm/fcntl.h \
+  include/uapi/asm-generic/fcntl.h \
+  include/uapi/linux/openat2.h \
+  include/linux/migrate_mode.h \
+  include/linux/percpu-rwsem.h \
+  include/linux/rcuwait.h \
+  include/linux/sched/signal.h \
+    $(wildcard include/config/sched/autogroup.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/stack/growsup.h) \
+  include/linux/signal.h \
+    $(wildcard include/config/proc/fs.h) \
+  include/linux/signal_types.h \
+    $(wildcard include/config/old/sigaction.h) \
+  include/uapi/linux/signal.h \
+  arch/arm/include/asm/signal.h \
+  arch/arm/include/uapi/asm/signal.h \
+  include/uapi/asm-generic/signal-defs.h \
+  arch/arm/include/uapi/asm/sigcontext.h \
+  arch/arm/include/generated/uapi/asm/siginfo.h \
+  include/uapi/asm-generic/siginfo.h \
+  include/linux/sched.h \
+    $(wildcard include/config/virt/cpu/accounting/native.h) \
+    $(wildcard include/config/sched/info.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/uclamp/task.h) \
+    $(wildcard include/config/uclamp/buckets/count.h) \
+    $(wildcard include/config/cgroup/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/psi.h) \
+    $(wildcard include/config/compat/brk.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/blk/cgroup.h) \
+    $(wildcard include/config/stackprotector.h) \
+    $(wildcard include/config/arch/has/scaled/cputime.h) \
+    $(wildcard include/config/virt/cpu/accounting/gen.h) \
+    $(wildcard include/config/posix/cputimers.h) \
+    $(wildcard include/config/posix/cpu/timers/task/work.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/io/uring.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/ubsan.h) \
+    $(wildcard include/config/ubsan/trap.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/x86/cpu/resctrl.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/rseq.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/kunit.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/bcache.h) \
+    $(wildcard include/config/vmap/stack.h) \
+    $(wildcard include/config/livepatch.h) \
+    $(wildcard include/config/gcc/plugin/stackleak.h) \
+    $(wildcard include/config/x86/mce.h) \
+    $(wildcard include/config/arch/task/struct/on/stack.h) \
+    $(wildcard include/config/debug/rseq.h) \
+  include/uapi/linux/sched.h \
+  include/linux/sem.h \
+  include/uapi/linux/sem.h \
+  include/linux/ipc.h \
+  include/linux/rhashtable-types.h \
+  include/uapi/linux/ipc.h \
+  arch/arm/include/generated/uapi/asm/ipcbuf.h \
+  include/uapi/asm-generic/ipcbuf.h \
+  arch/arm/include/generated/uapi/asm/sembuf.h \
+  include/uapi/asm-generic/sembuf.h \
+  include/linux/shm.h \
+  include/uapi/linux/shm.h \
+  include/uapi/asm-generic/hugetlb_encode.h \
+  arch/arm/include/generated/uapi/asm/shmbuf.h \
+  include/uapi/asm-generic/shmbuf.h \
+  arch/arm/include/asm/shmparam.h \
+  include/linux/kcov.h \
+  include/uapi/linux/kcov.h \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/plist.h) \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+    $(wildcard include/config/time/low/res.h) \
+    $(wildcard include/config/timerfd.h) \
+  include/linux/hrtimer_defs.h \
+  include/linux/timerqueue.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+    $(wildcard include/config/have/arch/seccomp/filter.h) \
+    $(wildcard include/config/seccomp/filter.h) \
+    $(wildcard include/config/checkpoint/restore.h) \
+  include/uapi/linux/seccomp.h \
+  arch/arm/include/generated/asm/seccomp.h \
+  include/asm-generic/seccomp.h \
+  include/uapi/linux/unistd.h \
+  arch/arm/include/asm/unistd.h \
+    $(wildcard include/config/oabi/compat.h) \
+  arch/arm/include/uapi/asm/unistd.h \
+  arch/arm/include/generated/uapi/asm/unistd-eabi.h \
+  arch/arm/include/generated/uapi/asm/unistd-common.h \
+  arch/arm/include/generated/asm/unistd-nr.h \
+  include/linux/resource.h \
+  include/uapi/linux/resource.h \
+  arch/arm/include/generated/uapi/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/uapi/asm-generic/resource.h \
+  include/linux/latencytop.h \
+  include/linux/sched/prio.h \
+  include/linux/sched/types.h \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/posix-timers.h \
+  include/linux/alarmtimer.h \
+    $(wildcard include/config/rtc/class.h) \
+  include/linux/task_work.h \
+  include/uapi/linux/rseq.h \
+  include/linux/kcsan.h \
+  include/linux/sched/jobctl.h \
+  include/linux/sched/task.h \
+    $(wildcard include/config/have/exit/thread.h) \
+    $(wildcard include/config/arch/wants/dynamic/task/struct.h) \
+    $(wildcard include/config/have/arch/thread/struct/whitelist.h) \
+  include/linux/uaccess.h \
+    $(wildcard include/config/set/fs.h) \
+  include/linux/fault-inject-usercopy.h \
+    $(wildcard include/config/fault/injection/usercopy.h) \
+  include/linux/instrumented.h \
+  arch/arm/include/asm/uaccess.h \
+    $(wildcard include/config/cpu/sw/domain/pan.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+    $(wildcard include/config/uaccess/with/memcpy.h) \
+  arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/cp15/mmu.h) \
+  arch/arm/include/generated/asm/extable.h \
+  include/asm-generic/extable.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+  include/linux/key.h \
+    $(wildcard include/config/key/notifications.h) \
+    $(wildcard include/config/net.h) \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/uapi/linux/sysctl.h \
+  include/linux/assoc_array.h \
+    $(wildcard include/config/associative/array.h) \
+  include/linux/sched/user.h \
+    $(wildcard include/config/fanotify.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/bpf/syscall.h) \
+    $(wildcard include/config/watch/queue.h) \
+  include/linux/ratelimit.h \
+  include/linux/rcu_sync.h \
+  include/linux/delayed_call.h \
+  include/linux/uuid.h \
+  include/uapi/linux/uuid.h \
+  include/linux/errseq.h \
+  include/linux/ioprio.h \
+  include/linux/sched/rt.h \
+  include/linux/iocontext.h \
+  include/linux/fs_types.h \
+  include/uapi/linux/fs.h \
+  include/uapi/linux/ioctl.h \
+  arch/arm/include/generated/uapi/asm/ioctl.h \
+  include/asm-generic/ioctl.h \
+  include/uapi/asm-generic/ioctl.h \
+  include/linux/quota.h \
+    $(wildcard include/config/quota/netlink/interface.h) \
+  include/linux/percpu_counter.h \
+  include/uapi/linux/dqblk_xfs.h \
+  include/linux/dqblk_v1.h \
+  include/linux/dqblk_v2.h \
+  include/linux/dqblk_qtree.h \
+  include/linux/projid.h \
+  include/uapi/linux/quota.h \
+  include/linux/nfs_fs_i.h \
+  include/linux/gpio.h \
+    $(wildcard include/config/gpiolib.h) \
+    $(wildcard include/config/arch/have/custom/gpio/h.h) \
+  arch/arm/include/asm/gpio.h \
+    $(wildcard include/config/arch/nr/gpio.h) \
+  include/asm-generic/gpio.h \
+  include/linux/gpio/driver.h \
+    $(wildcard include/config/irq/domain/hierarchy.h) \
+    $(wildcard include/config/gpio/generic.h) \
+    $(wildcard include/config/gpiolib/irqchip.h) \
+    $(wildcard include/config/of/gpio.h) \
+    $(wildcard include/config/of.h) \
+    $(wildcard include/config/pinctrl.h) \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/energy/model.h) \
+    $(wildcard include/config/generic/msi/irq/domain.h) \
+    $(wildcard include/config/generic/msi/irq.h) \
+    $(wildcard include/config/dma/ops.h) \
+    $(wildcard include/config/dma/declare/coherent.h) \
+    $(wildcard include/config/dma/cma.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/device.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu/all.h) \
+    $(wildcard include/config/dma/ops/bypass.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/dev_printk.h \
+  include/linux/energy_model.h \
+  include/linux/jump_label.h \
+    $(wildcard include/config/jump/label.h) \
+    $(wildcard include/config/have/arch/jump/label/relative.h) \
+  arch/arm/include/asm/jump_label.h \
+  include/linux/kobject.h \
+    $(wildcard include/config/uevent/helper.h) \
+    $(wildcard include/config/debug/kobject/release.h) \
+  include/linux/sysfs.h \
+  include/linux/kernfs.h \
+    $(wildcard include/config/kernfs.h) \
+  include/linux/idr.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/sched/cpufreq.h \
+    $(wildcard include/config/cpu/freq.h) \
+  include/linux/sched/topology.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/sched/idle.h \
+  include/linux/sched/sd_flags.h \
+  include/linux/ioport.h \
+    $(wildcard include/config/io/strict/devmem.h) \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/vt/console/sleep.h) \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  include/linux/overflow.h \
+  include/linux/device/bus.h \
+    $(wildcard include/config/acpi.h) \
+  include/linux/device/class.h \
+  include/linux/device/driver.h \
+  arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/arm/dma/use/iommu.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/irq.h \
+    $(wildcard include/config/generic/irq/effective/aff/mask.h) \
+    $(wildcard include/config/generic/irq/ipi.h) \
+    $(wildcard include/config/generic/irq/migration.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+    $(wildcard include/config/hardirqs/sw/resend.h) \
+    $(wildcard include/config/generic/irq/legacy/alloc/hwirq.h) \
+    $(wildcard include/config/generic/irq/legacy.h) \
+    $(wildcard include/config/generic/irq/multi/handler.h) \
+  include/linux/irqhandler.h \
+  include/linux/irqreturn.h \
+  include/linux/irqnr.h \
+  include/uapi/linux/irqnr.h \
+  include/linux/io.h \
+    $(wildcard include/config/have/arch/huge/vmap.h) \
+    $(wildcard include/config/has/ioport/map.h) \
+    $(wildcard include/config/pci.h) \
+  arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/asm-generic/io.h \
+    $(wildcard include/config/generic/iomap.h) \
+    $(wildcard include/config/generic/ioremap.h) \
+    $(wildcard include/config/virt/to/bus.h) \
+  include/linux/logic_pio.h \
+    $(wildcard include/config/indirect/pio.h) \
+  include/linux/fwnode.h \
+  include/linux/vmalloc.h \
+    $(wildcard include/config/kasan/vmalloc.h) \
+  arch/arm/include/asm/vmalloc.h \
+  include/linux/slab.h \
+    $(wildcard include/config/debug/slab.h) \
+    $(wildcard include/config/failslab.h) \
+    $(wildcard include/config/have/hardened/usercopy/allocator.h) \
+    $(wildcard include/config/slab.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+  include/linux/percpu-refcount.h \
+  include/linux/kasan.h \
+    $(wildcard include/config/kasan/generic.h) \
+    $(wildcard include/config/kasan/inline.h) \
+  arch/arm/include/asm/irq.h \
+    $(wildcard include/config/sparse/irq.h) \
+  arch/arm/include/generated/asm/irq_regs.h \
+  include/asm-generic/irq_regs.h \
+  include/linux/irqdesc.h \
+    $(wildcard include/config/generic/irq/debugfs.h) \
+    $(wildcard include/config/handle/domain/irq.h) \
+    $(wildcard include/config/irq/domain.h) \
+  arch/arm/include/asm/hw_irq.h \
+  include/linux/irqchip/chained_irq.h \
+  include/linux/irqdomain.h \
+  include/linux/of.h \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/promtree.h) \
+    $(wildcard include/config/of/kobj.h) \
+    $(wildcard include/config/of/numa.h) \
+    $(wildcard include/config/of/overlay.h) \
+  include/linux/mod_devicetable.h \
+  include/linux/property.h \
+  include/linux/pinctrl/pinctrl.h \
+    $(wildcard include/config/generic/pinconf.h) \
+  include/linux/seq_file.h \
+  include/linux/pinctrl/pinctrl-state.h \
+  include/linux/pinctrl/devinfo.h \
+  include/linux/pinctrl/consumer.h \
+  include/linux/pinctrl/pinconf-generic.h \
+  include/linux/pinctrl/machine.h \
+  include/linux/gpio/consumer.h \
+    $(wildcard include/config/gpio/sysfs.h) \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/slave.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+    $(wildcard include/config/i2c/mux.h) \
+  include/linux/acpi.h \
+    $(wildcard include/config/acpi/debugger.h) \
+    $(wildcard include/config/x86.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/acpi/processor/cstate.h) \
+    $(wildcard include/config/acpi/hotplug/cpu.h) \
+    $(wildcard include/config/acpi/hotplug/ioapic.h) \
+    $(wildcard include/config/x86/io/apic.h) \
+    $(wildcard include/config/acpi/wmi.h) \
+    $(wildcard include/config/acpi/numa.h) \
+    $(wildcard include/config/hibernation.h) \
+    $(wildcard include/config/acpi/hotplug/memory.h) \
+    $(wildcard include/config/acpi/container.h) \
+    $(wildcard include/config/acpi/gtdt.h) \
+    $(wildcard include/config/acpi/table/upgrade.h) \
+    $(wildcard include/config/acpi/watchdog.h) \
+    $(wildcard include/config/acpi/spcr/table.h) \
+    $(wildcard include/config/acpi/generic/gsi.h) \
+    $(wildcard include/config/acpi/lpit.h) \
+    $(wildcard include/config/acpi/pptt.h) \
+  include/linux/resource_ext.h \
+  include/acpi/acpi.h \
+  include/acpi/platform/acenv.h \
+  include/acpi/platform/acgcc.h \
+  include/acpi/platform/aclinux.h \
+    $(wildcard include/config/acpi/reduced/hardware/only.h) \
+    $(wildcard include/config/acpi/debug.h) \
+  include/linux/ctype.h \
+  include/acpi/acnames.h \
+  include/acpi/actypes.h \
+  include/acpi/acexcep.h \
+  include/acpi/actbl.h \
+  include/acpi/actbl1.h \
+  include/acpi/actbl2.h \
+  include/acpi/actbl3.h \
+  include/acpi/acrestyp.h \
+  include/acpi/platform/acenvex.h \
+  include/acpi/platform/aclinuxex.h \
+  include/acpi/platform/acgccex.h \
+  include/acpi/acoutput.h \
+  include/acpi/acpiosxf.h \
+  include/acpi/acpixf.h \
+  include/acpi/acconfig.h \
+  include/acpi/acbuffer.h \
+  include/acpi/acpi_numa.h \
+    $(wildcard include/config/acpi/hmat.h) \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/uapi/linux/i2c.h \
+  include/linux/interrupt.h \
+    $(wildcard include/config/irq/forced/threading.h) \
+    $(wildcard include/config/generic/irq/probe.h) \
+    $(wildcard include/config/irq/timings.h) \
+  include/linux/hardirq.h \
+  include/linux/context_tracking_state.h \
+    $(wildcard include/config/context/tracking.h) \
+  include/linux/static_key.h \
+  include/linux/ftrace_irq.h \
+    $(wildcard include/config/hwlat/tracer.h) \
+  include/linux/vtime.h \
+    $(wildcard include/config/virt/cpu/accounting.h) \
+    $(wildcard include/config/irq/time/accounting.h) \
+  arch/arm/include/asm/hardirq.h \
+  include/linux/irq_cpustat.h \
+  arch/arm/include/asm/sections.h \
+  include/asm-generic/sections.h \
+  drivers/input/touchscreen/hxchipset/himax_common.h \
+    $(wildcard include/config/touchscreen/himax/ic/hx83192.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83193.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83194.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83195.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83180.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83181.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx8530.h) \
+    $(wildcard include/config/touchscreen/himax/self/test.h) \
+  include/linux/input.h \
+  include/uapi/linux/input.h \
+  include/uapi/linux/input-event-codes.h \
+  include/linux/module.h \
+    $(wildcard include/config/modules/tree/lookup.h) \
+    $(wildcard include/config/module/sig.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/bpf/events.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/kprobes.h) \
+    $(wildcard include/config/have/static/call/inline.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/function/error/injection.h) \
+  include/linux/kmod.h \
+  include/linux/umh.h \
+  include/linux/elf.h \
+    $(wildcard include/config/arch/use/gnu/property.h) \
+    $(wildcard include/config/arch/have/elf/prot.h) \
+  arch/arm/include/asm/elf.h \
+  arch/arm/include/asm/vdso_datapage.h \
+  include/vdso/datapage.h \
+    $(wildcard include/config/arch/has/vdso/data.h) \
+  include/uapi/asm-generic/errno-base.h \
+  include/vdso/clocksource.h \
+    $(wildcard include/config/generic/gettimeofday.h) \
+  arch/arm/include/asm/vdso/clocksource.h \
+  include/vdso/processor.h \
+  arch/arm/include/asm/vdso/gettimeofday.h \
+    $(wildcard include/config/arm/arch/timer.h) \
+  arch/arm/include/asm/vdso/cp15.h \
+    $(wildcard include/config/cpu/cp15.h) \
+  arch/arm/include/asm/user.h \
+  include/uapi/linux/elf.h \
+  include/uapi/linux/elf-em.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/rbtree_latch.h \
+  include/linux/error-injection.h \
+  include/asm-generic/error-injection.h \
+  include/linux/tracepoint-defs.h \
+  include/linux/static_call_types.h \
+    $(wildcard include/config/have/static/call.h) \
+  arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+    $(wildcard include/config/arm/module/plts.h) \
+  include/asm-generic/module.h \
+    $(wildcard include/config/have/mod/arch/specific.h) \
+    $(wildcard include/config/modules/use/elf/rel.h) \
+    $(wildcard include/config/modules/use/elf/rela.h) \
+  include/linux/async.h \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+    $(wildcard include/config/superh.h) \
+  include/linux/input/mt.h \
+  include/linux/firmware.h \
+    $(wildcard include/config/fw/loader.h) \
+  include/linux/buffer_head.h \
+  include/linux/pagemap.h \
+  include/linux/mm.h \
+    $(wildcard include/config/have/arch/mmap/rnd/bits.h) \
+    $(wildcard include/config/have/arch/mmap/rnd/compat/bits.h) \
+    $(wildcard include/config/mem/soft/dirty.h) \
+    $(wildcard include/config/arch/uses/high/vma/flags.h) \
+    $(wildcard include/config/arch/has/pkeys.h) \
+    $(wildcard include/config/ppc.h) \
+    $(wildcard include/config/parisc.h) \
+    $(wildcard include/config/sparc64.h) \
+    $(wildcard include/config/arm64/mte.h) \
+    $(wildcard include/config/shmem.h) \
+    $(wildcard include/config/dev/pagemap/ops.h) \
+    $(wildcard include/config/device/private.h) \
+    $(wildcard include/config/pci/p2pdma.h) \
+    $(wildcard include/config/arch/has/pte/special.h) \
+    $(wildcard include/config/arch/has/pte/devmap.h) \
+    $(wildcard include/config/debug/vm/rb.h) \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/init/on/alloc/default/on.h) \
+    $(wildcard include/config/init/on/free/default/on.h) \
+    $(wildcard include/config/debug/pagealloc.h) \
+    $(wildcard include/config/arch/has/set/direct/map.h) \
+    $(wildcard include/config/hugetlbfs.h) \
+    $(wildcard include/config/mapping/dirty/helpers.h) \
+  include/linux/mmap_lock.h \
+  include/linux/range.h \
+  include/linux/page_ext.h \
+  include/linux/stacktrace.h \
+    $(wildcard include/config/stacktrace.h) \
+    $(wildcard include/config/arch/stackwalk.h) \
+    $(wildcard include/config/have/reliable/stacktrace.h) \
+  include/linux/stackdepot.h \
+  include/linux/page_ref.h \
+    $(wildcard include/config/debug/page/ref.h) \
+  include/linux/memremap.h \
+  include/linux/pgtable.h \
+    $(wildcard include/config/pgtable/levels.h) \
+    $(wildcard include/config/highpte.h) \
+    $(wildcard include/config/have/arch/transparent/hugepage/pud.h) \
+    $(wildcard include/config/have/arch/soft/dirty.h) \
+    $(wildcard include/config/arch/enable/thp/migration.h) \
+    $(wildcard include/config/x86/espfix64.h) \
+  arch/arm/include/asm/pgtable.h \
+  arch/arm/include/asm/proc-fns.h \
+    $(wildcard include/config/big/little.h) \
+    $(wildcard include/config/harden/branch/predictor.h) \
+  arch/arm/include/asm/glue-proc.h \
+    $(wildcard include/config/cpu/arm7tdmi.h) \
+    $(wildcard include/config/cpu/arm720t.h) \
+    $(wildcard include/config/cpu/arm740t.h) \
+    $(wildcard include/config/cpu/arm9tdmi.h) \
+    $(wildcard include/config/cpu/arm920t.h) \
+    $(wildcard include/config/cpu/arm922t.h) \
+    $(wildcard include/config/cpu/arm925t.h) \
+    $(wildcard include/config/cpu/arm926t.h) \
+    $(wildcard include/config/cpu/arm940t.h) \
+    $(wildcard include/config/cpu/arm946e.h) \
+    $(wildcard include/config/cpu/arm1020.h) \
+    $(wildcard include/config/cpu/arm1020e.h) \
+    $(wildcard include/config/cpu/arm1022.h) \
+    $(wildcard include/config/cpu/arm1026.h) \
+    $(wildcard include/config/cpu/mohawk.h) \
+    $(wildcard include/config/cpu/feroceon.h) \
+    $(wildcard include/config/cpu/v6k.h) \
+    $(wildcard include/config/cpu/pj4b.h) \
+    $(wildcard include/config/cpu/v7.h) \
+  include/asm-generic/pgtable-nopud.h \
+  include/asm-generic/pgtable-nop4d.h \
+  arch/arm/include/asm/pgtable-hwdef.h \
+  arch/arm/include/asm/pgtable-2level-hwdef.h \
+  arch/arm/include/asm/tlbflush.h \
+    $(wildcard include/config/smp/on/up.h) \
+    $(wildcard include/config/cpu/tlb/v4wt.h) \
+    $(wildcard include/config/cpu/tlb/fa.h) \
+    $(wildcard include/config/cpu/tlb/v4wbi.h) \
+    $(wildcard include/config/cpu/tlb/feroceon.h) \
+    $(wildcard include/config/cpu/tlb/v4wb.h) \
+    $(wildcard include/config/cpu/tlb/v6.h) \
+    $(wildcard include/config/cpu/tlb/v7.h) \
+    $(wildcard include/config/arm/errata/720789.h) \
+    $(wildcard include/config/arm/errata/798181.h) \
+  arch/arm/include/asm/pgtable-2level.h \
+  include/asm-generic/pgtable_uffd.h \
+    $(wildcard include/config/have/arch/userfaultfd/wp.h) \
+  include/linux/huge_mm.h \
+  include/linux/sched/coredump.h \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+  include/linux/vmstat.h \
+    $(wildcard include/config/vm/event/counters.h) \
+    $(wildcard include/config/debug/tlbflush.h) \
+    $(wildcard include/config/debug/vm/vmacache.h) \
+  include/linux/vm_event_item.h \
+    $(wildcard include/config/memory/balloon.h) \
+    $(wildcard include/config/balloon/compaction.h) \
+  include/linux/highmem.h \
+    $(wildcard include/config/x86/32.h) \
+    $(wildcard include/config/debug/highmem.h) \
+  arch/arm/include/asm/cacheflush.h \
+    $(wildcard include/config/arm/errata/411920.h) \
+    $(wildcard include/config/cpu/cache/vipt.h) \
+    $(wildcard include/config/outer/cache.h) \
+    $(wildcard include/config/frame/pointer.h) \
+    $(wildcard include/config/cpu/icache/mismatch/workaround.h) \
+  arch/arm/include/asm/glue-cache.h \
+    $(wildcard include/config/cpu/cache/v4.h) \
+    $(wildcard include/config/cpu/cache/v4wb.h) \
+    $(wildcard include/config/cache/b15/rac.h) \
+  arch/arm/include/asm/cachetype.h \
+    $(wildcard include/config/cpu/cache/vivt.h) \
+  arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+  arch/arm/include/asm/kmap_types.h \
+  include/linux/hugetlb_inline.h \
+  include/linux/proc_fs.h \
+    $(wildcard include/config/proc/pid/arch/status.h) \
+  include/linux/kallsyms.h \
+    $(wildcard include/config/kallsyms/all.h) \
+  include/linux/of_gpio.h \
+  include/generated/uapi/linux/version.h \
+  include/linux/rtc.h \
+    $(wildcard include/config/rtc/intf/dev/uie/emul.h) \
+    $(wildcard include/config/rtc/hctosys/device.h) \
+    $(wildcard include/config/rtc/nvmem.h) \
+    $(wildcard include/config/rtc/intf/sysfs.h) \
+  include/linux/nvmem-provider.h \
+    $(wildcard include/config/nvmem.h) \
+  include/uapi/linux/rtc.h \
+  include/linux/cdev.h \
+  include/linux/poll.h \
+  include/uapi/linux/poll.h \
+  arch/arm/include/generated/uapi/asm/poll.h \
+  include/uapi/asm-generic/poll.h \
+  include/uapi/linux/eventpoll.h \
+  include/linux/fb.h \
+    $(wildcard include/config/gumstix/am200epd.h) \
+    $(wildcard include/config/fb/notify.h) \
+    $(wildcard include/config/fb/deferred/io.h) \
+    $(wildcard include/config/fb/tileblitting.h) \
+    $(wildcard include/config/fb/backlight.h) \
+    $(wildcard include/config/fb/foreign/endian.h) \
+    $(wildcard include/config/fb/both/endian.h) \
+    $(wildcard include/config/fb/big/endian.h) \
+    $(wildcard include/config/fb/little/endian.h) \
+  include/linux/kgdb.h \
+    $(wildcard include/config/have/arch/kgdb.h) \
+    $(wildcard include/config/kgdb.h) \
+    $(wildcard include/config/serial/kgdb/nmi.h) \
+    $(wildcard include/config/kgdb/honour/blocklist.h) \
+  include/linux/kprobes.h \
+    $(wildcard include/config/kretprobes.h) \
+    $(wildcard include/config/kprobes/sanity/test.h) \
+    $(wildcard include/config/optprobes.h) \
+    $(wildcard include/config/kprobes/on/ftrace.h) \
+  include/linux/ftrace.h \
+    $(wildcard include/config/function/tracer.h) \
+    $(wildcard include/config/dynamic/ftrace.h) \
+    $(wildcard include/config/dynamic/ftrace/with/regs.h) \
+    $(wildcard include/config/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/have/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/stack/tracer.h) \
+    $(wildcard include/config/function/profiler.h) \
+    $(wildcard include/config/ftrace/syscalls.h) \
+  include/linux/trace_clock.h \
+  arch/arm/include/generated/asm/trace_clock.h \
+  include/asm-generic/trace_clock.h \
+  include/linux/ptrace.h \
+  include/linux/pid_namespace.h \
+    $(wildcard include/config/pid/ns.h) \
+  include/linux/nsproxy.h \
+  include/linux/ns_common.h \
+  include/uapi/linux/ptrace.h \
+  arch/arm/include/asm/ftrace.h \
+  arch/arm/include/asm/kprobes.h \
+  include/asm-generic/kprobes.h \
+  arch/arm/include/asm/probes.h \
+  arch/arm/include/asm/kgdb.h \
+  include/uapi/linux/fb.h \
+  include/linux/backlight.h \
+    $(wildcard include/config/backlight/class/device.h) \
+  drivers/input/touchscreen/hxchipset/himax_ic_core.h \
+
+drivers/input/touchscreen/hxchipset/himax_ic_HX83193.o: $(deps_drivers/input/touchscreen/hxchipset/himax_ic_HX83193.o)
+
+$(deps_drivers/input/touchscreen/hxchipset/himax_ic_HX83193.o):
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_ic_incell_core.o.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_ic_incell_core.o.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_ic_incell_core.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_ic_incell_core.o.cmd	2024-06-14 10:43:31.772186056 +0200
@@ -0,0 +1,1212 @@
+cmd_drivers/input/touchscreen/hxchipset/himax_ic_incell_core.o := /mnt/buildramdisk/br-output/host/bin/arm-buildroot-linux-uclibcgnueabihf-gcc -Wp,-MMD,drivers/input/touchscreen/hxchipset/.himax_ic_incell_core.o.d -nostdinc -isystem /mnt/buildramdisk/br-output/host/lib/gcc/arm-buildroot-linux-uclibcgnueabihf/10.3.0/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -include ./include/linux/compiler_types.h -D__KERNEL__ -mlittle-endian -fmacro-prefix-map=./= -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=implicit-function-declaration -Werror=implicit-int -Werror=return-type -Wno-format-security -std=gnu89 -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mfpu=vfp -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-address-of-packed-member -O2 -fno-allow-store-data-races -Wframe-larger-than=1024 -fstack-protector-strong -Wimplicit-fallthrough -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -pg -Wdeclaration-after-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -Wno-zero-length-bounds -Wno-array-bounds -Wno-stringop-overflow -Wno-restrict -Wno-maybe-uninitialized -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init -Wno-packed-not-aligned -Wno-attribute-alias -DHX_CONFIG_FB -D__HIMAX_MOD__ -D__HIMAX_HX83193_MOD__ -D__HIMAX_MOD__  -DMODULE  -DKBUILD_BASENAME='"himax_ic_incell_core"' -DKBUILD_MODNAME='"himax_mmi"' -c -o drivers/input/touchscreen/hxchipset/himax_ic_incell_core.o drivers/input/touchscreen/hxchipset/himax_ic_incell_core.c
+
+source_drivers/input/touchscreen/hxchipset/himax_ic_incell_core.o := drivers/input/touchscreen/hxchipset/himax_ic_incell_core.c
+
+deps_drivers/input/touchscreen/hxchipset/himax_ic_incell_core.o := \
+    $(wildcard include/config/touchscreen/himax/ic/hx83194.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx8530.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83195.h) \
+    $(wildcard include/config/table.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83180.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83181.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83192.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83193.h) \
+  include/linux/kconfig.h \
+    $(wildcard include/config/cc/version/text.h) \
+    $(wildcard include/config/cpu/big/endian.h) \
+    $(wildcard include/config/booger.h) \
+    $(wildcard include/config/foo.h) \
+  include/linux/compiler_types.h \
+    $(wildcard include/config/have/arch/compiler/h.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/cc/has/asm/inline.h) \
+  include/linux/compiler_attributes.h \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arm64.h) \
+    $(wildcard include/config/retpoline.h) \
+    $(wildcard include/config/arch/use/builtin/bswap.h) \
+    $(wildcard include/config/kcov.h) \
+  drivers/input/touchscreen/hxchipset/himax_ic_core.h \
+  drivers/input/touchscreen/hxchipset/himax_platform.h \
+    $(wildcard include/config/touchscreen/himax/debug.h) \
+  include/linux/delay.h \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/preempt/rt.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/panic/timeout.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  include/linux/limits.h \
+  include/uapi/linux/limits.h \
+  include/linux/types.h \
+    $(wildcard include/config/have/uid16.h) \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  include/uapi/linux/types.h \
+  arch/arm/include/uapi/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  include/uapi/asm-generic/int-ll64.h \
+  arch/arm/include/generated/uapi/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/uapi/asm-generic/bitsperlong.h \
+  include/uapi/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/uapi/linux/stddef.h \
+  include/linux/compiler_types.h \
+  arch/arm/include/uapi/asm/posix_types.h \
+  include/uapi/asm-generic/posix_types.h \
+  include/vdso/limits.h \
+  include/linux/linkage.h \
+    $(wildcard include/config/arch/use/sym/annotations.h) \
+  include/linux/stringify.h \
+  include/linux/export.h \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/module/rel/crcs.h) \
+    $(wildcard include/config/have/arch/prel32/relocations.h) \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/trim/unused/ksyms.h) \
+    $(wildcard include/config/unused/symbols.h) \
+  arch/arm/include/asm/linkage.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/stack/validation.h) \
+  arch/arm/include/generated/asm/rwonce.h \
+  include/asm-generic/rwonce.h \
+  include/linux/kasan-checks.h \
+    $(wildcard include/config/kasan.h) \
+  include/linux/kcsan-checks.h \
+    $(wildcard include/config/kcsan.h) \
+    $(wildcard include/config/kcsan/ignore/atomics.h) \
+  include/linux/bitops.h \
+  include/linux/bits.h \
+  include/linux/const.h \
+  include/vdso/const.h \
+  include/uapi/linux/const.h \
+  include/vdso/bits.h \
+  include/linux/build_bug.h \
+  arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  arch/arm/include/asm/irqflags.h \
+    $(wildcard include/config/cpu/v7m.h) \
+  arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/arm/thumb.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+  arch/arm/include/uapi/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+  arch/arm/include/asm/hwcap.h \
+  arch/arm/include/uapi/asm/hwcap.h \
+  include/asm-generic/irqflags.h \
+  arch/arm/include/asm/percpu.h \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/percpu.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+    $(wildcard include/config/amd/mem/encrypt.h) \
+  arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arm/heavy/mb.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+    $(wildcard include/config/cpu/spectre.h) \
+  include/asm-generic/barrier.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/builtin-__fls.h \
+  include/asm-generic/bitops/builtin-__ffs.h \
+  include/asm-generic/bitops/builtin-fls.h \
+  include/asm-generic/bitops/builtin-ffs.h \
+  include/asm-generic/bitops/ffz.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/atomic.h \
+  arch/arm/include/asm/atomic.h \
+    $(wildcard include/config/generic/atomic64.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/linux/prefetch.h \
+  arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/binfmt/elf/fdpic.h) \
+  arch/arm/include/asm/hw_breakpoint.h \
+  arch/arm/include/asm/unified.h \
+  arch/arm/include/asm/vdso/processor.h \
+    $(wildcard include/config/arm/errata/754327.h) \
+  arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/atomic-fallback.h \
+  include/asm-generic/atomic-long.h \
+  include/asm-generic/bitops/find.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+  include/asm-generic/bitops/le.h \
+  arch/arm/include/uapi/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/uapi/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  include/uapi/linux/swab.h \
+  arch/arm/include/asm/swab.h \
+  arch/arm/include/uapi/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/minmax.h \
+  include/linux/printk.h \
+    $(wildcard include/config/message/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/quiet.h) \
+    $(wildcard include/config/early/printk.h) \
+    $(wildcard include/config/printk/nmi.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/dynamic/debug/core.h) \
+  include/linux/init.h \
+    $(wildcard include/config/strict/kernel/rwx.h) \
+    $(wildcard include/config/strict/module/rwx.h) \
+  include/linux/kern_levels.h \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/uapi/linux/kernel.h \
+  include/uapi/linux/sysinfo.h \
+  include/linux/ratelimit_types.h \
+  include/uapi/linux/param.h \
+  arch/arm/include/generated/uapi/asm/param.h \
+  include/asm-generic/param.h \
+    $(wildcard include/config/hz.h) \
+  include/uapi/asm-generic/param.h \
+  include/linux/spinlock_types.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep_types.h \
+    $(wildcard include/config/prove/raw/lock/nesting.h) \
+    $(wildcard include/config/preempt/lock.h) \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+  include/linux/rwlock_types.h \
+  arch/arm/include/asm/div64.h \
+  arch/arm/include/asm/compiler.h \
+  include/asm-generic/div64.h \
+  arch/arm/include/asm/delay.h \
+  arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/xip/kernel.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+    $(wildcard include/config/xip/phys/addr.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  include/linux/pfn.h \
+  include/linux/fs.h \
+    $(wildcard include/config/read/only/thp/for/fs.h) \
+    $(wildcard include/config/fs/posix/acl.h) \
+    $(wildcard include/config/security.h) \
+    $(wildcard include/config/cgroup/writeback.h) \
+    $(wildcard include/config/ima.h) \
+    $(wildcard include/config/file/locking.h) \
+    $(wildcard include/config/fsnotify.h) \
+    $(wildcard include/config/fs/encryption.h) \
+    $(wildcard include/config/fs/verity.h) \
+    $(wildcard include/config/preemption.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/unicode.h) \
+    $(wildcard include/config/compat.h) \
+    $(wildcard include/config/quota.h) \
+    $(wildcard include/config/fs/dax.h) \
+    $(wildcard include/config/mandatory/file/locking.h) \
+    $(wildcard include/config/block.h) \
+    $(wildcard include/config/migration.h) \
+  include/linux/wait_bit.h \
+  include/linux/wait.h \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+    $(wildcard include/config/page/poisoning/zero.h) \
+  include/linux/spinlock.h \
+  include/linux/preempt.h \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/trace/preempt/toggle.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  arch/arm/include/generated/asm/preempt.h \
+  include/asm-generic/preempt.h \
+  include/linux/thread_info.h \
+    $(wildcard include/config/thread/info/in/task.h) \
+    $(wildcard include/config/have/arch/within/stack/frames.h) \
+    $(wildcard include/config/hardened/usercopy.h) \
+  include/linux/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/bug/on/data/corruption.h) \
+  arch/arm/include/asm/bug.h \
+    $(wildcard include/config/debug/bugverbose.h) \
+  arch/arm/include/asm/opcodes.h \
+    $(wildcard include/config/cpu/endian/be32.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  include/linux/instrumentation.h \
+    $(wildcard include/config/debug/entry.h) \
+  include/linux/restart_block.h \
+  include/linux/time64.h \
+  include/linux/math64.h \
+    $(wildcard include/config/arch/supports/int128.h) \
+  include/vdso/math64.h \
+  include/vdso/time64.h \
+  include/uapi/linux/time.h \
+  include/uapi/linux/time_types.h \
+  include/linux/errno.h \
+  include/uapi/linux/errno.h \
+  arch/arm/include/generated/uapi/asm/errno.h \
+  include/uapi/asm-generic/errno.h \
+  include/uapi/asm-generic/errno-base.h \
+  arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/stackprotector/per/task.h) \
+    $(wildcard include/config/crunch.h) \
+    $(wildcard include/config/arm/thumbee.h) \
+  arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+    $(wildcard include/config/kuser/helpers.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+  arch/arm/include/asm/glue.h \
+  arch/arm/include/asm/pgtable-2level-types.h \
+  include/asm-generic/getorder.h \
+  include/linux/bottom_half.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/debug/locking/api/selftests.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/up/late/init.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+    $(wildcard include/config/fortify/source.h) \
+  include/uapi/linux/string.h \
+  arch/arm/include/asm/string.h \
+    $(wildcard include/config/bcm2835/fast/memcpy.h) \
+  include/linux/smp_types.h \
+  include/linux/llist.h \
+    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
+  arch/arm/include/asm/smp.h \
+  arch/arm/include/generated/asm/mmiowb.h \
+  include/asm-generic/mmiowb.h \
+    $(wildcard include/config/mmiowb.h) \
+  arch/arm/include/asm/spinlock.h \
+  include/linux/rwlock.h \
+    $(wildcard include/config/preempt.h) \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  arch/arm/include/generated/asm/current.h \
+  include/asm-generic/current.h \
+  include/uapi/linux/wait.h \
+  include/linux/kdev_t.h \
+  include/uapi/linux/kdev_t.h \
+  include/linux/dcache.h \
+  include/linux/rculist.h \
+    $(wildcard include/config/prove/rcu/list.h) \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tasks/rcu/generic.h) \
+    $(wildcard include/config/rcu/stall/common.h) \
+    $(wildcard include/config/no/hz/full.h) \
+    $(wildcard include/config/rcu/nocb/cpu.h) \
+    $(wildcard include/config/tasks/rcu.h) \
+    $(wildcard include/config/tasks/trace/rcu.h) \
+    $(wildcard include/config/tasks/rude/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/prove/rcu.h) \
+    $(wildcard include/config/rcu/boost.h) \
+    $(wildcard include/config/arch/weak/release/acquire.h) \
+  include/linux/rcutree.h \
+  include/linux/rculist_bl.h \
+  include/linux/list_bl.h \
+  include/linux/bit_spinlock.h \
+  include/linux/seqlock.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/mutex/spin/on/owner.h) \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/osq_lock.h \
+  include/linux/debug_locks.h \
+  include/linux/ww_mutex.h \
+    $(wildcard include/config/debug/ww/mutex/slowpath.h) \
+  include/linux/lockref.h \
+    $(wildcard include/config/arch/use/cmpxchg/lockref.h) \
+  include/generated/bounds.h \
+  include/linux/stringhash.h \
+    $(wildcard include/config/dcache/word/access.h) \
+  include/linux/hash.h \
+    $(wildcard include/config/have/arch/hash.h) \
+  include/linux/path.h \
+  include/linux/stat.h \
+  arch/arm/include/uapi/asm/stat.h \
+  include/uapi/linux/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+    $(wildcard include/config/posix/timers.h) \
+  include/linux/time32.h \
+  include/linux/timex.h \
+  include/uapi/linux/timex.h \
+  arch/arm/include/asm/timex.h \
+  include/vdso/time32.h \
+  include/vdso/time.h \
+  include/linux/uidgid.h \
+    $(wildcard include/config/multiuser.h) \
+    $(wildcard include/config/user/ns.h) \
+  include/linux/highuid.h \
+  include/linux/list_lru.h \
+    $(wildcard include/config/memcg/kmem.h) \
+  include/linux/nodemask.h \
+    $(wildcard include/config/numa.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+    $(wildcard include/config/numa/keep/meminfo.h) \
+  include/linux/shrinker.h \
+    $(wildcard include/config/memcg.h) \
+  include/linux/radix-tree.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/vm/pgflags.h) \
+  include/linux/xarray.h \
+    $(wildcard include/config/xarray/multi.h) \
+  include/linux/gfp.h \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/zone/device.h) \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/contig/alloc.h) \
+    $(wildcard include/config/cma.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/isolation.h) \
+    $(wildcard include/config/zsmalloc.h) \
+    $(wildcard include/config/shadow/call/stack.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/transparent/hugepage.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/page/extension.h) \
+    $(wildcard include/config/deferred/struct/page/init.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/page-flags-layout.h \
+    $(wildcard include/config/numa/balancing.h) \
+    $(wildcard include/config/kasan/sw/tags.h) \
+  include/linux/mm_types.h \
+    $(wildcard include/config/have/aligned/struct/page.h) \
+    $(wildcard include/config/userfaultfd.h) \
+    $(wildcard include/config/swap.h) \
+    $(wildcard include/config/have/arch/compat/mmap/bases.h) \
+    $(wildcard include/config/membarrier.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+    $(wildcard include/config/arch/want/batched/unmap/tlb/flush.h) \
+    $(wildcard include/config/iommu/support.h) \
+  include/linux/mm_types_task.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/arch/enable/split/pmd/ptlock.h) \
+  include/linux/auxvec.h \
+  include/uapi/linux/auxvec.h \
+  arch/arm/include/asm/auxvec.h \
+  arch/arm/include/uapi/asm/auxvec.h \
+  include/linux/rbtree.h \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/spin/on/owner.h) \
+    $(wildcard include/config/debug/rwsems.h) \
+  include/linux/err.h \
+  include/linux/completion.h \
+  include/linux/swait.h \
+  include/linux/uprobes.h \
+    $(wildcard include/config/uprobes.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+    $(wildcard include/config/sysfs.h) \
+    $(wildcard include/config/wq/watchdog.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/debug/objects/timers.h) \
+    $(wildcard include/config/no/hz/common.h) \
+  include/linux/ktime.h \
+  include/linux/jiffies.h \
+  include/vdso/jiffies.h \
+  include/generated/timeconst.h \
+  include/vdso/ktime.h \
+  include/linux/timekeeping.h \
+  include/linux/timekeeping32.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+    $(wildcard include/config/vdso.h) \
+  include/linux/page-flags.h \
+    $(wildcard include/config/arch/uses/pg/uncached.h) \
+    $(wildcard include/config/memory/failure.h) \
+    $(wildcard include/config/idle/page/tracking.h) \
+    $(wildcard include/config/thp/swap.h) \
+    $(wildcard include/config/ksm.h) \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/arch/has/add/pages.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/have/bootmem/info/node.h) \
+  include/linux/notifier.h \
+    $(wildcard include/config/tree/srcu.h) \
+  include/linux/srcu.h \
+    $(wildcard include/config/tiny/srcu.h) \
+    $(wildcard include/config/srcu.h) \
+  include/linux/rcu_segcblist.h \
+  include/linux/srcutree.h \
+  include/linux/rcu_node_tree.h \
+    $(wildcard include/config/rcu/fanout.h) \
+    $(wildcard include/config/rcu/fanout/leaf.h) \
+  include/linux/topology.h \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+    $(wildcard include/config/sched/smt.h) \
+  include/linux/arch_topology.h \
+    $(wildcard include/config/generic/arch/topology.h) \
+  arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+    $(wildcard include/config/bl/switcher.h) \
+  include/asm-generic/topology.h \
+  include/linux/kconfig.h \
+  include/linux/local_lock.h \
+  include/linux/local_lock_internal.h \
+  include/linux/pid.h \
+  include/linux/refcount.h \
+  include/linux/capability.h \
+  include/uapi/linux/capability.h \
+  include/linux/semaphore.h \
+  include/linux/fcntl.h \
+    $(wildcard include/config/arch/32bit/off/t.h) \
+  include/uapi/linux/fcntl.h \
+  arch/arm/include/uapi/asm/fcntl.h \
+  include/uapi/asm-generic/fcntl.h \
+  include/uapi/linux/openat2.h \
+  include/linux/migrate_mode.h \
+  include/linux/percpu-rwsem.h \
+  include/linux/rcuwait.h \
+  include/linux/sched/signal.h \
+    $(wildcard include/config/sched/autogroup.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/stack/growsup.h) \
+  include/linux/signal.h \
+    $(wildcard include/config/proc/fs.h) \
+  include/linux/signal_types.h \
+    $(wildcard include/config/old/sigaction.h) \
+  include/uapi/linux/signal.h \
+  arch/arm/include/asm/signal.h \
+  arch/arm/include/uapi/asm/signal.h \
+  include/uapi/asm-generic/signal-defs.h \
+  arch/arm/include/uapi/asm/sigcontext.h \
+  arch/arm/include/generated/uapi/asm/siginfo.h \
+  include/uapi/asm-generic/siginfo.h \
+  include/linux/sched.h \
+    $(wildcard include/config/virt/cpu/accounting/native.h) \
+    $(wildcard include/config/sched/info.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/uclamp/task.h) \
+    $(wildcard include/config/uclamp/buckets/count.h) \
+    $(wildcard include/config/cgroup/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/psi.h) \
+    $(wildcard include/config/compat/brk.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/blk/cgroup.h) \
+    $(wildcard include/config/stackprotector.h) \
+    $(wildcard include/config/arch/has/scaled/cputime.h) \
+    $(wildcard include/config/virt/cpu/accounting/gen.h) \
+    $(wildcard include/config/posix/cputimers.h) \
+    $(wildcard include/config/posix/cpu/timers/task/work.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/io/uring.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/ubsan.h) \
+    $(wildcard include/config/ubsan/trap.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/x86/cpu/resctrl.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/rseq.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/kunit.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/bcache.h) \
+    $(wildcard include/config/vmap/stack.h) \
+    $(wildcard include/config/livepatch.h) \
+    $(wildcard include/config/gcc/plugin/stackleak.h) \
+    $(wildcard include/config/x86/mce.h) \
+    $(wildcard include/config/arch/task/struct/on/stack.h) \
+    $(wildcard include/config/debug/rseq.h) \
+  include/uapi/linux/sched.h \
+  include/linux/sem.h \
+  include/uapi/linux/sem.h \
+  include/linux/ipc.h \
+  include/linux/rhashtable-types.h \
+  include/uapi/linux/ipc.h \
+  arch/arm/include/generated/uapi/asm/ipcbuf.h \
+  include/uapi/asm-generic/ipcbuf.h \
+  arch/arm/include/generated/uapi/asm/sembuf.h \
+  include/uapi/asm-generic/sembuf.h \
+  include/linux/shm.h \
+  include/uapi/linux/shm.h \
+  include/uapi/asm-generic/hugetlb_encode.h \
+  arch/arm/include/generated/uapi/asm/shmbuf.h \
+  include/uapi/asm-generic/shmbuf.h \
+  arch/arm/include/asm/shmparam.h \
+  include/linux/kcov.h \
+  include/uapi/linux/kcov.h \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/plist.h) \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+    $(wildcard include/config/time/low/res.h) \
+    $(wildcard include/config/timerfd.h) \
+  include/linux/hrtimer_defs.h \
+  include/linux/timerqueue.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+    $(wildcard include/config/have/arch/seccomp/filter.h) \
+    $(wildcard include/config/seccomp/filter.h) \
+    $(wildcard include/config/checkpoint/restore.h) \
+  include/uapi/linux/seccomp.h \
+  arch/arm/include/generated/asm/seccomp.h \
+  include/asm-generic/seccomp.h \
+  include/uapi/linux/unistd.h \
+  arch/arm/include/asm/unistd.h \
+    $(wildcard include/config/oabi/compat.h) \
+  arch/arm/include/uapi/asm/unistd.h \
+  arch/arm/include/generated/uapi/asm/unistd-eabi.h \
+  arch/arm/include/generated/uapi/asm/unistd-common.h \
+  arch/arm/include/generated/asm/unistd-nr.h \
+  include/linux/resource.h \
+  include/uapi/linux/resource.h \
+  arch/arm/include/generated/uapi/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/uapi/asm-generic/resource.h \
+  include/linux/latencytop.h \
+  include/linux/sched/prio.h \
+  include/linux/sched/types.h \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/posix-timers.h \
+  include/linux/alarmtimer.h \
+    $(wildcard include/config/rtc/class.h) \
+  include/linux/task_work.h \
+  include/uapi/linux/rseq.h \
+  include/linux/kcsan.h \
+  include/linux/sched/jobctl.h \
+  include/linux/sched/task.h \
+    $(wildcard include/config/have/exit/thread.h) \
+    $(wildcard include/config/arch/wants/dynamic/task/struct.h) \
+    $(wildcard include/config/have/arch/thread/struct/whitelist.h) \
+  include/linux/uaccess.h \
+    $(wildcard include/config/set/fs.h) \
+  include/linux/fault-inject-usercopy.h \
+    $(wildcard include/config/fault/injection/usercopy.h) \
+  include/linux/instrumented.h \
+  arch/arm/include/asm/uaccess.h \
+    $(wildcard include/config/cpu/sw/domain/pan.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+    $(wildcard include/config/uaccess/with/memcpy.h) \
+  arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/cp15/mmu.h) \
+  arch/arm/include/generated/asm/extable.h \
+  include/asm-generic/extable.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+  include/linux/key.h \
+    $(wildcard include/config/key/notifications.h) \
+    $(wildcard include/config/net.h) \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/uapi/linux/sysctl.h \
+  include/linux/assoc_array.h \
+    $(wildcard include/config/associative/array.h) \
+  include/linux/sched/user.h \
+    $(wildcard include/config/fanotify.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/bpf/syscall.h) \
+    $(wildcard include/config/watch/queue.h) \
+  include/linux/ratelimit.h \
+  include/linux/rcu_sync.h \
+  include/linux/delayed_call.h \
+  include/linux/uuid.h \
+  include/uapi/linux/uuid.h \
+  include/linux/errseq.h \
+  include/linux/ioprio.h \
+  include/linux/sched/rt.h \
+  include/linux/iocontext.h \
+  include/linux/fs_types.h \
+  include/uapi/linux/fs.h \
+  include/uapi/linux/ioctl.h \
+  arch/arm/include/generated/uapi/asm/ioctl.h \
+  include/asm-generic/ioctl.h \
+  include/uapi/asm-generic/ioctl.h \
+  include/linux/quota.h \
+    $(wildcard include/config/quota/netlink/interface.h) \
+  include/linux/percpu_counter.h \
+  include/uapi/linux/dqblk_xfs.h \
+  include/linux/dqblk_v1.h \
+  include/linux/dqblk_v2.h \
+  include/linux/dqblk_qtree.h \
+  include/linux/projid.h \
+  include/uapi/linux/quota.h \
+  include/linux/nfs_fs_i.h \
+  include/linux/gpio.h \
+    $(wildcard include/config/gpiolib.h) \
+    $(wildcard include/config/arch/have/custom/gpio/h.h) \
+  arch/arm/include/asm/gpio.h \
+    $(wildcard include/config/arch/nr/gpio.h) \
+  include/asm-generic/gpio.h \
+  include/linux/gpio/driver.h \
+    $(wildcard include/config/irq/domain/hierarchy.h) \
+    $(wildcard include/config/gpio/generic.h) \
+    $(wildcard include/config/gpiolib/irqchip.h) \
+    $(wildcard include/config/of/gpio.h) \
+    $(wildcard include/config/of.h) \
+    $(wildcard include/config/pinctrl.h) \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/energy/model.h) \
+    $(wildcard include/config/generic/msi/irq/domain.h) \
+    $(wildcard include/config/generic/msi/irq.h) \
+    $(wildcard include/config/dma/ops.h) \
+    $(wildcard include/config/dma/declare/coherent.h) \
+    $(wildcard include/config/dma/cma.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/device.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu/all.h) \
+    $(wildcard include/config/dma/ops/bypass.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/dev_printk.h \
+  include/linux/energy_model.h \
+  include/linux/jump_label.h \
+    $(wildcard include/config/jump/label.h) \
+    $(wildcard include/config/have/arch/jump/label/relative.h) \
+  arch/arm/include/asm/jump_label.h \
+  include/linux/kobject.h \
+    $(wildcard include/config/uevent/helper.h) \
+    $(wildcard include/config/debug/kobject/release.h) \
+  include/linux/sysfs.h \
+  include/linux/kernfs.h \
+    $(wildcard include/config/kernfs.h) \
+  include/linux/idr.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/sched/cpufreq.h \
+    $(wildcard include/config/cpu/freq.h) \
+  include/linux/sched/topology.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/sched/idle.h \
+  include/linux/sched/sd_flags.h \
+  include/linux/ioport.h \
+    $(wildcard include/config/io/strict/devmem.h) \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/vt/console/sleep.h) \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  include/linux/overflow.h \
+  include/linux/device/bus.h \
+    $(wildcard include/config/acpi.h) \
+  include/linux/device/class.h \
+  include/linux/device/driver.h \
+  arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/arm/dma/use/iommu.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/irq.h \
+    $(wildcard include/config/generic/irq/effective/aff/mask.h) \
+    $(wildcard include/config/generic/irq/ipi.h) \
+    $(wildcard include/config/generic/irq/migration.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+    $(wildcard include/config/hardirqs/sw/resend.h) \
+    $(wildcard include/config/generic/irq/legacy/alloc/hwirq.h) \
+    $(wildcard include/config/generic/irq/legacy.h) \
+    $(wildcard include/config/generic/irq/multi/handler.h) \
+  include/linux/irqhandler.h \
+  include/linux/irqreturn.h \
+  include/linux/irqnr.h \
+  include/uapi/linux/irqnr.h \
+  include/linux/io.h \
+    $(wildcard include/config/have/arch/huge/vmap.h) \
+    $(wildcard include/config/has/ioport/map.h) \
+    $(wildcard include/config/pci.h) \
+  arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/asm-generic/io.h \
+    $(wildcard include/config/generic/iomap.h) \
+    $(wildcard include/config/generic/ioremap.h) \
+    $(wildcard include/config/virt/to/bus.h) \
+  include/linux/logic_pio.h \
+    $(wildcard include/config/indirect/pio.h) \
+  include/linux/fwnode.h \
+  include/linux/vmalloc.h \
+    $(wildcard include/config/kasan/vmalloc.h) \
+  arch/arm/include/asm/vmalloc.h \
+  include/linux/slab.h \
+    $(wildcard include/config/debug/slab.h) \
+    $(wildcard include/config/failslab.h) \
+    $(wildcard include/config/have/hardened/usercopy/allocator.h) \
+    $(wildcard include/config/slab.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+  include/linux/percpu-refcount.h \
+  include/linux/kasan.h \
+    $(wildcard include/config/kasan/generic.h) \
+    $(wildcard include/config/kasan/inline.h) \
+  arch/arm/include/asm/irq.h \
+    $(wildcard include/config/sparse/irq.h) \
+  arch/arm/include/generated/asm/irq_regs.h \
+  include/asm-generic/irq_regs.h \
+  include/linux/irqdesc.h \
+    $(wildcard include/config/generic/irq/debugfs.h) \
+    $(wildcard include/config/handle/domain/irq.h) \
+    $(wildcard include/config/irq/domain.h) \
+  arch/arm/include/asm/hw_irq.h \
+  include/linux/irqchip/chained_irq.h \
+  include/linux/irqdomain.h \
+  include/linux/of.h \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/promtree.h) \
+    $(wildcard include/config/of/kobj.h) \
+    $(wildcard include/config/of/numa.h) \
+    $(wildcard include/config/of/overlay.h) \
+  include/linux/mod_devicetable.h \
+  include/linux/property.h \
+  include/linux/pinctrl/pinctrl.h \
+    $(wildcard include/config/generic/pinconf.h) \
+  include/linux/seq_file.h \
+  include/linux/pinctrl/pinctrl-state.h \
+  include/linux/pinctrl/devinfo.h \
+  include/linux/pinctrl/consumer.h \
+  include/linux/pinctrl/pinconf-generic.h \
+  include/linux/pinctrl/machine.h \
+  include/linux/gpio/consumer.h \
+    $(wildcard include/config/gpio/sysfs.h) \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/slave.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+    $(wildcard include/config/i2c/mux.h) \
+  include/linux/acpi.h \
+    $(wildcard include/config/acpi/debugger.h) \
+    $(wildcard include/config/x86.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/acpi/processor/cstate.h) \
+    $(wildcard include/config/acpi/hotplug/cpu.h) \
+    $(wildcard include/config/acpi/hotplug/ioapic.h) \
+    $(wildcard include/config/x86/io/apic.h) \
+    $(wildcard include/config/acpi/wmi.h) \
+    $(wildcard include/config/acpi/numa.h) \
+    $(wildcard include/config/hibernation.h) \
+    $(wildcard include/config/acpi/hotplug/memory.h) \
+    $(wildcard include/config/acpi/container.h) \
+    $(wildcard include/config/acpi/gtdt.h) \
+    $(wildcard include/config/acpi/table/upgrade.h) \
+    $(wildcard include/config/acpi/watchdog.h) \
+    $(wildcard include/config/acpi/spcr/table.h) \
+    $(wildcard include/config/acpi/generic/gsi.h) \
+    $(wildcard include/config/acpi/lpit.h) \
+    $(wildcard include/config/acpi/pptt.h) \
+  include/linux/resource_ext.h \
+  include/acpi/acpi.h \
+  include/acpi/platform/acenv.h \
+  include/acpi/platform/acgcc.h \
+  include/acpi/platform/aclinux.h \
+    $(wildcard include/config/acpi/reduced/hardware/only.h) \
+    $(wildcard include/config/acpi/debug.h) \
+  include/linux/ctype.h \
+  include/acpi/acnames.h \
+  include/acpi/actypes.h \
+  include/acpi/acexcep.h \
+  include/acpi/actbl.h \
+  include/acpi/actbl1.h \
+  include/acpi/actbl2.h \
+  include/acpi/actbl3.h \
+  include/acpi/acrestyp.h \
+  include/acpi/platform/acenvex.h \
+  include/acpi/platform/aclinuxex.h \
+  include/acpi/platform/acgccex.h \
+  include/acpi/acoutput.h \
+  include/acpi/acpiosxf.h \
+  include/acpi/acpixf.h \
+  include/acpi/acconfig.h \
+  include/acpi/acbuffer.h \
+  include/acpi/acpi_numa.h \
+    $(wildcard include/config/acpi/hmat.h) \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/uapi/linux/i2c.h \
+  include/linux/interrupt.h \
+    $(wildcard include/config/irq/forced/threading.h) \
+    $(wildcard include/config/generic/irq/probe.h) \
+    $(wildcard include/config/irq/timings.h) \
+  include/linux/hardirq.h \
+  include/linux/context_tracking_state.h \
+    $(wildcard include/config/context/tracking.h) \
+  include/linux/static_key.h \
+  include/linux/ftrace_irq.h \
+    $(wildcard include/config/hwlat/tracer.h) \
+  include/linux/vtime.h \
+    $(wildcard include/config/virt/cpu/accounting.h) \
+    $(wildcard include/config/irq/time/accounting.h) \
+  arch/arm/include/asm/hardirq.h \
+  include/linux/irq_cpustat.h \
+  arch/arm/include/asm/sections.h \
+  include/asm-generic/sections.h \
+  drivers/input/touchscreen/hxchipset/himax_common.h \
+    $(wildcard include/config/touchscreen/himax/self/test.h) \
+  include/linux/input.h \
+  include/uapi/linux/input.h \
+  include/uapi/linux/input-event-codes.h \
+  include/linux/module.h \
+    $(wildcard include/config/modules/tree/lookup.h) \
+    $(wildcard include/config/module/sig.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/bpf/events.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/kprobes.h) \
+    $(wildcard include/config/have/static/call/inline.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/function/error/injection.h) \
+  include/linux/kmod.h \
+  include/linux/umh.h \
+  include/linux/elf.h \
+    $(wildcard include/config/arch/use/gnu/property.h) \
+    $(wildcard include/config/arch/have/elf/prot.h) \
+  arch/arm/include/asm/elf.h \
+  arch/arm/include/asm/vdso_datapage.h \
+  include/vdso/datapage.h \
+    $(wildcard include/config/arch/has/vdso/data.h) \
+  include/uapi/asm-generic/errno-base.h \
+  include/vdso/clocksource.h \
+    $(wildcard include/config/generic/gettimeofday.h) \
+  arch/arm/include/asm/vdso/clocksource.h \
+  include/vdso/processor.h \
+  arch/arm/include/asm/vdso/gettimeofday.h \
+    $(wildcard include/config/arm/arch/timer.h) \
+  arch/arm/include/asm/vdso/cp15.h \
+    $(wildcard include/config/cpu/cp15.h) \
+  arch/arm/include/asm/user.h \
+  include/uapi/linux/elf.h \
+  include/uapi/linux/elf-em.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/rbtree_latch.h \
+  include/linux/error-injection.h \
+  include/asm-generic/error-injection.h \
+  include/linux/tracepoint-defs.h \
+  include/linux/static_call_types.h \
+    $(wildcard include/config/have/static/call.h) \
+  arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+    $(wildcard include/config/arm/module/plts.h) \
+  include/asm-generic/module.h \
+    $(wildcard include/config/have/mod/arch/specific.h) \
+    $(wildcard include/config/modules/use/elf/rel.h) \
+    $(wildcard include/config/modules/use/elf/rela.h) \
+  include/linux/async.h \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+    $(wildcard include/config/superh.h) \
+  include/linux/input/mt.h \
+  include/linux/firmware.h \
+    $(wildcard include/config/fw/loader.h) \
+  include/linux/buffer_head.h \
+  include/linux/pagemap.h \
+  include/linux/mm.h \
+    $(wildcard include/config/have/arch/mmap/rnd/bits.h) \
+    $(wildcard include/config/have/arch/mmap/rnd/compat/bits.h) \
+    $(wildcard include/config/mem/soft/dirty.h) \
+    $(wildcard include/config/arch/uses/high/vma/flags.h) \
+    $(wildcard include/config/arch/has/pkeys.h) \
+    $(wildcard include/config/ppc.h) \
+    $(wildcard include/config/parisc.h) \
+    $(wildcard include/config/sparc64.h) \
+    $(wildcard include/config/arm64/mte.h) \
+    $(wildcard include/config/shmem.h) \
+    $(wildcard include/config/dev/pagemap/ops.h) \
+    $(wildcard include/config/device/private.h) \
+    $(wildcard include/config/pci/p2pdma.h) \
+    $(wildcard include/config/arch/has/pte/special.h) \
+    $(wildcard include/config/arch/has/pte/devmap.h) \
+    $(wildcard include/config/debug/vm/rb.h) \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/init/on/alloc/default/on.h) \
+    $(wildcard include/config/init/on/free/default/on.h) \
+    $(wildcard include/config/debug/pagealloc.h) \
+    $(wildcard include/config/arch/has/set/direct/map.h) \
+    $(wildcard include/config/hugetlbfs.h) \
+    $(wildcard include/config/mapping/dirty/helpers.h) \
+  include/linux/mmap_lock.h \
+  include/linux/range.h \
+  include/linux/page_ext.h \
+  include/linux/stacktrace.h \
+    $(wildcard include/config/stacktrace.h) \
+    $(wildcard include/config/arch/stackwalk.h) \
+    $(wildcard include/config/have/reliable/stacktrace.h) \
+  include/linux/stackdepot.h \
+  include/linux/page_ref.h \
+    $(wildcard include/config/debug/page/ref.h) \
+  include/linux/memremap.h \
+  include/linux/pgtable.h \
+    $(wildcard include/config/pgtable/levels.h) \
+    $(wildcard include/config/highpte.h) \
+    $(wildcard include/config/have/arch/transparent/hugepage/pud.h) \
+    $(wildcard include/config/have/arch/soft/dirty.h) \
+    $(wildcard include/config/arch/enable/thp/migration.h) \
+    $(wildcard include/config/x86/espfix64.h) \
+  arch/arm/include/asm/pgtable.h \
+  arch/arm/include/asm/proc-fns.h \
+    $(wildcard include/config/big/little.h) \
+    $(wildcard include/config/harden/branch/predictor.h) \
+  arch/arm/include/asm/glue-proc.h \
+    $(wildcard include/config/cpu/arm7tdmi.h) \
+    $(wildcard include/config/cpu/arm720t.h) \
+    $(wildcard include/config/cpu/arm740t.h) \
+    $(wildcard include/config/cpu/arm9tdmi.h) \
+    $(wildcard include/config/cpu/arm920t.h) \
+    $(wildcard include/config/cpu/arm922t.h) \
+    $(wildcard include/config/cpu/arm925t.h) \
+    $(wildcard include/config/cpu/arm926t.h) \
+    $(wildcard include/config/cpu/arm940t.h) \
+    $(wildcard include/config/cpu/arm946e.h) \
+    $(wildcard include/config/cpu/arm1020.h) \
+    $(wildcard include/config/cpu/arm1020e.h) \
+    $(wildcard include/config/cpu/arm1022.h) \
+    $(wildcard include/config/cpu/arm1026.h) \
+    $(wildcard include/config/cpu/mohawk.h) \
+    $(wildcard include/config/cpu/feroceon.h) \
+    $(wildcard include/config/cpu/v6k.h) \
+    $(wildcard include/config/cpu/pj4b.h) \
+    $(wildcard include/config/cpu/v7.h) \
+  include/asm-generic/pgtable-nopud.h \
+  include/asm-generic/pgtable-nop4d.h \
+  arch/arm/include/asm/pgtable-hwdef.h \
+  arch/arm/include/asm/pgtable-2level-hwdef.h \
+  arch/arm/include/asm/tlbflush.h \
+    $(wildcard include/config/smp/on/up.h) \
+    $(wildcard include/config/cpu/tlb/v4wt.h) \
+    $(wildcard include/config/cpu/tlb/fa.h) \
+    $(wildcard include/config/cpu/tlb/v4wbi.h) \
+    $(wildcard include/config/cpu/tlb/feroceon.h) \
+    $(wildcard include/config/cpu/tlb/v4wb.h) \
+    $(wildcard include/config/cpu/tlb/v6.h) \
+    $(wildcard include/config/cpu/tlb/v7.h) \
+    $(wildcard include/config/arm/errata/720789.h) \
+    $(wildcard include/config/arm/errata/798181.h) \
+  arch/arm/include/asm/pgtable-2level.h \
+  include/asm-generic/pgtable_uffd.h \
+    $(wildcard include/config/have/arch/userfaultfd/wp.h) \
+  include/linux/huge_mm.h \
+  include/linux/sched/coredump.h \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+  include/linux/vmstat.h \
+    $(wildcard include/config/vm/event/counters.h) \
+    $(wildcard include/config/debug/tlbflush.h) \
+    $(wildcard include/config/debug/vm/vmacache.h) \
+  include/linux/vm_event_item.h \
+    $(wildcard include/config/memory/balloon.h) \
+    $(wildcard include/config/balloon/compaction.h) \
+  include/linux/highmem.h \
+    $(wildcard include/config/x86/32.h) \
+    $(wildcard include/config/debug/highmem.h) \
+  arch/arm/include/asm/cacheflush.h \
+    $(wildcard include/config/arm/errata/411920.h) \
+    $(wildcard include/config/cpu/cache/vipt.h) \
+    $(wildcard include/config/outer/cache.h) \
+    $(wildcard include/config/frame/pointer.h) \
+    $(wildcard include/config/cpu/icache/mismatch/workaround.h) \
+  arch/arm/include/asm/glue-cache.h \
+    $(wildcard include/config/cpu/cache/v4.h) \
+    $(wildcard include/config/cpu/cache/v4wb.h) \
+    $(wildcard include/config/cache/b15/rac.h) \
+  arch/arm/include/asm/cachetype.h \
+    $(wildcard include/config/cpu/cache/vivt.h) \
+  arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+  arch/arm/include/asm/kmap_types.h \
+  include/linux/hugetlb_inline.h \
+  include/linux/proc_fs.h \
+    $(wildcard include/config/proc/pid/arch/status.h) \
+  include/linux/kallsyms.h \
+    $(wildcard include/config/kallsyms/all.h) \
+  include/linux/of_gpio.h \
+  include/generated/uapi/linux/version.h \
+  include/linux/rtc.h \
+    $(wildcard include/config/rtc/intf/dev/uie/emul.h) \
+    $(wildcard include/config/rtc/hctosys/device.h) \
+    $(wildcard include/config/rtc/nvmem.h) \
+    $(wildcard include/config/rtc/intf/sysfs.h) \
+  include/linux/nvmem-provider.h \
+    $(wildcard include/config/nvmem.h) \
+  include/uapi/linux/rtc.h \
+  include/linux/cdev.h \
+  include/linux/poll.h \
+  include/uapi/linux/poll.h \
+  arch/arm/include/generated/uapi/asm/poll.h \
+  include/uapi/asm-generic/poll.h \
+  include/uapi/linux/eventpoll.h \
+  include/linux/fb.h \
+    $(wildcard include/config/gumstix/am200epd.h) \
+    $(wildcard include/config/fb/notify.h) \
+    $(wildcard include/config/fb/deferred/io.h) \
+    $(wildcard include/config/fb/tileblitting.h) \
+    $(wildcard include/config/fb/backlight.h) \
+    $(wildcard include/config/fb/foreign/endian.h) \
+    $(wildcard include/config/fb/both/endian.h) \
+    $(wildcard include/config/fb/big/endian.h) \
+    $(wildcard include/config/fb/little/endian.h) \
+  include/linux/kgdb.h \
+    $(wildcard include/config/have/arch/kgdb.h) \
+    $(wildcard include/config/kgdb.h) \
+    $(wildcard include/config/serial/kgdb/nmi.h) \
+    $(wildcard include/config/kgdb/honour/blocklist.h) \
+  include/linux/kprobes.h \
+    $(wildcard include/config/kretprobes.h) \
+    $(wildcard include/config/kprobes/sanity/test.h) \
+    $(wildcard include/config/optprobes.h) \
+    $(wildcard include/config/kprobes/on/ftrace.h) \
+  include/linux/ftrace.h \
+    $(wildcard include/config/function/tracer.h) \
+    $(wildcard include/config/dynamic/ftrace.h) \
+    $(wildcard include/config/dynamic/ftrace/with/regs.h) \
+    $(wildcard include/config/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/have/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/stack/tracer.h) \
+    $(wildcard include/config/function/profiler.h) \
+    $(wildcard include/config/ftrace/syscalls.h) \
+  include/linux/trace_clock.h \
+  arch/arm/include/generated/asm/trace_clock.h \
+  include/asm-generic/trace_clock.h \
+  include/linux/ptrace.h \
+  include/linux/pid_namespace.h \
+    $(wildcard include/config/pid/ns.h) \
+  include/linux/nsproxy.h \
+  include/linux/ns_common.h \
+  include/uapi/linux/ptrace.h \
+  arch/arm/include/asm/ftrace.h \
+  arch/arm/include/asm/kprobes.h \
+  include/asm-generic/kprobes.h \
+  arch/arm/include/asm/probes.h \
+  arch/arm/include/asm/kgdb.h \
+  include/uapi/linux/fb.h \
+  include/linux/backlight.h \
+    $(wildcard include/config/backlight/class/device.h) \
+  drivers/input/touchscreen/hxchipset/himax_self_test.h \
+
+drivers/input/touchscreen/hxchipset/himax_ic_incell_core.o: $(deps_drivers/input/touchscreen/hxchipset/himax_ic_incell_core.o)
+
+$(deps_drivers/input/touchscreen/hxchipset/himax_ic_incell_core.o):
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_mmi.ko.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_mmi.ko.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_mmi.ko.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_mmi.ko.cmd	2024-06-14 10:43:31.772186056 +0200
@@ -0,0 +1 @@
+cmd_drivers/input/touchscreen/hxchipset/himax_mmi.ko := /mnt/buildramdisk/br-output/host/bin/arm-buildroot-linux-uclibcgnueabihf-ld -r -EL --build-id=sha1  -T scripts/module.lds -o drivers/input/touchscreen/hxchipset/himax_mmi.ko drivers/input/touchscreen/hxchipset/himax_mmi.o drivers/input/touchscreen/hxchipset/himax_mmi.mod.o;  true
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_mmi.mod.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_mmi.mod.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_mmi.mod.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_mmi.mod.cmd	2024-06-14 10:43:31.772186056 +0200
@@ -0,0 +1 @@
+cmd_drivers/input/touchscreen/hxchipset/himax_mmi.mod := { echo  drivers/input/touchscreen/hxchipset/himax_debug.o drivers/input/touchscreen/hxchipset/himax_self_test.o drivers/input/touchscreen/hxchipset/himax_ic_incell_core.o drivers/input/touchscreen/hxchipset/himax_ic_HX83193.o drivers/input/touchscreen/hxchipset/himax_common.o drivers/input/touchscreen/hxchipset/himax_platform.o;  echo; } > drivers/input/touchscreen/hxchipset/himax_mmi.mod
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_mmi.mod.o.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_mmi.mod.o.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_mmi.mod.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_mmi.mod.o.cmd	2024-06-14 10:43:31.772186056 +0200
@@ -0,0 +1,593 @@
+cmd_drivers/input/touchscreen/hxchipset/himax_mmi.mod.o := /mnt/buildramdisk/br-output/host/bin/arm-buildroot-linux-uclibcgnueabihf-gcc -Wp,-MMD,drivers/input/touchscreen/hxchipset/.himax_mmi.mod.o.d -nostdinc -isystem /mnt/buildramdisk/br-output/host/lib/gcc/arm-buildroot-linux-uclibcgnueabihf/10.3.0/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -include ./include/linux/compiler_types.h -D__KERNEL__ -mlittle-endian -fmacro-prefix-map=./= -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=implicit-function-declaration -Werror=implicit-int -Werror=return-type -Wno-format-security -std=gnu89 -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mfpu=vfp -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-address-of-packed-member -O2 -fno-allow-store-data-races -Wframe-larger-than=1024 -fstack-protector-strong -Wimplicit-fallthrough -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -pg -Wdeclaration-after-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -Wno-zero-length-bounds -Wno-array-bounds -Wno-stringop-overflow -Wno-restrict -Wno-maybe-uninitialized -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init -Wno-packed-not-aligned -Wno-attribute-alias  -DMODULE  -DKBUILD_BASENAME='"himax_mmi.mod"' -DKBUILD_MODNAME='"himax_mmi"' -c -o drivers/input/touchscreen/hxchipset/himax_mmi.mod.o drivers/input/touchscreen/hxchipset/himax_mmi.mod.c
+
+source_drivers/input/touchscreen/hxchipset/himax_mmi.mod.o := drivers/input/touchscreen/hxchipset/himax_mmi.mod.c
+
+deps_drivers/input/touchscreen/hxchipset/himax_mmi.mod.o := \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/retpoline.h) \
+  include/linux/kconfig.h \
+    $(wildcard include/config/cc/version/text.h) \
+    $(wildcard include/config/cpu/big/endian.h) \
+    $(wildcard include/config/booger.h) \
+    $(wildcard include/config/foo.h) \
+  include/linux/compiler_types.h \
+    $(wildcard include/config/have/arch/compiler/h.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/cc/has/asm/inline.h) \
+  include/linux/compiler_attributes.h \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arm64.h) \
+    $(wildcard include/config/arch/use/builtin/bswap.h) \
+    $(wildcard include/config/kcov.h) \
+  include/linux/module.h \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/sysfs.h) \
+    $(wildcard include/config/modules/tree/lookup.h) \
+    $(wildcard include/config/livepatch.h) \
+    $(wildcard include/config/unused/symbols.h) \
+    $(wildcard include/config/module/sig.h) \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/tree/srcu.h) \
+    $(wildcard include/config/bpf/events.h) \
+    $(wildcard include/config/jump/label.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+    $(wildcard include/config/kprobes.h) \
+    $(wildcard include/config/have/static/call/inline.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/function/error/injection.h) \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/types.h \
+    $(wildcard include/config/have/uid16.h) \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  include/uapi/linux/types.h \
+  arch/arm/include/uapi/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  include/uapi/asm-generic/int-ll64.h \
+  arch/arm/include/generated/uapi/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/uapi/asm-generic/bitsperlong.h \
+  include/uapi/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/uapi/linux/stddef.h \
+  include/linux/compiler_types.h \
+  arch/arm/include/uapi/asm/posix_types.h \
+  include/uapi/asm-generic/posix_types.h \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+    $(wildcard include/config/page/poisoning/zero.h) \
+  include/linux/const.h \
+  include/vdso/const.h \
+  include/uapi/linux/const.h \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/preempt/rt.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/panic/timeout.h) \
+  include/linux/limits.h \
+  include/uapi/linux/limits.h \
+  include/vdso/limits.h \
+  include/linux/linkage.h \
+    $(wildcard include/config/arch/use/sym/annotations.h) \
+  include/linux/stringify.h \
+  include/linux/export.h \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/module/rel/crcs.h) \
+    $(wildcard include/config/have/arch/prel32/relocations.h) \
+    $(wildcard include/config/trim/unused/ksyms.h) \
+  arch/arm/include/asm/linkage.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/stack/validation.h) \
+  arch/arm/include/generated/asm/rwonce.h \
+  include/asm-generic/rwonce.h \
+  include/linux/kasan-checks.h \
+    $(wildcard include/config/kasan.h) \
+  include/linux/kcsan-checks.h \
+    $(wildcard include/config/kcsan.h) \
+    $(wildcard include/config/kcsan/ignore/atomics.h) \
+  include/linux/bitops.h \
+  include/linux/bits.h \
+  include/vdso/bits.h \
+  include/linux/build_bug.h \
+  arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  arch/arm/include/asm/irqflags.h \
+    $(wildcard include/config/cpu/v7m.h) \
+  arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/arm/thumb.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+  arch/arm/include/uapi/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+  arch/arm/include/asm/hwcap.h \
+  arch/arm/include/uapi/asm/hwcap.h \
+  include/asm-generic/irqflags.h \
+  arch/arm/include/asm/percpu.h \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/percpu.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+    $(wildcard include/config/amd/mem/encrypt.h) \
+  arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arm/heavy/mb.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+    $(wildcard include/config/cpu/spectre.h) \
+  include/asm-generic/barrier.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/builtin-__fls.h \
+  include/asm-generic/bitops/builtin-__ffs.h \
+  include/asm-generic/bitops/builtin-fls.h \
+  include/asm-generic/bitops/builtin-ffs.h \
+  include/asm-generic/bitops/ffz.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/atomic.h \
+  arch/arm/include/asm/atomic.h \
+    $(wildcard include/config/generic/atomic64.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/linux/prefetch.h \
+  arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/binfmt/elf/fdpic.h) \
+  arch/arm/include/asm/hw_breakpoint.h \
+  arch/arm/include/asm/unified.h \
+  arch/arm/include/asm/vdso/processor.h \
+    $(wildcard include/config/arm/errata/754327.h) \
+  arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/atomic-fallback.h \
+  include/asm-generic/atomic-long.h \
+  include/asm-generic/bitops/find.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+  include/asm-generic/bitops/le.h \
+  arch/arm/include/uapi/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/uapi/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  include/uapi/linux/swab.h \
+  arch/arm/include/asm/swab.h \
+  arch/arm/include/uapi/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/minmax.h \
+  include/linux/printk.h \
+    $(wildcard include/config/message/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/quiet.h) \
+    $(wildcard include/config/early/printk.h) \
+    $(wildcard include/config/printk/nmi.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/dynamic/debug/core.h) \
+  include/linux/init.h \
+    $(wildcard include/config/strict/kernel/rwx.h) \
+    $(wildcard include/config/strict/module/rwx.h) \
+  include/linux/kern_levels.h \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/uapi/linux/kernel.h \
+  include/uapi/linux/sysinfo.h \
+  include/linux/ratelimit_types.h \
+  include/uapi/linux/param.h \
+  arch/arm/include/generated/uapi/asm/param.h \
+  include/asm-generic/param.h \
+    $(wildcard include/config/hz.h) \
+  include/uapi/asm-generic/param.h \
+  include/linux/spinlock_types.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep_types.h \
+    $(wildcard include/config/prove/raw/lock/nesting.h) \
+    $(wildcard include/config/preempt/lock.h) \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+  include/linux/rwlock_types.h \
+  arch/arm/include/asm/div64.h \
+  arch/arm/include/asm/compiler.h \
+  include/asm-generic/div64.h \
+  include/linux/stat.h \
+  arch/arm/include/uapi/asm/stat.h \
+  include/uapi/linux/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+    $(wildcard include/config/posix/timers.h) \
+  include/linux/math64.h \
+    $(wildcard include/config/arch/supports/int128.h) \
+  include/vdso/math64.h \
+  include/linux/time64.h \
+  include/vdso/time64.h \
+  include/uapi/linux/time.h \
+  include/uapi/linux/time_types.h \
+  include/linux/time32.h \
+  include/linux/timex.h \
+  include/uapi/linux/timex.h \
+  arch/arm/include/asm/timex.h \
+  include/vdso/time32.h \
+  include/vdso/time.h \
+  include/linux/uidgid.h \
+    $(wildcard include/config/multiuser.h) \
+    $(wildcard include/config/user/ns.h) \
+  include/linux/highuid.h \
+  include/linux/kmod.h \
+  include/linux/umh.h \
+  include/linux/gfp.h \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/zone/device.h) \
+    $(wildcard include/config/numa.h) \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/contig/alloc.h) \
+    $(wildcard include/config/cma.h) \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/virtual.h) \
+    $(wildcard include/config/debug/vm/pgflags.h) \
+  include/linux/bug.h \
+    $(wildcard include/config/bug/on/data/corruption.h) \
+  arch/arm/include/asm/bug.h \
+    $(wildcard include/config/debug/bugverbose.h) \
+  arch/arm/include/asm/opcodes.h \
+    $(wildcard include/config/cpu/endian/be32.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  include/linux/instrumentation.h \
+    $(wildcard include/config/debug/entry.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/isolation.h) \
+    $(wildcard include/config/zsmalloc.h) \
+    $(wildcard include/config/shadow/call/stack.h) \
+    $(wildcard include/config/memcg.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/sparsemem.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/transparent/hugepage.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/page/extension.h) \
+    $(wildcard include/config/deferred/struct/page/init.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/spinlock.h \
+    $(wildcard include/config/preemption.h) \
+  include/linux/preempt.h \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/trace/preempt/toggle.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  arch/arm/include/generated/asm/preempt.h \
+  include/asm-generic/preempt.h \
+  include/linux/thread_info.h \
+    $(wildcard include/config/thread/info/in/task.h) \
+    $(wildcard include/config/have/arch/within/stack/frames.h) \
+    $(wildcard include/config/hardened/usercopy.h) \
+  include/linux/restart_block.h \
+  include/linux/errno.h \
+  include/uapi/linux/errno.h \
+  arch/arm/include/generated/uapi/asm/errno.h \
+  include/uapi/asm-generic/errno.h \
+  include/uapi/asm-generic/errno-base.h \
+  arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/stackprotector/per/task.h) \
+    $(wildcard include/config/crunch.h) \
+    $(wildcard include/config/arm/thumbee.h) \
+  arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+    $(wildcard include/config/kuser/helpers.h) \
+  arch/arm/include/asm/glue.h \
+  arch/arm/include/asm/pgtable-2level-types.h \
+  arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/xip/kernel.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+    $(wildcard include/config/xip/phys/addr.h) \
+  include/linux/sizes.h \
+  include/asm-generic/memory_model.h \
+  include/linux/pfn.h \
+  include/asm-generic/getorder.h \
+  include/linux/bottom_half.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/debug/locking/api/selftests.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/up/late/init.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+    $(wildcard include/config/fortify/source.h) \
+  include/uapi/linux/string.h \
+  arch/arm/include/asm/string.h \
+    $(wildcard include/config/bcm2835/fast/memcpy.h) \
+  include/linux/smp_types.h \
+  include/linux/llist.h \
+    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
+  arch/arm/include/asm/smp.h \
+  arch/arm/include/generated/asm/mmiowb.h \
+  include/asm-generic/mmiowb.h \
+    $(wildcard include/config/mmiowb.h) \
+  arch/arm/include/asm/spinlock.h \
+  include/linux/rwlock.h \
+    $(wildcard include/config/preempt.h) \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  include/linux/wait.h \
+  arch/arm/include/generated/asm/current.h \
+  include/asm-generic/current.h \
+  include/uapi/linux/wait.h \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+    $(wildcard include/config/numa/keep/meminfo.h) \
+  include/linux/seqlock.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/mutex/spin/on/owner.h) \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/osq_lock.h \
+  include/linux/debug_locks.h \
+  include/linux/ww_mutex.h \
+    $(wildcard include/config/debug/ww/mutex/slowpath.h) \
+  include/linux/nodemask.h \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/page-flags-layout.h \
+    $(wildcard include/config/numa/balancing.h) \
+    $(wildcard include/config/kasan/sw/tags.h) \
+  include/generated/bounds.h \
+  include/linux/mm_types.h \
+    $(wildcard include/config/have/aligned/struct/page.h) \
+    $(wildcard include/config/userfaultfd.h) \
+    $(wildcard include/config/swap.h) \
+    $(wildcard include/config/have/arch/compat/mmap/bases.h) \
+    $(wildcard include/config/membarrier.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+    $(wildcard include/config/arch/want/batched/unmap/tlb/flush.h) \
+    $(wildcard include/config/iommu/support.h) \
+  include/linux/mm_types_task.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/arch/enable/split/pmd/ptlock.h) \
+  include/linux/auxvec.h \
+  include/uapi/linux/auxvec.h \
+  arch/arm/include/asm/auxvec.h \
+  arch/arm/include/uapi/asm/auxvec.h \
+  include/linux/rbtree.h \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tasks/rcu/generic.h) \
+    $(wildcard include/config/rcu/stall/common.h) \
+    $(wildcard include/config/no/hz/full.h) \
+    $(wildcard include/config/rcu/nocb/cpu.h) \
+    $(wildcard include/config/tasks/rcu.h) \
+    $(wildcard include/config/tasks/trace/rcu.h) \
+    $(wildcard include/config/tasks/rude/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/prove/rcu.h) \
+    $(wildcard include/config/rcu/boost.h) \
+    $(wildcard include/config/arch/weak/release/acquire.h) \
+  include/linux/rcutree.h \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/spin/on/owner.h) \
+    $(wildcard include/config/debug/rwsems.h) \
+  include/linux/err.h \
+  include/linux/completion.h \
+  include/linux/swait.h \
+  include/linux/uprobes.h \
+    $(wildcard include/config/uprobes.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+    $(wildcard include/config/wq/watchdog.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/debug/objects/timers.h) \
+    $(wildcard include/config/no/hz/common.h) \
+  include/linux/ktime.h \
+  include/linux/jiffies.h \
+  include/vdso/jiffies.h \
+  include/generated/timeconst.h \
+  include/vdso/ktime.h \
+  include/linux/timekeeping.h \
+  include/linux/timekeeping32.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+    $(wildcard include/config/vdso.h) \
+  include/linux/page-flags.h \
+    $(wildcard include/config/arch/uses/pg/uncached.h) \
+    $(wildcard include/config/memory/failure.h) \
+    $(wildcard include/config/idle/page/tracking.h) \
+    $(wildcard include/config/thp/swap.h) \
+    $(wildcard include/config/ksm.h) \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/arch/has/add/pages.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/have/bootmem/info/node.h) \
+  include/linux/notifier.h \
+  include/linux/srcu.h \
+    $(wildcard include/config/tiny/srcu.h) \
+    $(wildcard include/config/srcu.h) \
+  include/linux/rcu_segcblist.h \
+  include/linux/srcutree.h \
+  include/linux/rcu_node_tree.h \
+    $(wildcard include/config/rcu/fanout.h) \
+    $(wildcard include/config/rcu/fanout/leaf.h) \
+  include/linux/topology.h \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+    $(wildcard include/config/sched/smt.h) \
+  include/linux/arch_topology.h \
+    $(wildcard include/config/generic/arch/topology.h) \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+  arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+    $(wildcard include/config/bl/switcher.h) \
+  include/asm-generic/topology.h \
+  include/linux/sysctl.h \
+    $(wildcard include/config/sysctl.h) \
+  include/uapi/linux/sysctl.h \
+  include/linux/elf.h \
+    $(wildcard include/config/arch/use/gnu/property.h) \
+    $(wildcard include/config/arch/have/elf/prot.h) \
+  arch/arm/include/asm/elf.h \
+  arch/arm/include/asm/vdso_datapage.h \
+  include/vdso/datapage.h \
+    $(wildcard include/config/arch/has/vdso/data.h) \
+  include/uapi/asm-generic/errno-base.h \
+  include/vdso/clocksource.h \
+    $(wildcard include/config/generic/gettimeofday.h) \
+  arch/arm/include/asm/vdso/clocksource.h \
+  include/vdso/processor.h \
+  arch/arm/include/asm/vdso/gettimeofday.h \
+    $(wildcard include/config/arm/arch/timer.h) \
+  arch/arm/include/asm/unistd.h \
+    $(wildcard include/config/oabi/compat.h) \
+  arch/arm/include/uapi/asm/unistd.h \
+  arch/arm/include/generated/uapi/asm/unistd-eabi.h \
+  arch/arm/include/generated/uapi/asm/unistd-common.h \
+  arch/arm/include/generated/asm/unistd-nr.h \
+  arch/arm/include/asm/vdso/cp15.h \
+    $(wildcard include/config/cpu/cp15.h) \
+  arch/arm/include/asm/user.h \
+  include/uapi/linux/elf.h \
+  include/uapi/linux/elf-em.h \
+  include/linux/kobject.h \
+    $(wildcard include/config/uevent/helper.h) \
+    $(wildcard include/config/debug/kobject/release.h) \
+  include/linux/sysfs.h \
+  include/linux/kernfs.h \
+    $(wildcard include/config/kernfs.h) \
+  include/linux/idr.h \
+  include/linux/radix-tree.h \
+  include/linux/xarray.h \
+    $(wildcard include/config/xarray/multi.h) \
+  include/linux/kconfig.h \
+  include/linux/local_lock.h \
+  include/linux/local_lock_internal.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/refcount.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/jump_label.h \
+    $(wildcard include/config/have/arch/jump/label/relative.h) \
+  arch/arm/include/asm/jump_label.h \
+  include/linux/rbtree_latch.h \
+  include/linux/error-injection.h \
+  include/asm-generic/error-injection.h \
+  include/linux/tracepoint-defs.h \
+  include/linux/static_key.h \
+  include/linux/static_call_types.h \
+    $(wildcard include/config/have/static/call.h) \
+  arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+    $(wildcard include/config/arm/module/plts.h) \
+  include/asm-generic/module.h \
+    $(wildcard include/config/have/mod/arch/specific.h) \
+    $(wildcard include/config/modules/use/elf/rel.h) \
+    $(wildcard include/config/modules/use/elf/rela.h) \
+  include/linux/build-salt.h \
+    $(wildcard include/config/build/salt.h) \
+  include/linux/elfnote.h \
+  include/linux/vermagic.h \
+  include/generated/utsrelease.h \
+  arch/arm/include/asm/vermagic.h \
+
+drivers/input/touchscreen/hxchipset/himax_mmi.mod.o: $(deps_drivers/input/touchscreen/hxchipset/himax_mmi.mod.o)
+
+$(deps_drivers/input/touchscreen/hxchipset/himax_mmi.mod.o):
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_mmi.o.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_mmi.o.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_mmi.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_mmi.o.cmd	2024-06-14 10:43:31.772186056 +0200
@@ -0,0 +1 @@
+cmd_drivers/input/touchscreen/hxchipset/himax_mmi.o := /mnt/buildramdisk/br-output/host/bin/arm-buildroot-linux-uclibcgnueabihf-ld -EL   -r -o drivers/input/touchscreen/hxchipset/himax_mmi.o drivers/input/touchscreen/hxchipset/himax_debug.o drivers/input/touchscreen/hxchipset/himax_self_test.o drivers/input/touchscreen/hxchipset/himax_ic_incell_core.o drivers/input/touchscreen/hxchipset/himax_ic_HX83193.o drivers/input/touchscreen/hxchipset/himax_common.o drivers/input/touchscreen/hxchipset/himax_platform.o
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_platform.o.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_platform.o.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_platform.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_platform.o.cmd	2024-06-14 10:43:31.775519389 +0200
@@ -0,0 +1,1209 @@
+cmd_drivers/input/touchscreen/hxchipset/himax_platform.o := /mnt/buildramdisk/br-output/host/bin/arm-buildroot-linux-uclibcgnueabihf-gcc -Wp,-MMD,drivers/input/touchscreen/hxchipset/.himax_platform.o.d -nostdinc -isystem /mnt/buildramdisk/br-output/host/lib/gcc/arm-buildroot-linux-uclibcgnueabihf/10.3.0/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -include ./include/linux/compiler_types.h -D__KERNEL__ -mlittle-endian -fmacro-prefix-map=./= -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=implicit-function-declaration -Werror=implicit-int -Werror=return-type -Wno-format-security -std=gnu89 -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mfpu=vfp -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-address-of-packed-member -O2 -fno-allow-store-data-races -Wframe-larger-than=1024 -fstack-protector-strong -Wimplicit-fallthrough -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -pg -Wdeclaration-after-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -Wno-zero-length-bounds -Wno-array-bounds -Wno-stringop-overflow -Wno-restrict -Wno-maybe-uninitialized -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init -Wno-packed-not-aligned -Wno-attribute-alias -DHX_CONFIG_FB -D__HIMAX_MOD__ -D__HIMAX_HX83193_MOD__ -D__HIMAX_MOD__  -DMODULE  -DKBUILD_BASENAME='"himax_platform"' -DKBUILD_MODNAME='"himax_mmi"' -c -o drivers/input/touchscreen/hxchipset/himax_platform.o drivers/input/touchscreen/hxchipset/himax_platform.c
+
+source_drivers/input/touchscreen/hxchipset/himax_platform.o := drivers/input/touchscreen/hxchipset/himax_platform.c
+
+deps_drivers/input/touchscreen/hxchipset/himax_platform.o := \
+    $(wildcard include/config/of.h) \
+  include/linux/kconfig.h \
+    $(wildcard include/config/cc/version/text.h) \
+    $(wildcard include/config/cpu/big/endian.h) \
+    $(wildcard include/config/booger.h) \
+    $(wildcard include/config/foo.h) \
+  include/linux/compiler_types.h \
+    $(wildcard include/config/have/arch/compiler/h.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/cc/has/asm/inline.h) \
+  include/linux/compiler_attributes.h \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arm64.h) \
+    $(wildcard include/config/retpoline.h) \
+    $(wildcard include/config/arch/use/builtin/bswap.h) \
+    $(wildcard include/config/kcov.h) \
+  drivers/input/touchscreen/hxchipset/himax_platform.h \
+    $(wildcard include/config/touchscreen/himax/debug.h) \
+  include/linux/delay.h \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/preempt/rt.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/panic/timeout.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  include/linux/limits.h \
+  include/uapi/linux/limits.h \
+  include/linux/types.h \
+    $(wildcard include/config/have/uid16.h) \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  include/uapi/linux/types.h \
+  arch/arm/include/uapi/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  include/uapi/asm-generic/int-ll64.h \
+  arch/arm/include/generated/uapi/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/uapi/asm-generic/bitsperlong.h \
+  include/uapi/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/uapi/linux/stddef.h \
+  include/linux/compiler_types.h \
+  arch/arm/include/uapi/asm/posix_types.h \
+  include/uapi/asm-generic/posix_types.h \
+  include/vdso/limits.h \
+  include/linux/linkage.h \
+    $(wildcard include/config/arch/use/sym/annotations.h) \
+  include/linux/stringify.h \
+  include/linux/export.h \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/module/rel/crcs.h) \
+    $(wildcard include/config/have/arch/prel32/relocations.h) \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/trim/unused/ksyms.h) \
+    $(wildcard include/config/unused/symbols.h) \
+  arch/arm/include/asm/linkage.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/stack/validation.h) \
+  arch/arm/include/generated/asm/rwonce.h \
+  include/asm-generic/rwonce.h \
+  include/linux/kasan-checks.h \
+    $(wildcard include/config/kasan.h) \
+  include/linux/kcsan-checks.h \
+    $(wildcard include/config/kcsan.h) \
+    $(wildcard include/config/kcsan/ignore/atomics.h) \
+  include/linux/bitops.h \
+  include/linux/bits.h \
+  include/linux/const.h \
+  include/vdso/const.h \
+  include/uapi/linux/const.h \
+  include/vdso/bits.h \
+  include/linux/build_bug.h \
+  arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  arch/arm/include/asm/irqflags.h \
+    $(wildcard include/config/cpu/v7m.h) \
+  arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/arm/thumb.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+  arch/arm/include/uapi/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+  arch/arm/include/asm/hwcap.h \
+  arch/arm/include/uapi/asm/hwcap.h \
+  include/asm-generic/irqflags.h \
+  arch/arm/include/asm/percpu.h \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/percpu.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+    $(wildcard include/config/amd/mem/encrypt.h) \
+  arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arm/heavy/mb.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+    $(wildcard include/config/cpu/spectre.h) \
+  include/asm-generic/barrier.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/builtin-__fls.h \
+  include/asm-generic/bitops/builtin-__ffs.h \
+  include/asm-generic/bitops/builtin-fls.h \
+  include/asm-generic/bitops/builtin-ffs.h \
+  include/asm-generic/bitops/ffz.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/atomic.h \
+  arch/arm/include/asm/atomic.h \
+    $(wildcard include/config/generic/atomic64.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/linux/prefetch.h \
+  arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/binfmt/elf/fdpic.h) \
+  arch/arm/include/asm/hw_breakpoint.h \
+  arch/arm/include/asm/unified.h \
+  arch/arm/include/asm/vdso/processor.h \
+    $(wildcard include/config/arm/errata/754327.h) \
+  arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/atomic-fallback.h \
+  include/asm-generic/atomic-long.h \
+  include/asm-generic/bitops/find.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+  include/asm-generic/bitops/le.h \
+  arch/arm/include/uapi/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/uapi/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  include/uapi/linux/swab.h \
+  arch/arm/include/asm/swab.h \
+  arch/arm/include/uapi/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/minmax.h \
+  include/linux/printk.h \
+    $(wildcard include/config/message/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/quiet.h) \
+    $(wildcard include/config/early/printk.h) \
+    $(wildcard include/config/printk/nmi.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/dynamic/debug/core.h) \
+  include/linux/init.h \
+    $(wildcard include/config/strict/kernel/rwx.h) \
+    $(wildcard include/config/strict/module/rwx.h) \
+  include/linux/kern_levels.h \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/uapi/linux/kernel.h \
+  include/uapi/linux/sysinfo.h \
+  include/linux/ratelimit_types.h \
+  include/uapi/linux/param.h \
+  arch/arm/include/generated/uapi/asm/param.h \
+  include/asm-generic/param.h \
+    $(wildcard include/config/hz.h) \
+  include/uapi/asm-generic/param.h \
+  include/linux/spinlock_types.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep_types.h \
+    $(wildcard include/config/prove/raw/lock/nesting.h) \
+    $(wildcard include/config/preempt/lock.h) \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+  include/linux/rwlock_types.h \
+  arch/arm/include/asm/div64.h \
+  arch/arm/include/asm/compiler.h \
+  include/asm-generic/div64.h \
+  arch/arm/include/asm/delay.h \
+  arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/xip/kernel.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+    $(wildcard include/config/xip/phys/addr.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  include/linux/pfn.h \
+  include/linux/fs.h \
+    $(wildcard include/config/read/only/thp/for/fs.h) \
+    $(wildcard include/config/fs/posix/acl.h) \
+    $(wildcard include/config/security.h) \
+    $(wildcard include/config/cgroup/writeback.h) \
+    $(wildcard include/config/ima.h) \
+    $(wildcard include/config/file/locking.h) \
+    $(wildcard include/config/fsnotify.h) \
+    $(wildcard include/config/fs/encryption.h) \
+    $(wildcard include/config/fs/verity.h) \
+    $(wildcard include/config/preemption.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/unicode.h) \
+    $(wildcard include/config/compat.h) \
+    $(wildcard include/config/quota.h) \
+    $(wildcard include/config/fs/dax.h) \
+    $(wildcard include/config/mandatory/file/locking.h) \
+    $(wildcard include/config/block.h) \
+    $(wildcard include/config/migration.h) \
+  include/linux/wait_bit.h \
+  include/linux/wait.h \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+    $(wildcard include/config/page/poisoning/zero.h) \
+  include/linux/spinlock.h \
+  include/linux/preempt.h \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/trace/preempt/toggle.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  arch/arm/include/generated/asm/preempt.h \
+  include/asm-generic/preempt.h \
+  include/linux/thread_info.h \
+    $(wildcard include/config/thread/info/in/task.h) \
+    $(wildcard include/config/have/arch/within/stack/frames.h) \
+    $(wildcard include/config/hardened/usercopy.h) \
+  include/linux/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/bug/on/data/corruption.h) \
+  arch/arm/include/asm/bug.h \
+    $(wildcard include/config/debug/bugverbose.h) \
+  arch/arm/include/asm/opcodes.h \
+    $(wildcard include/config/cpu/endian/be32.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  include/linux/instrumentation.h \
+    $(wildcard include/config/debug/entry.h) \
+  include/linux/restart_block.h \
+  include/linux/time64.h \
+  include/linux/math64.h \
+    $(wildcard include/config/arch/supports/int128.h) \
+  include/vdso/math64.h \
+  include/vdso/time64.h \
+  include/uapi/linux/time.h \
+  include/uapi/linux/time_types.h \
+  include/linux/errno.h \
+  include/uapi/linux/errno.h \
+  arch/arm/include/generated/uapi/asm/errno.h \
+  include/uapi/asm-generic/errno.h \
+  include/uapi/asm-generic/errno-base.h \
+  arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/stackprotector/per/task.h) \
+    $(wildcard include/config/crunch.h) \
+    $(wildcard include/config/arm/thumbee.h) \
+  arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+    $(wildcard include/config/kuser/helpers.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+  arch/arm/include/asm/glue.h \
+  arch/arm/include/asm/pgtable-2level-types.h \
+  include/asm-generic/getorder.h \
+  include/linux/bottom_half.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/debug/locking/api/selftests.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/up/late/init.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+    $(wildcard include/config/fortify/source.h) \
+  include/uapi/linux/string.h \
+  arch/arm/include/asm/string.h \
+    $(wildcard include/config/bcm2835/fast/memcpy.h) \
+  include/linux/smp_types.h \
+  include/linux/llist.h \
+    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
+  arch/arm/include/asm/smp.h \
+  arch/arm/include/generated/asm/mmiowb.h \
+  include/asm-generic/mmiowb.h \
+    $(wildcard include/config/mmiowb.h) \
+  arch/arm/include/asm/spinlock.h \
+  include/linux/rwlock.h \
+    $(wildcard include/config/preempt.h) \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  arch/arm/include/generated/asm/current.h \
+  include/asm-generic/current.h \
+  include/uapi/linux/wait.h \
+  include/linux/kdev_t.h \
+  include/uapi/linux/kdev_t.h \
+  include/linux/dcache.h \
+  include/linux/rculist.h \
+    $(wildcard include/config/prove/rcu/list.h) \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tasks/rcu/generic.h) \
+    $(wildcard include/config/rcu/stall/common.h) \
+    $(wildcard include/config/no/hz/full.h) \
+    $(wildcard include/config/rcu/nocb/cpu.h) \
+    $(wildcard include/config/tasks/rcu.h) \
+    $(wildcard include/config/tasks/trace/rcu.h) \
+    $(wildcard include/config/tasks/rude/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/prove/rcu.h) \
+    $(wildcard include/config/rcu/boost.h) \
+    $(wildcard include/config/arch/weak/release/acquire.h) \
+  include/linux/rcutree.h \
+  include/linux/rculist_bl.h \
+  include/linux/list_bl.h \
+  include/linux/bit_spinlock.h \
+  include/linux/seqlock.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/mutex/spin/on/owner.h) \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/osq_lock.h \
+  include/linux/debug_locks.h \
+  include/linux/ww_mutex.h \
+    $(wildcard include/config/debug/ww/mutex/slowpath.h) \
+  include/linux/lockref.h \
+    $(wildcard include/config/arch/use/cmpxchg/lockref.h) \
+  include/generated/bounds.h \
+  include/linux/stringhash.h \
+    $(wildcard include/config/dcache/word/access.h) \
+  include/linux/hash.h \
+    $(wildcard include/config/have/arch/hash.h) \
+  include/linux/path.h \
+  include/linux/stat.h \
+  arch/arm/include/uapi/asm/stat.h \
+  include/uapi/linux/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+    $(wildcard include/config/posix/timers.h) \
+  include/linux/time32.h \
+  include/linux/timex.h \
+  include/uapi/linux/timex.h \
+  arch/arm/include/asm/timex.h \
+  include/vdso/time32.h \
+  include/vdso/time.h \
+  include/linux/uidgid.h \
+    $(wildcard include/config/multiuser.h) \
+    $(wildcard include/config/user/ns.h) \
+  include/linux/highuid.h \
+  include/linux/list_lru.h \
+    $(wildcard include/config/memcg/kmem.h) \
+  include/linux/nodemask.h \
+    $(wildcard include/config/numa.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+    $(wildcard include/config/numa/keep/meminfo.h) \
+  include/linux/shrinker.h \
+    $(wildcard include/config/memcg.h) \
+  include/linux/radix-tree.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/vm/pgflags.h) \
+  include/linux/xarray.h \
+    $(wildcard include/config/xarray/multi.h) \
+  include/linux/gfp.h \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/zone/device.h) \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/contig/alloc.h) \
+    $(wildcard include/config/cma.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/isolation.h) \
+    $(wildcard include/config/zsmalloc.h) \
+    $(wildcard include/config/shadow/call/stack.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/transparent/hugepage.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/page/extension.h) \
+    $(wildcard include/config/deferred/struct/page/init.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/page-flags-layout.h \
+    $(wildcard include/config/numa/balancing.h) \
+    $(wildcard include/config/kasan/sw/tags.h) \
+  include/linux/mm_types.h \
+    $(wildcard include/config/have/aligned/struct/page.h) \
+    $(wildcard include/config/userfaultfd.h) \
+    $(wildcard include/config/swap.h) \
+    $(wildcard include/config/have/arch/compat/mmap/bases.h) \
+    $(wildcard include/config/membarrier.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+    $(wildcard include/config/arch/want/batched/unmap/tlb/flush.h) \
+    $(wildcard include/config/iommu/support.h) \
+  include/linux/mm_types_task.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/arch/enable/split/pmd/ptlock.h) \
+  include/linux/auxvec.h \
+  include/uapi/linux/auxvec.h \
+  arch/arm/include/asm/auxvec.h \
+  arch/arm/include/uapi/asm/auxvec.h \
+  include/linux/rbtree.h \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/spin/on/owner.h) \
+    $(wildcard include/config/debug/rwsems.h) \
+  include/linux/err.h \
+  include/linux/completion.h \
+  include/linux/swait.h \
+  include/linux/uprobes.h \
+    $(wildcard include/config/uprobes.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+    $(wildcard include/config/sysfs.h) \
+    $(wildcard include/config/wq/watchdog.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/debug/objects/timers.h) \
+    $(wildcard include/config/no/hz/common.h) \
+  include/linux/ktime.h \
+  include/linux/jiffies.h \
+  include/vdso/jiffies.h \
+  include/generated/timeconst.h \
+  include/vdso/ktime.h \
+  include/linux/timekeeping.h \
+  include/linux/timekeeping32.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+    $(wildcard include/config/vdso.h) \
+  include/linux/page-flags.h \
+    $(wildcard include/config/arch/uses/pg/uncached.h) \
+    $(wildcard include/config/memory/failure.h) \
+    $(wildcard include/config/idle/page/tracking.h) \
+    $(wildcard include/config/thp/swap.h) \
+    $(wildcard include/config/ksm.h) \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/arch/has/add/pages.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/have/bootmem/info/node.h) \
+  include/linux/notifier.h \
+    $(wildcard include/config/tree/srcu.h) \
+  include/linux/srcu.h \
+    $(wildcard include/config/tiny/srcu.h) \
+    $(wildcard include/config/srcu.h) \
+  include/linux/rcu_segcblist.h \
+  include/linux/srcutree.h \
+  include/linux/rcu_node_tree.h \
+    $(wildcard include/config/rcu/fanout.h) \
+    $(wildcard include/config/rcu/fanout/leaf.h) \
+  include/linux/topology.h \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+    $(wildcard include/config/sched/smt.h) \
+  include/linux/arch_topology.h \
+    $(wildcard include/config/generic/arch/topology.h) \
+  arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+    $(wildcard include/config/bl/switcher.h) \
+  include/asm-generic/topology.h \
+  include/linux/kconfig.h \
+  include/linux/local_lock.h \
+  include/linux/local_lock_internal.h \
+  include/linux/pid.h \
+  include/linux/refcount.h \
+  include/linux/capability.h \
+  include/uapi/linux/capability.h \
+  include/linux/semaphore.h \
+  include/linux/fcntl.h \
+    $(wildcard include/config/arch/32bit/off/t.h) \
+  include/uapi/linux/fcntl.h \
+  arch/arm/include/uapi/asm/fcntl.h \
+  include/uapi/asm-generic/fcntl.h \
+  include/uapi/linux/openat2.h \
+  include/linux/migrate_mode.h \
+  include/linux/percpu-rwsem.h \
+  include/linux/rcuwait.h \
+  include/linux/sched/signal.h \
+    $(wildcard include/config/sched/autogroup.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/stack/growsup.h) \
+  include/linux/signal.h \
+    $(wildcard include/config/proc/fs.h) \
+  include/linux/signal_types.h \
+    $(wildcard include/config/old/sigaction.h) \
+  include/uapi/linux/signal.h \
+  arch/arm/include/asm/signal.h \
+  arch/arm/include/uapi/asm/signal.h \
+  include/uapi/asm-generic/signal-defs.h \
+  arch/arm/include/uapi/asm/sigcontext.h \
+  arch/arm/include/generated/uapi/asm/siginfo.h \
+  include/uapi/asm-generic/siginfo.h \
+  include/linux/sched.h \
+    $(wildcard include/config/virt/cpu/accounting/native.h) \
+    $(wildcard include/config/sched/info.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/uclamp/task.h) \
+    $(wildcard include/config/uclamp/buckets/count.h) \
+    $(wildcard include/config/cgroup/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/psi.h) \
+    $(wildcard include/config/compat/brk.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/blk/cgroup.h) \
+    $(wildcard include/config/stackprotector.h) \
+    $(wildcard include/config/arch/has/scaled/cputime.h) \
+    $(wildcard include/config/virt/cpu/accounting/gen.h) \
+    $(wildcard include/config/posix/cputimers.h) \
+    $(wildcard include/config/posix/cpu/timers/task/work.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/io/uring.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/ubsan.h) \
+    $(wildcard include/config/ubsan/trap.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/x86/cpu/resctrl.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/rseq.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/kunit.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/bcache.h) \
+    $(wildcard include/config/vmap/stack.h) \
+    $(wildcard include/config/livepatch.h) \
+    $(wildcard include/config/gcc/plugin/stackleak.h) \
+    $(wildcard include/config/x86/mce.h) \
+    $(wildcard include/config/arch/task/struct/on/stack.h) \
+    $(wildcard include/config/debug/rseq.h) \
+  include/uapi/linux/sched.h \
+  include/linux/sem.h \
+  include/uapi/linux/sem.h \
+  include/linux/ipc.h \
+  include/linux/rhashtable-types.h \
+  include/uapi/linux/ipc.h \
+  arch/arm/include/generated/uapi/asm/ipcbuf.h \
+  include/uapi/asm-generic/ipcbuf.h \
+  arch/arm/include/generated/uapi/asm/sembuf.h \
+  include/uapi/asm-generic/sembuf.h \
+  include/linux/shm.h \
+  include/uapi/linux/shm.h \
+  include/uapi/asm-generic/hugetlb_encode.h \
+  arch/arm/include/generated/uapi/asm/shmbuf.h \
+  include/uapi/asm-generic/shmbuf.h \
+  arch/arm/include/asm/shmparam.h \
+  include/linux/kcov.h \
+  include/uapi/linux/kcov.h \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/plist.h) \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+    $(wildcard include/config/time/low/res.h) \
+    $(wildcard include/config/timerfd.h) \
+  include/linux/hrtimer_defs.h \
+  include/linux/timerqueue.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+    $(wildcard include/config/have/arch/seccomp/filter.h) \
+    $(wildcard include/config/seccomp/filter.h) \
+    $(wildcard include/config/checkpoint/restore.h) \
+  include/uapi/linux/seccomp.h \
+  arch/arm/include/generated/asm/seccomp.h \
+  include/asm-generic/seccomp.h \
+  include/uapi/linux/unistd.h \
+  arch/arm/include/asm/unistd.h \
+    $(wildcard include/config/oabi/compat.h) \
+  arch/arm/include/uapi/asm/unistd.h \
+  arch/arm/include/generated/uapi/asm/unistd-eabi.h \
+  arch/arm/include/generated/uapi/asm/unistd-common.h \
+  arch/arm/include/generated/asm/unistd-nr.h \
+  include/linux/resource.h \
+  include/uapi/linux/resource.h \
+  arch/arm/include/generated/uapi/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/uapi/asm-generic/resource.h \
+  include/linux/latencytop.h \
+  include/linux/sched/prio.h \
+  include/linux/sched/types.h \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/posix-timers.h \
+  include/linux/alarmtimer.h \
+    $(wildcard include/config/rtc/class.h) \
+  include/linux/task_work.h \
+  include/uapi/linux/rseq.h \
+  include/linux/kcsan.h \
+  include/linux/sched/jobctl.h \
+  include/linux/sched/task.h \
+    $(wildcard include/config/have/exit/thread.h) \
+    $(wildcard include/config/arch/wants/dynamic/task/struct.h) \
+    $(wildcard include/config/have/arch/thread/struct/whitelist.h) \
+  include/linux/uaccess.h \
+    $(wildcard include/config/set/fs.h) \
+  include/linux/fault-inject-usercopy.h \
+    $(wildcard include/config/fault/injection/usercopy.h) \
+  include/linux/instrumented.h \
+  arch/arm/include/asm/uaccess.h \
+    $(wildcard include/config/cpu/sw/domain/pan.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+    $(wildcard include/config/uaccess/with/memcpy.h) \
+  arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/cp15/mmu.h) \
+  arch/arm/include/generated/asm/extable.h \
+  include/asm-generic/extable.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+  include/linux/key.h \
+    $(wildcard include/config/key/notifications.h) \
+    $(wildcard include/config/net.h) \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/uapi/linux/sysctl.h \
+  include/linux/assoc_array.h \
+    $(wildcard include/config/associative/array.h) \
+  include/linux/sched/user.h \
+    $(wildcard include/config/fanotify.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/bpf/syscall.h) \
+    $(wildcard include/config/watch/queue.h) \
+  include/linux/ratelimit.h \
+  include/linux/rcu_sync.h \
+  include/linux/delayed_call.h \
+  include/linux/uuid.h \
+  include/uapi/linux/uuid.h \
+  include/linux/errseq.h \
+  include/linux/ioprio.h \
+  include/linux/sched/rt.h \
+  include/linux/iocontext.h \
+  include/linux/fs_types.h \
+  include/uapi/linux/fs.h \
+  include/uapi/linux/ioctl.h \
+  arch/arm/include/generated/uapi/asm/ioctl.h \
+  include/asm-generic/ioctl.h \
+  include/uapi/asm-generic/ioctl.h \
+  include/linux/quota.h \
+    $(wildcard include/config/quota/netlink/interface.h) \
+  include/linux/percpu_counter.h \
+  include/uapi/linux/dqblk_xfs.h \
+  include/linux/dqblk_v1.h \
+  include/linux/dqblk_v2.h \
+  include/linux/dqblk_qtree.h \
+  include/linux/projid.h \
+  include/uapi/linux/quota.h \
+  include/linux/nfs_fs_i.h \
+  include/linux/gpio.h \
+    $(wildcard include/config/gpiolib.h) \
+    $(wildcard include/config/arch/have/custom/gpio/h.h) \
+  arch/arm/include/asm/gpio.h \
+    $(wildcard include/config/arch/nr/gpio.h) \
+  include/asm-generic/gpio.h \
+  include/linux/gpio/driver.h \
+    $(wildcard include/config/irq/domain/hierarchy.h) \
+    $(wildcard include/config/gpio/generic.h) \
+    $(wildcard include/config/gpiolib/irqchip.h) \
+    $(wildcard include/config/of/gpio.h) \
+    $(wildcard include/config/pinctrl.h) \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/energy/model.h) \
+    $(wildcard include/config/generic/msi/irq/domain.h) \
+    $(wildcard include/config/generic/msi/irq.h) \
+    $(wildcard include/config/dma/ops.h) \
+    $(wildcard include/config/dma/declare/coherent.h) \
+    $(wildcard include/config/dma/cma.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/device.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu/all.h) \
+    $(wildcard include/config/dma/ops/bypass.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/dev_printk.h \
+  include/linux/energy_model.h \
+  include/linux/jump_label.h \
+    $(wildcard include/config/jump/label.h) \
+    $(wildcard include/config/have/arch/jump/label/relative.h) \
+  arch/arm/include/asm/jump_label.h \
+  include/linux/kobject.h \
+    $(wildcard include/config/uevent/helper.h) \
+    $(wildcard include/config/debug/kobject/release.h) \
+  include/linux/sysfs.h \
+  include/linux/kernfs.h \
+    $(wildcard include/config/kernfs.h) \
+  include/linux/idr.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/sched/cpufreq.h \
+    $(wildcard include/config/cpu/freq.h) \
+  include/linux/sched/topology.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/sched/idle.h \
+  include/linux/sched/sd_flags.h \
+  include/linux/ioport.h \
+    $(wildcard include/config/io/strict/devmem.h) \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/vt/console/sleep.h) \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  include/linux/overflow.h \
+  include/linux/device/bus.h \
+    $(wildcard include/config/acpi.h) \
+  include/linux/device/class.h \
+  include/linux/device/driver.h \
+  arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/arm/dma/use/iommu.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/irq.h \
+    $(wildcard include/config/generic/irq/effective/aff/mask.h) \
+    $(wildcard include/config/generic/irq/ipi.h) \
+    $(wildcard include/config/generic/irq/migration.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+    $(wildcard include/config/hardirqs/sw/resend.h) \
+    $(wildcard include/config/generic/irq/legacy/alloc/hwirq.h) \
+    $(wildcard include/config/generic/irq/legacy.h) \
+    $(wildcard include/config/generic/irq/multi/handler.h) \
+  include/linux/irqhandler.h \
+  include/linux/irqreturn.h \
+  include/linux/irqnr.h \
+  include/uapi/linux/irqnr.h \
+  include/linux/io.h \
+    $(wildcard include/config/have/arch/huge/vmap.h) \
+    $(wildcard include/config/has/ioport/map.h) \
+    $(wildcard include/config/pci.h) \
+  arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/asm-generic/io.h \
+    $(wildcard include/config/generic/iomap.h) \
+    $(wildcard include/config/generic/ioremap.h) \
+    $(wildcard include/config/virt/to/bus.h) \
+  include/linux/logic_pio.h \
+    $(wildcard include/config/indirect/pio.h) \
+  include/linux/fwnode.h \
+  include/linux/vmalloc.h \
+    $(wildcard include/config/kasan/vmalloc.h) \
+  arch/arm/include/asm/vmalloc.h \
+  include/linux/slab.h \
+    $(wildcard include/config/debug/slab.h) \
+    $(wildcard include/config/failslab.h) \
+    $(wildcard include/config/have/hardened/usercopy/allocator.h) \
+    $(wildcard include/config/slab.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+  include/linux/percpu-refcount.h \
+  include/linux/kasan.h \
+    $(wildcard include/config/kasan/generic.h) \
+    $(wildcard include/config/kasan/inline.h) \
+  arch/arm/include/asm/irq.h \
+    $(wildcard include/config/sparse/irq.h) \
+  arch/arm/include/generated/asm/irq_regs.h \
+  include/asm-generic/irq_regs.h \
+  include/linux/irqdesc.h \
+    $(wildcard include/config/generic/irq/debugfs.h) \
+    $(wildcard include/config/handle/domain/irq.h) \
+    $(wildcard include/config/irq/domain.h) \
+  arch/arm/include/asm/hw_irq.h \
+  include/linux/irqchip/chained_irq.h \
+  include/linux/irqdomain.h \
+  include/linux/of.h \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/promtree.h) \
+    $(wildcard include/config/of/kobj.h) \
+    $(wildcard include/config/of/numa.h) \
+    $(wildcard include/config/of/overlay.h) \
+  include/linux/mod_devicetable.h \
+  include/linux/property.h \
+  include/linux/pinctrl/pinctrl.h \
+    $(wildcard include/config/generic/pinconf.h) \
+  include/linux/seq_file.h \
+  include/linux/pinctrl/pinctrl-state.h \
+  include/linux/pinctrl/devinfo.h \
+  include/linux/pinctrl/consumer.h \
+  include/linux/pinctrl/pinconf-generic.h \
+  include/linux/pinctrl/machine.h \
+  include/linux/gpio/consumer.h \
+    $(wildcard include/config/gpio/sysfs.h) \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/slave.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+    $(wildcard include/config/i2c/mux.h) \
+  include/linux/acpi.h \
+    $(wildcard include/config/acpi/debugger.h) \
+    $(wildcard include/config/x86.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/acpi/processor/cstate.h) \
+    $(wildcard include/config/acpi/hotplug/cpu.h) \
+    $(wildcard include/config/acpi/hotplug/ioapic.h) \
+    $(wildcard include/config/x86/io/apic.h) \
+    $(wildcard include/config/acpi/wmi.h) \
+    $(wildcard include/config/acpi/numa.h) \
+    $(wildcard include/config/hibernation.h) \
+    $(wildcard include/config/acpi/hotplug/memory.h) \
+    $(wildcard include/config/acpi/container.h) \
+    $(wildcard include/config/acpi/gtdt.h) \
+    $(wildcard include/config/acpi/table/upgrade.h) \
+    $(wildcard include/config/acpi/watchdog.h) \
+    $(wildcard include/config/acpi/spcr/table.h) \
+    $(wildcard include/config/acpi/generic/gsi.h) \
+    $(wildcard include/config/acpi/lpit.h) \
+    $(wildcard include/config/acpi/pptt.h) \
+  include/linux/resource_ext.h \
+  include/acpi/acpi.h \
+  include/acpi/platform/acenv.h \
+  include/acpi/platform/acgcc.h \
+  include/acpi/platform/aclinux.h \
+    $(wildcard include/config/acpi/reduced/hardware/only.h) \
+    $(wildcard include/config/acpi/debug.h) \
+  include/linux/ctype.h \
+  include/acpi/acnames.h \
+  include/acpi/actypes.h \
+  include/acpi/acexcep.h \
+  include/acpi/actbl.h \
+  include/acpi/actbl1.h \
+  include/acpi/actbl2.h \
+  include/acpi/actbl3.h \
+  include/acpi/acrestyp.h \
+  include/acpi/platform/acenvex.h \
+  include/acpi/platform/aclinuxex.h \
+  include/acpi/platform/acgccex.h \
+  include/acpi/acoutput.h \
+  include/acpi/acpiosxf.h \
+  include/acpi/acpixf.h \
+  include/acpi/acconfig.h \
+  include/acpi/acbuffer.h \
+  include/acpi/acpi_numa.h \
+    $(wildcard include/config/acpi/hmat.h) \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/uapi/linux/i2c.h \
+  include/linux/interrupt.h \
+    $(wildcard include/config/irq/forced/threading.h) \
+    $(wildcard include/config/generic/irq/probe.h) \
+    $(wildcard include/config/irq/timings.h) \
+  include/linux/hardirq.h \
+  include/linux/context_tracking_state.h \
+    $(wildcard include/config/context/tracking.h) \
+  include/linux/static_key.h \
+  include/linux/ftrace_irq.h \
+    $(wildcard include/config/hwlat/tracer.h) \
+  include/linux/vtime.h \
+    $(wildcard include/config/virt/cpu/accounting.h) \
+    $(wildcard include/config/irq/time/accounting.h) \
+  arch/arm/include/asm/hardirq.h \
+  include/linux/irq_cpustat.h \
+  arch/arm/include/asm/sections.h \
+  include/asm-generic/sections.h \
+  drivers/input/touchscreen/hxchipset/himax_common.h \
+    $(wildcard include/config/touchscreen/himax/ic/hx83192.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83193.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83194.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83195.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83180.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83181.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx8530.h) \
+    $(wildcard include/config/touchscreen/himax/self/test.h) \
+  include/linux/input.h \
+  include/uapi/linux/input.h \
+  include/uapi/linux/input-event-codes.h \
+  include/linux/module.h \
+    $(wildcard include/config/modules/tree/lookup.h) \
+    $(wildcard include/config/module/sig.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/bpf/events.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/kprobes.h) \
+    $(wildcard include/config/have/static/call/inline.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/function/error/injection.h) \
+  include/linux/kmod.h \
+  include/linux/umh.h \
+  include/linux/elf.h \
+    $(wildcard include/config/arch/use/gnu/property.h) \
+    $(wildcard include/config/arch/have/elf/prot.h) \
+  arch/arm/include/asm/elf.h \
+  arch/arm/include/asm/vdso_datapage.h \
+  include/vdso/datapage.h \
+    $(wildcard include/config/arch/has/vdso/data.h) \
+  include/uapi/asm-generic/errno-base.h \
+  include/vdso/clocksource.h \
+    $(wildcard include/config/generic/gettimeofday.h) \
+  arch/arm/include/asm/vdso/clocksource.h \
+  include/vdso/processor.h \
+  arch/arm/include/asm/vdso/gettimeofday.h \
+    $(wildcard include/config/arm/arch/timer.h) \
+  arch/arm/include/asm/vdso/cp15.h \
+    $(wildcard include/config/cpu/cp15.h) \
+  arch/arm/include/asm/user.h \
+  include/uapi/linux/elf.h \
+  include/uapi/linux/elf-em.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/rbtree_latch.h \
+  include/linux/error-injection.h \
+  include/asm-generic/error-injection.h \
+  include/linux/tracepoint-defs.h \
+  include/linux/static_call_types.h \
+    $(wildcard include/config/have/static/call.h) \
+  arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+    $(wildcard include/config/arm/module/plts.h) \
+  include/asm-generic/module.h \
+    $(wildcard include/config/have/mod/arch/specific.h) \
+    $(wildcard include/config/modules/use/elf/rel.h) \
+    $(wildcard include/config/modules/use/elf/rela.h) \
+  include/linux/async.h \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+    $(wildcard include/config/superh.h) \
+  include/linux/input/mt.h \
+  include/linux/firmware.h \
+    $(wildcard include/config/fw/loader.h) \
+  include/linux/buffer_head.h \
+  include/linux/pagemap.h \
+  include/linux/mm.h \
+    $(wildcard include/config/have/arch/mmap/rnd/bits.h) \
+    $(wildcard include/config/have/arch/mmap/rnd/compat/bits.h) \
+    $(wildcard include/config/mem/soft/dirty.h) \
+    $(wildcard include/config/arch/uses/high/vma/flags.h) \
+    $(wildcard include/config/arch/has/pkeys.h) \
+    $(wildcard include/config/ppc.h) \
+    $(wildcard include/config/parisc.h) \
+    $(wildcard include/config/sparc64.h) \
+    $(wildcard include/config/arm64/mte.h) \
+    $(wildcard include/config/shmem.h) \
+    $(wildcard include/config/dev/pagemap/ops.h) \
+    $(wildcard include/config/device/private.h) \
+    $(wildcard include/config/pci/p2pdma.h) \
+    $(wildcard include/config/arch/has/pte/special.h) \
+    $(wildcard include/config/arch/has/pte/devmap.h) \
+    $(wildcard include/config/debug/vm/rb.h) \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/init/on/alloc/default/on.h) \
+    $(wildcard include/config/init/on/free/default/on.h) \
+    $(wildcard include/config/debug/pagealloc.h) \
+    $(wildcard include/config/arch/has/set/direct/map.h) \
+    $(wildcard include/config/hugetlbfs.h) \
+    $(wildcard include/config/mapping/dirty/helpers.h) \
+  include/linux/mmap_lock.h \
+  include/linux/range.h \
+  include/linux/page_ext.h \
+  include/linux/stacktrace.h \
+    $(wildcard include/config/stacktrace.h) \
+    $(wildcard include/config/arch/stackwalk.h) \
+    $(wildcard include/config/have/reliable/stacktrace.h) \
+  include/linux/stackdepot.h \
+  include/linux/page_ref.h \
+    $(wildcard include/config/debug/page/ref.h) \
+  include/linux/memremap.h \
+  include/linux/pgtable.h \
+    $(wildcard include/config/pgtable/levels.h) \
+    $(wildcard include/config/highpte.h) \
+    $(wildcard include/config/have/arch/transparent/hugepage/pud.h) \
+    $(wildcard include/config/have/arch/soft/dirty.h) \
+    $(wildcard include/config/arch/enable/thp/migration.h) \
+    $(wildcard include/config/x86/espfix64.h) \
+  arch/arm/include/asm/pgtable.h \
+  arch/arm/include/asm/proc-fns.h \
+    $(wildcard include/config/big/little.h) \
+    $(wildcard include/config/harden/branch/predictor.h) \
+  arch/arm/include/asm/glue-proc.h \
+    $(wildcard include/config/cpu/arm7tdmi.h) \
+    $(wildcard include/config/cpu/arm720t.h) \
+    $(wildcard include/config/cpu/arm740t.h) \
+    $(wildcard include/config/cpu/arm9tdmi.h) \
+    $(wildcard include/config/cpu/arm920t.h) \
+    $(wildcard include/config/cpu/arm922t.h) \
+    $(wildcard include/config/cpu/arm925t.h) \
+    $(wildcard include/config/cpu/arm926t.h) \
+    $(wildcard include/config/cpu/arm940t.h) \
+    $(wildcard include/config/cpu/arm946e.h) \
+    $(wildcard include/config/cpu/arm1020.h) \
+    $(wildcard include/config/cpu/arm1020e.h) \
+    $(wildcard include/config/cpu/arm1022.h) \
+    $(wildcard include/config/cpu/arm1026.h) \
+    $(wildcard include/config/cpu/mohawk.h) \
+    $(wildcard include/config/cpu/feroceon.h) \
+    $(wildcard include/config/cpu/v6k.h) \
+    $(wildcard include/config/cpu/pj4b.h) \
+    $(wildcard include/config/cpu/v7.h) \
+  include/asm-generic/pgtable-nopud.h \
+  include/asm-generic/pgtable-nop4d.h \
+  arch/arm/include/asm/pgtable-hwdef.h \
+  arch/arm/include/asm/pgtable-2level-hwdef.h \
+  arch/arm/include/asm/tlbflush.h \
+    $(wildcard include/config/smp/on/up.h) \
+    $(wildcard include/config/cpu/tlb/v4wt.h) \
+    $(wildcard include/config/cpu/tlb/fa.h) \
+    $(wildcard include/config/cpu/tlb/v4wbi.h) \
+    $(wildcard include/config/cpu/tlb/feroceon.h) \
+    $(wildcard include/config/cpu/tlb/v4wb.h) \
+    $(wildcard include/config/cpu/tlb/v6.h) \
+    $(wildcard include/config/cpu/tlb/v7.h) \
+    $(wildcard include/config/arm/errata/720789.h) \
+    $(wildcard include/config/arm/errata/798181.h) \
+  arch/arm/include/asm/pgtable-2level.h \
+  include/asm-generic/pgtable_uffd.h \
+    $(wildcard include/config/have/arch/userfaultfd/wp.h) \
+  include/linux/huge_mm.h \
+  include/linux/sched/coredump.h \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+  include/linux/vmstat.h \
+    $(wildcard include/config/vm/event/counters.h) \
+    $(wildcard include/config/debug/tlbflush.h) \
+    $(wildcard include/config/debug/vm/vmacache.h) \
+  include/linux/vm_event_item.h \
+    $(wildcard include/config/memory/balloon.h) \
+    $(wildcard include/config/balloon/compaction.h) \
+  include/linux/highmem.h \
+    $(wildcard include/config/x86/32.h) \
+    $(wildcard include/config/debug/highmem.h) \
+  arch/arm/include/asm/cacheflush.h \
+    $(wildcard include/config/arm/errata/411920.h) \
+    $(wildcard include/config/cpu/cache/vipt.h) \
+    $(wildcard include/config/outer/cache.h) \
+    $(wildcard include/config/frame/pointer.h) \
+    $(wildcard include/config/cpu/icache/mismatch/workaround.h) \
+  arch/arm/include/asm/glue-cache.h \
+    $(wildcard include/config/cpu/cache/v4.h) \
+    $(wildcard include/config/cpu/cache/v4wb.h) \
+    $(wildcard include/config/cache/b15/rac.h) \
+  arch/arm/include/asm/cachetype.h \
+    $(wildcard include/config/cpu/cache/vivt.h) \
+  arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+  arch/arm/include/asm/kmap_types.h \
+  include/linux/hugetlb_inline.h \
+  include/linux/proc_fs.h \
+    $(wildcard include/config/proc/pid/arch/status.h) \
+  include/linux/kallsyms.h \
+    $(wildcard include/config/kallsyms/all.h) \
+  include/linux/of_gpio.h \
+  include/generated/uapi/linux/version.h \
+  include/linux/rtc.h \
+    $(wildcard include/config/rtc/intf/dev/uie/emul.h) \
+    $(wildcard include/config/rtc/hctosys/device.h) \
+    $(wildcard include/config/rtc/nvmem.h) \
+    $(wildcard include/config/rtc/intf/sysfs.h) \
+  include/linux/nvmem-provider.h \
+    $(wildcard include/config/nvmem.h) \
+  include/uapi/linux/rtc.h \
+  include/linux/cdev.h \
+  include/linux/poll.h \
+  include/uapi/linux/poll.h \
+  arch/arm/include/generated/uapi/asm/poll.h \
+  include/uapi/asm-generic/poll.h \
+  include/uapi/linux/eventpoll.h \
+  include/linux/fb.h \
+    $(wildcard include/config/gumstix/am200epd.h) \
+    $(wildcard include/config/fb/notify.h) \
+    $(wildcard include/config/fb/deferred/io.h) \
+    $(wildcard include/config/fb/tileblitting.h) \
+    $(wildcard include/config/fb/backlight.h) \
+    $(wildcard include/config/fb/foreign/endian.h) \
+    $(wildcard include/config/fb/both/endian.h) \
+    $(wildcard include/config/fb/big/endian.h) \
+    $(wildcard include/config/fb/little/endian.h) \
+  include/linux/kgdb.h \
+    $(wildcard include/config/have/arch/kgdb.h) \
+    $(wildcard include/config/kgdb.h) \
+    $(wildcard include/config/serial/kgdb/nmi.h) \
+    $(wildcard include/config/kgdb/honour/blocklist.h) \
+  include/linux/kprobes.h \
+    $(wildcard include/config/kretprobes.h) \
+    $(wildcard include/config/kprobes/sanity/test.h) \
+    $(wildcard include/config/optprobes.h) \
+    $(wildcard include/config/kprobes/on/ftrace.h) \
+  include/linux/ftrace.h \
+    $(wildcard include/config/function/tracer.h) \
+    $(wildcard include/config/dynamic/ftrace.h) \
+    $(wildcard include/config/dynamic/ftrace/with/regs.h) \
+    $(wildcard include/config/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/have/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/stack/tracer.h) \
+    $(wildcard include/config/function/profiler.h) \
+    $(wildcard include/config/ftrace/syscalls.h) \
+  include/linux/trace_clock.h \
+  arch/arm/include/generated/asm/trace_clock.h \
+  include/asm-generic/trace_clock.h \
+  include/linux/ptrace.h \
+  include/linux/pid_namespace.h \
+    $(wildcard include/config/pid/ns.h) \
+  include/linux/nsproxy.h \
+  include/linux/ns_common.h \
+  include/uapi/linux/ptrace.h \
+  arch/arm/include/asm/ftrace.h \
+  arch/arm/include/asm/kprobes.h \
+  include/asm-generic/kprobes.h \
+  arch/arm/include/asm/probes.h \
+  arch/arm/include/asm/kgdb.h \
+  include/uapi/linux/fb.h \
+  include/linux/backlight.h \
+    $(wildcard include/config/backlight/class/device.h) \
+
+drivers/input/touchscreen/hxchipset/himax_platform.o: $(deps_drivers/input/touchscreen/hxchipset/himax_platform.o)
+
+$(deps_drivers/input/touchscreen/hxchipset/himax_platform.o):
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_platform.o.d linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_platform.o.d
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_platform.o.d	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_platform.o.d	2024-06-14 10:43:31.775519389 +0200
@@ -0,0 +1,272 @@
+himax_platform.o: drivers/input/touchscreen/hxchipset/himax_platform.c \
+ include/linux/kconfig.h include/generated/autoconf.h \
+ include/linux/compiler_types.h include/linux/compiler_attributes.h \
+ include/linux/compiler-gcc.h \
+ drivers/input/touchscreen/hxchipset/himax_platform.h \
+ include/linux/delay.h include/linux/kernel.h include/linux/limits.h \
+ include/uapi/linux/limits.h include/linux/types.h \
+ include/uapi/linux/types.h arch/arm/include/uapi/asm/types.h \
+ include/asm-generic/int-ll64.h include/uapi/asm-generic/int-ll64.h \
+ arch/arm/include/generated/uapi/asm/bitsperlong.h \
+ include/asm-generic/bitsperlong.h include/uapi/asm-generic/bitsperlong.h \
+ include/uapi/linux/posix_types.h include/linux/stddef.h \
+ include/uapi/linux/stddef.h include/linux/compiler_types.h \
+ arch/arm/include/uapi/asm/posix_types.h \
+ include/uapi/asm-generic/posix_types.h include/vdso/limits.h \
+ include/linux/linkage.h include/linux/stringify.h include/linux/export.h \
+ arch/arm/include/asm/linkage.h include/linux/compiler.h \
+ arch/arm/include/generated/asm/rwonce.h include/asm-generic/rwonce.h \
+ include/linux/kasan-checks.h include/linux/kcsan-checks.h \
+ include/linux/bitops.h include/linux/bits.h include/linux/const.h \
+ include/vdso/const.h include/uapi/linux/const.h include/vdso/bits.h \
+ include/linux/build_bug.h arch/arm/include/asm/bitops.h \
+ include/linux/irqflags.h include/linux/typecheck.h \
+ arch/arm/include/asm/irqflags.h arch/arm/include/asm/ptrace.h \
+ arch/arm/include/uapi/asm/ptrace.h arch/arm/include/asm/hwcap.h \
+ arch/arm/include/uapi/asm/hwcap.h include/asm-generic/irqflags.h \
+ arch/arm/include/asm/percpu.h include/asm-generic/percpu.h \
+ include/linux/threads.h include/linux/percpu-defs.h \
+ arch/arm/include/asm/barrier.h include/asm-generic/barrier.h \
+ include/asm-generic/bitops/non-atomic.h \
+ include/asm-generic/bitops/builtin-__fls.h \
+ include/asm-generic/bitops/builtin-__ffs.h \
+ include/asm-generic/bitops/builtin-fls.h \
+ include/asm-generic/bitops/builtin-ffs.h \
+ include/asm-generic/bitops/ffz.h include/asm-generic/bitops/fls64.h \
+ include/asm-generic/bitops/sched.h include/asm-generic/bitops/hweight.h \
+ include/asm-generic/bitops/arch_hweight.h \
+ include/asm-generic/bitops/const_hweight.h \
+ include/asm-generic/bitops/lock.h include/linux/atomic.h \
+ arch/arm/include/asm/atomic.h include/linux/prefetch.h \
+ arch/arm/include/asm/processor.h arch/arm/include/asm/hw_breakpoint.h \
+ arch/arm/include/asm/unified.h arch/arm/include/asm/vdso/processor.h \
+ arch/arm/include/asm/cache.h arch/arm/include/asm/cmpxchg.h \
+ include/asm-generic/cmpxchg-local.h include/linux/atomic-fallback.h \
+ include/asm-generic/atomic-long.h include/asm-generic/bitops/find.h \
+ include/asm-generic/bitops/le.h arch/arm/include/uapi/asm/byteorder.h \
+ include/linux/byteorder/little_endian.h \
+ include/uapi/linux/byteorder/little_endian.h include/linux/swab.h \
+ include/uapi/linux/swab.h arch/arm/include/asm/swab.h \
+ arch/arm/include/uapi/asm/swab.h include/linux/byteorder/generic.h \
+ include/asm-generic/bitops/ext2-atomic-setbit.h include/linux/log2.h \
+ include/linux/minmax.h include/linux/printk.h include/linux/init.h \
+ include/linux/kern_levels.h include/linux/cache.h \
+ include/uapi/linux/kernel.h include/uapi/linux/sysinfo.h \
+ include/linux/ratelimit_types.h include/uapi/linux/param.h \
+ arch/arm/include/generated/uapi/asm/param.h include/asm-generic/param.h \
+ include/uapi/asm-generic/param.h include/linux/spinlock_types.h \
+ arch/arm/include/asm/spinlock_types.h include/linux/lockdep_types.h \
+ include/linux/rwlock_types.h arch/arm/include/asm/div64.h \
+ arch/arm/include/asm/compiler.h include/asm-generic/div64.h \
+ arch/arm/include/asm/delay.h arch/arm/include/asm/memory.h \
+ include/linux/sizes.h include/asm-generic/memory_model.h \
+ include/linux/pfn.h include/linux/fs.h include/linux/wait_bit.h \
+ include/linux/wait.h include/linux/list.h include/linux/poison.h \
+ include/linux/spinlock.h include/linux/preempt.h \
+ arch/arm/include/generated/asm/preempt.h include/asm-generic/preempt.h \
+ include/linux/thread_info.h include/linux/bug.h \
+ arch/arm/include/asm/bug.h arch/arm/include/asm/opcodes.h \
+ include/asm-generic/bug.h include/linux/instrumentation.h \
+ include/linux/restart_block.h include/linux/time64.h \
+ include/linux/math64.h include/vdso/math64.h include/vdso/time64.h \
+ include/uapi/linux/time.h include/uapi/linux/time_types.h \
+ include/linux/errno.h include/uapi/linux/errno.h \
+ arch/arm/include/generated/uapi/asm/errno.h \
+ include/uapi/asm-generic/errno.h include/uapi/asm-generic/errno-base.h \
+ arch/arm/include/asm/thread_info.h arch/arm/include/asm/fpstate.h \
+ arch/arm/include/asm/page.h arch/arm/include/asm/glue.h \
+ arch/arm/include/asm/pgtable-2level-types.h \
+ include/asm-generic/getorder.h include/linux/bottom_half.h \
+ include/linux/lockdep.h include/linux/smp.h include/linux/cpumask.h \
+ include/linux/bitmap.h include/linux/string.h \
+ include/uapi/linux/string.h arch/arm/include/asm/string.h \
+ include/linux/smp_types.h include/linux/llist.h \
+ arch/arm/include/asm/smp.h arch/arm/include/generated/asm/mmiowb.h \
+ include/asm-generic/mmiowb.h arch/arm/include/asm/spinlock.h \
+ include/linux/rwlock.h include/linux/spinlock_api_smp.h \
+ include/linux/rwlock_api_smp.h arch/arm/include/generated/asm/current.h \
+ include/asm-generic/current.h include/uapi/linux/wait.h \
+ include/linux/kdev_t.h include/uapi/linux/kdev_t.h \
+ include/linux/dcache.h include/linux/rculist.h include/linux/rcupdate.h \
+ include/linux/rcutree.h include/linux/rculist_bl.h \
+ include/linux/list_bl.h include/linux/bit_spinlock.h \
+ include/linux/seqlock.h include/linux/mutex.h include/linux/osq_lock.h \
+ include/linux/debug_locks.h include/linux/ww_mutex.h \
+ include/linux/lockref.h include/generated/bounds.h \
+ include/linux/stringhash.h include/linux/hash.h include/linux/path.h \
+ include/linux/stat.h arch/arm/include/uapi/asm/stat.h \
+ include/uapi/linux/stat.h include/linux/time.h include/linux/time32.h \
+ include/linux/timex.h include/uapi/linux/timex.h \
+ arch/arm/include/asm/timex.h include/vdso/time32.h include/vdso/time.h \
+ include/linux/uidgid.h include/linux/highuid.h include/linux/list_lru.h \
+ include/linux/nodemask.h include/linux/numa.h include/linux/shrinker.h \
+ include/linux/radix-tree.h include/linux/percpu.h \
+ include/linux/mmdebug.h include/linux/xarray.h include/linux/gfp.h \
+ include/linux/mmzone.h include/linux/pageblock-flags.h \
+ include/linux/page-flags-layout.h include/linux/mm_types.h \
+ include/linux/mm_types_task.h include/linux/auxvec.h \
+ include/uapi/linux/auxvec.h arch/arm/include/asm/auxvec.h \
+ arch/arm/include/uapi/asm/auxvec.h include/linux/rbtree.h \
+ include/linux/rwsem.h include/linux/err.h include/linux/completion.h \
+ include/linux/swait.h include/linux/uprobes.h include/linux/workqueue.h \
+ include/linux/timer.h include/linux/ktime.h include/linux/jiffies.h \
+ include/vdso/jiffies.h include/generated/timeconst.h \
+ include/vdso/ktime.h include/linux/timekeeping.h \
+ include/linux/timekeeping32.h include/linux/debugobjects.h \
+ arch/arm/include/asm/mmu.h include/linux/page-flags.h \
+ include/linux/memory_hotplug.h include/linux/notifier.h \
+ include/linux/srcu.h include/linux/rcu_segcblist.h \
+ include/linux/srcutree.h include/linux/rcu_node_tree.h \
+ include/linux/topology.h include/linux/arch_topology.h \
+ arch/arm/include/asm/topology.h include/asm-generic/topology.h \
+ include/linux/kconfig.h include/linux/local_lock.h \
+ include/linux/local_lock_internal.h include/linux/pid.h \
+ include/linux/refcount.h include/linux/capability.h \
+ include/uapi/linux/capability.h include/linux/semaphore.h \
+ include/linux/fcntl.h include/uapi/linux/fcntl.h \
+ arch/arm/include/uapi/asm/fcntl.h include/uapi/asm-generic/fcntl.h \
+ include/uapi/linux/openat2.h include/linux/migrate_mode.h \
+ include/linux/percpu-rwsem.h include/linux/rcuwait.h \
+ include/linux/sched/signal.h include/linux/signal.h \
+ include/linux/signal_types.h include/uapi/linux/signal.h \
+ arch/arm/include/asm/signal.h arch/arm/include/uapi/asm/signal.h \
+ include/uapi/asm-generic/signal-defs.h \
+ arch/arm/include/uapi/asm/sigcontext.h \
+ arch/arm/include/generated/uapi/asm/siginfo.h \
+ include/uapi/asm-generic/siginfo.h include/linux/sched.h \
+ include/uapi/linux/sched.h include/linux/sem.h include/uapi/linux/sem.h \
+ include/linux/ipc.h include/linux/rhashtable-types.h \
+ include/uapi/linux/ipc.h arch/arm/include/generated/uapi/asm/ipcbuf.h \
+ include/uapi/asm-generic/ipcbuf.h \
+ arch/arm/include/generated/uapi/asm/sembuf.h \
+ include/uapi/asm-generic/sembuf.h include/linux/shm.h \
+ include/uapi/linux/shm.h include/uapi/asm-generic/hugetlb_encode.h \
+ arch/arm/include/generated/uapi/asm/shmbuf.h \
+ include/uapi/asm-generic/shmbuf.h arch/arm/include/asm/shmparam.h \
+ include/linux/kcov.h include/uapi/linux/kcov.h include/linux/plist.h \
+ include/linux/hrtimer.h include/linux/hrtimer_defs.h \
+ include/linux/timerqueue.h include/linux/seccomp.h \
+ include/uapi/linux/seccomp.h arch/arm/include/generated/asm/seccomp.h \
+ include/asm-generic/seccomp.h include/uapi/linux/unistd.h \
+ arch/arm/include/asm/unistd.h arch/arm/include/uapi/asm/unistd.h \
+ arch/arm/include/generated/uapi/asm/unistd-eabi.h \
+ arch/arm/include/generated/uapi/asm/unistd-common.h \
+ arch/arm/include/generated/asm/unistd-nr.h include/linux/resource.h \
+ include/uapi/linux/resource.h \
+ arch/arm/include/generated/uapi/asm/resource.h \
+ include/asm-generic/resource.h include/uapi/asm-generic/resource.h \
+ include/linux/latencytop.h include/linux/sched/prio.h \
+ include/linux/sched/types.h include/linux/task_io_accounting.h \
+ include/linux/posix-timers.h include/linux/alarmtimer.h \
+ include/linux/task_work.h include/uapi/linux/rseq.h \
+ include/linux/kcsan.h include/linux/sched/jobctl.h \
+ include/linux/sched/task.h include/linux/uaccess.h \
+ include/linux/fault-inject-usercopy.h include/linux/instrumented.h \
+ arch/arm/include/asm/uaccess.h arch/arm/include/asm/domain.h \
+ arch/arm/include/generated/asm/extable.h include/asm-generic/extable.h \
+ include/linux/cred.h include/linux/key.h include/linux/sysctl.h \
+ include/uapi/linux/sysctl.h include/linux/assoc_array.h \
+ include/linux/sched/user.h include/linux/ratelimit.h \
+ include/linux/rcu_sync.h include/linux/delayed_call.h \
+ include/linux/uuid.h include/uapi/linux/uuid.h include/linux/errseq.h \
+ include/linux/ioprio.h include/linux/sched/rt.h \
+ include/linux/iocontext.h include/linux/fs_types.h \
+ include/uapi/linux/fs.h include/uapi/linux/ioctl.h \
+ arch/arm/include/generated/uapi/asm/ioctl.h include/asm-generic/ioctl.h \
+ include/uapi/asm-generic/ioctl.h include/linux/quota.h \
+ include/linux/percpu_counter.h include/uapi/linux/dqblk_xfs.h \
+ include/linux/dqblk_v1.h include/linux/dqblk_v2.h \
+ include/linux/dqblk_qtree.h include/linux/projid.h \
+ include/uapi/linux/quota.h include/linux/nfs_fs_i.h include/linux/gpio.h \
+ arch/arm/include/asm/gpio.h include/asm-generic/gpio.h \
+ include/linux/gpio/driver.h include/linux/device.h \
+ include/linux/dev_printk.h include/linux/energy_model.h \
+ include/linux/jump_label.h arch/arm/include/asm/jump_label.h \
+ include/linux/kobject.h include/linux/sysfs.h include/linux/kernfs.h \
+ include/linux/idr.h include/linux/kobject_ns.h include/linux/kref.h \
+ include/linux/sched/cpufreq.h include/linux/sched/topology.h \
+ include/linux/sched/idle.h include/linux/sched/sd_flags.h \
+ include/linux/ioport.h include/linux/klist.h include/linux/pm.h \
+ include/linux/overflow.h include/linux/device/bus.h \
+ include/linux/device/class.h include/linux/device/driver.h \
+ arch/arm/include/asm/device.h include/linux/pm_wakeup.h \
+ include/linux/irq.h include/linux/irqhandler.h include/linux/irqreturn.h \
+ include/linux/irqnr.h include/uapi/linux/irqnr.h include/linux/io.h \
+ arch/arm/include/asm/io.h include/asm-generic/pci_iomap.h \
+ include/asm-generic/io.h include/linux/logic_pio.h \
+ include/linux/fwnode.h include/linux/vmalloc.h \
+ arch/arm/include/asm/vmalloc.h include/linux/slab.h \
+ include/linux/percpu-refcount.h include/linux/kasan.h \
+ arch/arm/include/asm/irq.h arch/arm/include/generated/asm/irq_regs.h \
+ include/asm-generic/irq_regs.h include/linux/irqdesc.h \
+ arch/arm/include/asm/hw_irq.h include/linux/irqchip/chained_irq.h \
+ include/linux/irqdomain.h include/linux/of.h \
+ include/linux/mod_devicetable.h include/linux/property.h \
+ include/linux/pinctrl/pinctrl.h include/linux/seq_file.h \
+ include/linux/pinctrl/pinctrl-state.h include/linux/pinctrl/devinfo.h \
+ include/linux/pinctrl/consumer.h include/linux/pinctrl/pinconf-generic.h \
+ include/linux/pinctrl/machine.h include/linux/gpio/consumer.h \
+ include/linux/i2c.h include/linux/acpi.h include/linux/resource_ext.h \
+ include/acpi/acpi.h include/acpi/platform/acenv.h \
+ include/acpi/platform/acgcc.h include/acpi/platform/aclinux.h \
+ include/linux/ctype.h include/acpi/acnames.h include/acpi/actypes.h \
+ include/acpi/acexcep.h include/acpi/actbl.h include/acpi/actbl1.h \
+ include/acpi/actbl2.h include/acpi/actbl3.h include/acpi/acrestyp.h \
+ include/acpi/platform/acenvex.h include/acpi/platform/aclinuxex.h \
+ include/acpi/platform/acgccex.h include/acpi/acoutput.h \
+ include/acpi/acpiosxf.h include/acpi/acpixf.h include/acpi/acconfig.h \
+ include/acpi/acbuffer.h include/acpi/acpi_numa.h include/linux/rtmutex.h \
+ include/uapi/linux/i2c.h include/linux/interrupt.h \
+ include/linux/hardirq.h include/linux/context_tracking_state.h \
+ include/linux/static_key.h include/linux/ftrace_irq.h \
+ include/linux/vtime.h arch/arm/include/asm/hardirq.h \
+ include/linux/irq_cpustat.h arch/arm/include/asm/sections.h \
+ include/asm-generic/sections.h \
+ drivers/input/touchscreen/hxchipset/himax_common.h include/linux/input.h \
+ include/uapi/linux/input.h include/uapi/linux/input-event-codes.h \
+ include/linux/module.h include/linux/kmod.h include/linux/umh.h \
+ include/linux/elf.h arch/arm/include/asm/elf.h \
+ arch/arm/include/asm/vdso_datapage.h include/vdso/datapage.h \
+ include/uapi/asm-generic/errno-base.h include/vdso/clocksource.h \
+ arch/arm/include/asm/vdso/clocksource.h include/vdso/processor.h \
+ arch/arm/include/asm/vdso/gettimeofday.h \
+ arch/arm/include/asm/vdso/cp15.h arch/arm/include/asm/user.h \
+ include/uapi/linux/elf.h include/uapi/linux/elf-em.h \
+ include/linux/moduleparam.h include/linux/rbtree_latch.h \
+ include/linux/error-injection.h include/asm-generic/error-injection.h \
+ include/linux/tracepoint-defs.h include/linux/static_call_types.h \
+ arch/arm/include/asm/module.h include/asm-generic/module.h \
+ include/linux/async.h include/linux/platform_device.h \
+ include/linux/input/mt.h include/linux/firmware.h \
+ include/linux/buffer_head.h include/linux/pagemap.h include/linux/mm.h \
+ include/linux/mmap_lock.h include/linux/range.h include/linux/page_ext.h \
+ include/linux/stacktrace.h include/linux/stackdepot.h \
+ include/linux/page_ref.h include/linux/memremap.h \
+ include/linux/pgtable.h arch/arm/include/asm/pgtable.h \
+ arch/arm/include/asm/proc-fns.h arch/arm/include/asm/glue-proc.h \
+ include/asm-generic/pgtable-nopud.h include/asm-generic/pgtable-nop4d.h \
+ arch/arm/include/asm/pgtable-hwdef.h \
+ arch/arm/include/asm/pgtable-2level-hwdef.h \
+ arch/arm/include/asm/tlbflush.h arch/arm/include/asm/pgtable-2level.h \
+ include/asm-generic/pgtable_uffd.h include/linux/huge_mm.h \
+ include/linux/sched/coredump.h include/linux/vmstat.h \
+ include/linux/vm_event_item.h include/linux/highmem.h \
+ arch/arm/include/asm/cacheflush.h arch/arm/include/asm/glue-cache.h \
+ arch/arm/include/asm/cachetype.h arch/arm/include/asm/outercache.h \
+ arch/arm/include/asm/kmap_types.h include/linux/hugetlb_inline.h \
+ include/linux/proc_fs.h include/linux/kallsyms.h include/linux/of_gpio.h \
+ include/generated/uapi/linux/version.h include/linux/rtc.h \
+ include/linux/nvmem-provider.h include/uapi/linux/rtc.h \
+ include/linux/cdev.h include/linux/poll.h include/uapi/linux/poll.h \
+ arch/arm/include/generated/uapi/asm/poll.h \
+ include/uapi/asm-generic/poll.h include/uapi/linux/eventpoll.h \
+ include/linux/fb.h include/linux/kgdb.h include/linux/kprobes.h \
+ include/linux/ftrace.h include/linux/trace_clock.h \
+ arch/arm/include/generated/asm/trace_clock.h \
+ include/asm-generic/trace_clock.h include/linux/ptrace.h \
+ include/linux/pid_namespace.h include/linux/nsproxy.h \
+ include/linux/ns_common.h include/uapi/linux/ptrace.h \
+ arch/arm/include/asm/ftrace.h arch/arm/include/asm/kprobes.h \
+ include/asm-generic/kprobes.h arch/arm/include/asm/probes.h \
+ arch/arm/include/asm/kgdb.h include/uapi/linux/fb.h \
+ include/linux/backlight.h
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_self_test.o.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_self_test.o.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.himax_self_test.o.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.himax_self_test.o.cmd	2024-06-14 10:43:31.775519389 +0200
@@ -0,0 +1,1211 @@
+cmd_drivers/input/touchscreen/hxchipset/himax_self_test.o := /mnt/buildramdisk/br-output/host/bin/arm-buildroot-linux-uclibcgnueabihf-gcc -Wp,-MMD,drivers/input/touchscreen/hxchipset/.himax_self_test.o.d -nostdinc -isystem /mnt/buildramdisk/br-output/host/lib/gcc/arm-buildroot-linux-uclibcgnueabihf/10.3.0/include -I./arch/arm/include -I./arch/arm/include/generated  -I./include -I./arch/arm/include/uapi -I./arch/arm/include/generated/uapi -I./include/uapi -I./include/generated/uapi -include ./include/linux/kconfig.h -include ./include/linux/compiler_types.h -D__KERNEL__ -mlittle-endian -fmacro-prefix-map=./= -Wall -Wundef -Werror=strict-prototypes -Wno-trigraphs -fno-strict-aliasing -fno-common -fshort-wchar -fno-PIE -Werror=implicit-function-declaration -Werror=implicit-int -Werror=return-type -Wno-format-security -std=gnu89 -fno-dwarf2-cfi-asm -fno-omit-frame-pointer -mapcs -mno-sched-prolog -fno-ipa-sra -mabi=aapcs-linux -mfpu=vfp -marm -Wa,-mno-warn-deprecated -D__LINUX_ARM_ARCH__=7 -march=armv7-a -msoft-float -Uarm -fno-delete-null-pointer-checks -Wno-frame-address -Wno-format-truncation -Wno-format-overflow -Wno-address-of-packed-member -O2 -fno-allow-store-data-races -Wframe-larger-than=1024 -fstack-protector-strong -Wimplicit-fallthrough -Wno-unused-but-set-variable -Wno-unused-const-variable -fno-omit-frame-pointer -fno-optimize-sibling-calls -pg -Wdeclaration-after-statement -Wvla -Wno-pointer-sign -Wno-stringop-truncation -Wno-zero-length-bounds -Wno-array-bounds -Wno-stringop-overflow -Wno-restrict -Wno-maybe-uninitialized -fno-strict-overflow -fno-stack-check -fconserve-stack -Werror=date-time -Werror=incompatible-pointer-types -Werror=designated-init -Wno-packed-not-aligned -Wno-attribute-alias -DHX_CONFIG_FB -D__HIMAX_MOD__ -D__HIMAX_HX83193_MOD__ -D__HIMAX_MOD__  -DMODULE  -DKBUILD_BASENAME='"himax_self_test"' -DKBUILD_MODNAME='"himax_mmi"' -c -o drivers/input/touchscreen/hxchipset/himax_self_test.o drivers/input/touchscreen/hxchipset/himax_self_test.c
+
+source_drivers/input/touchscreen/hxchipset/himax_self_test.o := drivers/input/touchscreen/hxchipset/himax_self_test.c
+
+deps_drivers/input/touchscreen/hxchipset/himax_self_test.o := \
+    $(wildcard include/config/touchscreen/himax/ic/hx8530.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83194.h) \
+  include/linux/kconfig.h \
+    $(wildcard include/config/cc/version/text.h) \
+    $(wildcard include/config/cpu/big/endian.h) \
+    $(wildcard include/config/booger.h) \
+    $(wildcard include/config/foo.h) \
+  include/linux/compiler_types.h \
+    $(wildcard include/config/have/arch/compiler/h.h) \
+    $(wildcard include/config/enable/must/check.h) \
+    $(wildcard include/config/cc/has/asm/inline.h) \
+  include/linux/compiler_attributes.h \
+  include/linux/compiler-gcc.h \
+    $(wildcard include/config/arm64.h) \
+    $(wildcard include/config/retpoline.h) \
+    $(wildcard include/config/arch/use/builtin/bswap.h) \
+    $(wildcard include/config/kcov.h) \
+  drivers/input/touchscreen/hxchipset/himax_self_test.h \
+  drivers/input/touchscreen/hxchipset/himax_platform.h \
+    $(wildcard include/config/touchscreen/himax/debug.h) \
+  include/linux/delay.h \
+  include/linux/kernel.h \
+    $(wildcard include/config/preempt/voluntary.h) \
+    $(wildcard include/config/debug/atomic/sleep.h) \
+    $(wildcard include/config/preempt/rt.h) \
+    $(wildcard include/config/mmu.h) \
+    $(wildcard include/config/prove/locking.h) \
+    $(wildcard include/config/smp.h) \
+    $(wildcard include/config/panic/timeout.h) \
+    $(wildcard include/config/tracing.h) \
+    $(wildcard include/config/ftrace/mcount/record.h) \
+  include/linux/limits.h \
+  include/uapi/linux/limits.h \
+  include/linux/types.h \
+    $(wildcard include/config/have/uid16.h) \
+    $(wildcard include/config/uid16.h) \
+    $(wildcard include/config/arch/dma/addr/t/64bit.h) \
+    $(wildcard include/config/phys/addr/t/64bit.h) \
+    $(wildcard include/config/64bit.h) \
+  include/uapi/linux/types.h \
+  arch/arm/include/uapi/asm/types.h \
+  include/asm-generic/int-ll64.h \
+  include/uapi/asm-generic/int-ll64.h \
+  arch/arm/include/generated/uapi/asm/bitsperlong.h \
+  include/asm-generic/bitsperlong.h \
+  include/uapi/asm-generic/bitsperlong.h \
+  include/uapi/linux/posix_types.h \
+  include/linux/stddef.h \
+  include/uapi/linux/stddef.h \
+  include/linux/compiler_types.h \
+  arch/arm/include/uapi/asm/posix_types.h \
+  include/uapi/asm-generic/posix_types.h \
+  include/vdso/limits.h \
+  include/linux/linkage.h \
+    $(wildcard include/config/arch/use/sym/annotations.h) \
+  include/linux/stringify.h \
+  include/linux/export.h \
+    $(wildcard include/config/modversions.h) \
+    $(wildcard include/config/module/rel/crcs.h) \
+    $(wildcard include/config/have/arch/prel32/relocations.h) \
+    $(wildcard include/config/modules.h) \
+    $(wildcard include/config/trim/unused/ksyms.h) \
+    $(wildcard include/config/unused/symbols.h) \
+  arch/arm/include/asm/linkage.h \
+  include/linux/compiler.h \
+    $(wildcard include/config/trace/branch/profiling.h) \
+    $(wildcard include/config/profile/all/branches.h) \
+    $(wildcard include/config/stack/validation.h) \
+  arch/arm/include/generated/asm/rwonce.h \
+  include/asm-generic/rwonce.h \
+  include/linux/kasan-checks.h \
+    $(wildcard include/config/kasan.h) \
+  include/linux/kcsan-checks.h \
+    $(wildcard include/config/kcsan.h) \
+    $(wildcard include/config/kcsan/ignore/atomics.h) \
+  include/linux/bitops.h \
+  include/linux/bits.h \
+  include/linux/const.h \
+  include/vdso/const.h \
+  include/uapi/linux/const.h \
+  include/vdso/bits.h \
+  include/linux/build_bug.h \
+  arch/arm/include/asm/bitops.h \
+  include/linux/irqflags.h \
+    $(wildcard include/config/trace/irqflags.h) \
+    $(wildcard include/config/irqsoff/tracer.h) \
+    $(wildcard include/config/preempt/tracer.h) \
+    $(wildcard include/config/trace/irqflags/support.h) \
+  include/linux/typecheck.h \
+  arch/arm/include/asm/irqflags.h \
+    $(wildcard include/config/cpu/v7m.h) \
+  arch/arm/include/asm/ptrace.h \
+    $(wildcard include/config/arm/thumb.h) \
+    $(wildcard include/config/thumb2/kernel.h) \
+  arch/arm/include/uapi/asm/ptrace.h \
+    $(wildcard include/config/cpu/endian/be8.h) \
+  arch/arm/include/asm/hwcap.h \
+  arch/arm/include/uapi/asm/hwcap.h \
+  include/asm-generic/irqflags.h \
+  arch/arm/include/asm/percpu.h \
+    $(wildcard include/config/cpu/v6.h) \
+  include/asm-generic/percpu.h \
+    $(wildcard include/config/debug/preempt.h) \
+    $(wildcard include/config/have/setup/per/cpu/area.h) \
+  include/linux/threads.h \
+    $(wildcard include/config/nr/cpus.h) \
+    $(wildcard include/config/base/small.h) \
+  include/linux/percpu-defs.h \
+    $(wildcard include/config/debug/force/weak/per/cpu.h) \
+    $(wildcard include/config/amd/mem/encrypt.h) \
+  arch/arm/include/asm/barrier.h \
+    $(wildcard include/config/cpu/32v6k.h) \
+    $(wildcard include/config/cpu/xsc3.h) \
+    $(wildcard include/config/cpu/fa526.h) \
+    $(wildcard include/config/arm/heavy/mb.h) \
+    $(wildcard include/config/arm/dma/mem/bufferable.h) \
+    $(wildcard include/config/cpu/spectre.h) \
+  include/asm-generic/barrier.h \
+  include/asm-generic/bitops/non-atomic.h \
+  include/asm-generic/bitops/builtin-__fls.h \
+  include/asm-generic/bitops/builtin-__ffs.h \
+  include/asm-generic/bitops/builtin-fls.h \
+  include/asm-generic/bitops/builtin-ffs.h \
+  include/asm-generic/bitops/ffz.h \
+  include/asm-generic/bitops/fls64.h \
+  include/asm-generic/bitops/sched.h \
+  include/asm-generic/bitops/hweight.h \
+  include/asm-generic/bitops/arch_hweight.h \
+  include/asm-generic/bitops/const_hweight.h \
+  include/asm-generic/bitops/lock.h \
+  include/linux/atomic.h \
+  arch/arm/include/asm/atomic.h \
+    $(wildcard include/config/generic/atomic64.h) \
+    $(wildcard include/config/arm/lpae.h) \
+  include/linux/prefetch.h \
+  arch/arm/include/asm/processor.h \
+    $(wildcard include/config/have/hw/breakpoint.h) \
+    $(wildcard include/config/binfmt/elf/fdpic.h) \
+  arch/arm/include/asm/hw_breakpoint.h \
+  arch/arm/include/asm/unified.h \
+  arch/arm/include/asm/vdso/processor.h \
+    $(wildcard include/config/arm/errata/754327.h) \
+  arch/arm/include/asm/cache.h \
+    $(wildcard include/config/arm/l1/cache/shift.h) \
+    $(wildcard include/config/aeabi.h) \
+  arch/arm/include/asm/cmpxchg.h \
+    $(wildcard include/config/cpu/sa1100.h) \
+    $(wildcard include/config/cpu/sa110.h) \
+  include/asm-generic/cmpxchg-local.h \
+  include/linux/atomic-fallback.h \
+  include/asm-generic/atomic-long.h \
+  include/asm-generic/bitops/find.h \
+    $(wildcard include/config/generic/find/first/bit.h) \
+  include/asm-generic/bitops/le.h \
+  arch/arm/include/uapi/asm/byteorder.h \
+  include/linux/byteorder/little_endian.h \
+  include/uapi/linux/byteorder/little_endian.h \
+  include/linux/swab.h \
+  include/uapi/linux/swab.h \
+  arch/arm/include/asm/swab.h \
+  arch/arm/include/uapi/asm/swab.h \
+  include/linux/byteorder/generic.h \
+  include/asm-generic/bitops/ext2-atomic-setbit.h \
+  include/linux/log2.h \
+    $(wildcard include/config/arch/has/ilog2/u32.h) \
+    $(wildcard include/config/arch/has/ilog2/u64.h) \
+  include/linux/minmax.h \
+  include/linux/printk.h \
+    $(wildcard include/config/message/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/default.h) \
+    $(wildcard include/config/console/loglevel/quiet.h) \
+    $(wildcard include/config/early/printk.h) \
+    $(wildcard include/config/printk/nmi.h) \
+    $(wildcard include/config/printk.h) \
+    $(wildcard include/config/dynamic/debug.h) \
+    $(wildcard include/config/dynamic/debug/core.h) \
+  include/linux/init.h \
+    $(wildcard include/config/strict/kernel/rwx.h) \
+    $(wildcard include/config/strict/module/rwx.h) \
+  include/linux/kern_levels.h \
+  include/linux/cache.h \
+    $(wildcard include/config/arch/has/cache/line/size.h) \
+  include/uapi/linux/kernel.h \
+  include/uapi/linux/sysinfo.h \
+  include/linux/ratelimit_types.h \
+  include/uapi/linux/param.h \
+  arch/arm/include/generated/uapi/asm/param.h \
+  include/asm-generic/param.h \
+    $(wildcard include/config/hz.h) \
+  include/uapi/asm-generic/param.h \
+  include/linux/spinlock_types.h \
+    $(wildcard include/config/debug/spinlock.h) \
+    $(wildcard include/config/debug/lock/alloc.h) \
+  arch/arm/include/asm/spinlock_types.h \
+  include/linux/lockdep_types.h \
+    $(wildcard include/config/prove/raw/lock/nesting.h) \
+    $(wildcard include/config/preempt/lock.h) \
+    $(wildcard include/config/lockdep.h) \
+    $(wildcard include/config/lock/stat.h) \
+  include/linux/rwlock_types.h \
+  arch/arm/include/asm/div64.h \
+  arch/arm/include/asm/compiler.h \
+  include/asm-generic/div64.h \
+  arch/arm/include/asm/delay.h \
+  arch/arm/include/asm/memory.h \
+    $(wildcard include/config/need/mach/memory/h.h) \
+    $(wildcard include/config/page/offset.h) \
+    $(wildcard include/config/highmem.h) \
+    $(wildcard include/config/dram/base.h) \
+    $(wildcard include/config/dram/size.h) \
+    $(wildcard include/config/xip/kernel.h) \
+    $(wildcard include/config/have/tcm.h) \
+    $(wildcard include/config/arm/patch/phys/virt.h) \
+    $(wildcard include/config/phys/offset.h) \
+    $(wildcard include/config/xip/phys/addr.h) \
+    $(wildcard include/config/debug/virtual.h) \
+  include/linux/sizes.h \
+  include/asm-generic/memory_model.h \
+    $(wildcard include/config/flatmem.h) \
+    $(wildcard include/config/discontigmem.h) \
+    $(wildcard include/config/sparsemem/vmemmap.h) \
+    $(wildcard include/config/sparsemem.h) \
+  include/linux/pfn.h \
+  include/linux/fs.h \
+    $(wildcard include/config/read/only/thp/for/fs.h) \
+    $(wildcard include/config/fs/posix/acl.h) \
+    $(wildcard include/config/security.h) \
+    $(wildcard include/config/cgroup/writeback.h) \
+    $(wildcard include/config/ima.h) \
+    $(wildcard include/config/file/locking.h) \
+    $(wildcard include/config/fsnotify.h) \
+    $(wildcard include/config/fs/encryption.h) \
+    $(wildcard include/config/fs/verity.h) \
+    $(wildcard include/config/preemption.h) \
+    $(wildcard include/config/epoll.h) \
+    $(wildcard include/config/unicode.h) \
+    $(wildcard include/config/compat.h) \
+    $(wildcard include/config/quota.h) \
+    $(wildcard include/config/fs/dax.h) \
+    $(wildcard include/config/mandatory/file/locking.h) \
+    $(wildcard include/config/block.h) \
+    $(wildcard include/config/migration.h) \
+  include/linux/wait_bit.h \
+  include/linux/wait.h \
+  include/linux/list.h \
+    $(wildcard include/config/debug/list.h) \
+  include/linux/poison.h \
+    $(wildcard include/config/illegal/pointer/value.h) \
+    $(wildcard include/config/page/poisoning/zero.h) \
+  include/linux/spinlock.h \
+  include/linux/preempt.h \
+    $(wildcard include/config/preempt/count.h) \
+    $(wildcard include/config/trace/preempt/toggle.h) \
+    $(wildcard include/config/preempt/notifiers.h) \
+  arch/arm/include/generated/asm/preempt.h \
+  include/asm-generic/preempt.h \
+  include/linux/thread_info.h \
+    $(wildcard include/config/thread/info/in/task.h) \
+    $(wildcard include/config/have/arch/within/stack/frames.h) \
+    $(wildcard include/config/hardened/usercopy.h) \
+  include/linux/bug.h \
+    $(wildcard include/config/generic/bug.h) \
+    $(wildcard include/config/bug/on/data/corruption.h) \
+  arch/arm/include/asm/bug.h \
+    $(wildcard include/config/debug/bugverbose.h) \
+  arch/arm/include/asm/opcodes.h \
+    $(wildcard include/config/cpu/endian/be32.h) \
+  include/asm-generic/bug.h \
+    $(wildcard include/config/bug.h) \
+    $(wildcard include/config/generic/bug/relative/pointers.h) \
+  include/linux/instrumentation.h \
+    $(wildcard include/config/debug/entry.h) \
+  include/linux/restart_block.h \
+  include/linux/time64.h \
+  include/linux/math64.h \
+    $(wildcard include/config/arch/supports/int128.h) \
+  include/vdso/math64.h \
+  include/vdso/time64.h \
+  include/uapi/linux/time.h \
+  include/uapi/linux/time_types.h \
+  include/linux/errno.h \
+  include/uapi/linux/errno.h \
+  arch/arm/include/generated/uapi/asm/errno.h \
+  include/uapi/asm-generic/errno.h \
+  include/uapi/asm-generic/errno-base.h \
+  arch/arm/include/asm/thread_info.h \
+    $(wildcard include/config/stackprotector/per/task.h) \
+    $(wildcard include/config/crunch.h) \
+    $(wildcard include/config/arm/thumbee.h) \
+  arch/arm/include/asm/fpstate.h \
+    $(wildcard include/config/vfpv3.h) \
+    $(wildcard include/config/iwmmxt.h) \
+  arch/arm/include/asm/page.h \
+    $(wildcard include/config/cpu/copy/v4wt.h) \
+    $(wildcard include/config/cpu/copy/v4wb.h) \
+    $(wildcard include/config/cpu/copy/feroceon.h) \
+    $(wildcard include/config/cpu/copy/fa.h) \
+    $(wildcard include/config/cpu/xscale.h) \
+    $(wildcard include/config/cpu/copy/v6.h) \
+    $(wildcard include/config/kuser/helpers.h) \
+    $(wildcard include/config/have/arch/pfn/valid.h) \
+  arch/arm/include/asm/glue.h \
+  arch/arm/include/asm/pgtable-2level-types.h \
+  include/asm-generic/getorder.h \
+  include/linux/bottom_half.h \
+  include/linux/lockdep.h \
+    $(wildcard include/config/debug/locking/api/selftests.h) \
+  include/linux/smp.h \
+    $(wildcard include/config/up/late/init.h) \
+  include/linux/cpumask.h \
+    $(wildcard include/config/cpumask/offstack.h) \
+    $(wildcard include/config/hotplug/cpu.h) \
+    $(wildcard include/config/debug/per/cpu/maps.h) \
+  include/linux/bitmap.h \
+  include/linux/string.h \
+    $(wildcard include/config/binary/printf.h) \
+    $(wildcard include/config/fortify/source.h) \
+  include/uapi/linux/string.h \
+  arch/arm/include/asm/string.h \
+    $(wildcard include/config/bcm2835/fast/memcpy.h) \
+  include/linux/smp_types.h \
+  include/linux/llist.h \
+    $(wildcard include/config/arch/have/nmi/safe/cmpxchg.h) \
+  arch/arm/include/asm/smp.h \
+  arch/arm/include/generated/asm/mmiowb.h \
+  include/asm-generic/mmiowb.h \
+    $(wildcard include/config/mmiowb.h) \
+  arch/arm/include/asm/spinlock.h \
+  include/linux/rwlock.h \
+    $(wildcard include/config/preempt.h) \
+  include/linux/spinlock_api_smp.h \
+    $(wildcard include/config/inline/spin/lock.h) \
+    $(wildcard include/config/inline/spin/lock/bh.h) \
+    $(wildcard include/config/inline/spin/lock/irq.h) \
+    $(wildcard include/config/inline/spin/lock/irqsave.h) \
+    $(wildcard include/config/inline/spin/trylock.h) \
+    $(wildcard include/config/inline/spin/trylock/bh.h) \
+    $(wildcard include/config/uninline/spin/unlock.h) \
+    $(wildcard include/config/inline/spin/unlock/bh.h) \
+    $(wildcard include/config/inline/spin/unlock/irq.h) \
+    $(wildcard include/config/inline/spin/unlock/irqrestore.h) \
+    $(wildcard include/config/generic/lockbreak.h) \
+  include/linux/rwlock_api_smp.h \
+    $(wildcard include/config/inline/read/lock.h) \
+    $(wildcard include/config/inline/write/lock.h) \
+    $(wildcard include/config/inline/read/lock/bh.h) \
+    $(wildcard include/config/inline/write/lock/bh.h) \
+    $(wildcard include/config/inline/read/lock/irq.h) \
+    $(wildcard include/config/inline/write/lock/irq.h) \
+    $(wildcard include/config/inline/read/lock/irqsave.h) \
+    $(wildcard include/config/inline/write/lock/irqsave.h) \
+    $(wildcard include/config/inline/read/trylock.h) \
+    $(wildcard include/config/inline/write/trylock.h) \
+    $(wildcard include/config/inline/read/unlock.h) \
+    $(wildcard include/config/inline/write/unlock.h) \
+    $(wildcard include/config/inline/read/unlock/bh.h) \
+    $(wildcard include/config/inline/write/unlock/bh.h) \
+    $(wildcard include/config/inline/read/unlock/irq.h) \
+    $(wildcard include/config/inline/write/unlock/irq.h) \
+    $(wildcard include/config/inline/read/unlock/irqrestore.h) \
+    $(wildcard include/config/inline/write/unlock/irqrestore.h) \
+  arch/arm/include/generated/asm/current.h \
+  include/asm-generic/current.h \
+  include/uapi/linux/wait.h \
+  include/linux/kdev_t.h \
+  include/uapi/linux/kdev_t.h \
+  include/linux/dcache.h \
+  include/linux/rculist.h \
+    $(wildcard include/config/prove/rcu/list.h) \
+  include/linux/rcupdate.h \
+    $(wildcard include/config/preempt/rcu.h) \
+    $(wildcard include/config/tiny/rcu.h) \
+    $(wildcard include/config/tasks/rcu/generic.h) \
+    $(wildcard include/config/rcu/stall/common.h) \
+    $(wildcard include/config/no/hz/full.h) \
+    $(wildcard include/config/rcu/nocb/cpu.h) \
+    $(wildcard include/config/tasks/rcu.h) \
+    $(wildcard include/config/tasks/trace/rcu.h) \
+    $(wildcard include/config/tasks/rude/rcu.h) \
+    $(wildcard include/config/tree/rcu.h) \
+    $(wildcard include/config/debug/objects/rcu/head.h) \
+    $(wildcard include/config/prove/rcu.h) \
+    $(wildcard include/config/rcu/boost.h) \
+    $(wildcard include/config/arch/weak/release/acquire.h) \
+  include/linux/rcutree.h \
+  include/linux/rculist_bl.h \
+  include/linux/list_bl.h \
+  include/linux/bit_spinlock.h \
+  include/linux/seqlock.h \
+  include/linux/mutex.h \
+    $(wildcard include/config/mutex/spin/on/owner.h) \
+    $(wildcard include/config/debug/mutexes.h) \
+  include/linux/osq_lock.h \
+  include/linux/debug_locks.h \
+  include/linux/ww_mutex.h \
+    $(wildcard include/config/debug/ww/mutex/slowpath.h) \
+  include/linux/lockref.h \
+    $(wildcard include/config/arch/use/cmpxchg/lockref.h) \
+  include/generated/bounds.h \
+  include/linux/stringhash.h \
+    $(wildcard include/config/dcache/word/access.h) \
+  include/linux/hash.h \
+    $(wildcard include/config/have/arch/hash.h) \
+  include/linux/path.h \
+  include/linux/stat.h \
+  arch/arm/include/uapi/asm/stat.h \
+  include/uapi/linux/stat.h \
+  include/linux/time.h \
+    $(wildcard include/config/arch/uses/gettimeoffset.h) \
+    $(wildcard include/config/posix/timers.h) \
+  include/linux/time32.h \
+  include/linux/timex.h \
+  include/uapi/linux/timex.h \
+  arch/arm/include/asm/timex.h \
+  include/vdso/time32.h \
+  include/vdso/time.h \
+  include/linux/uidgid.h \
+    $(wildcard include/config/multiuser.h) \
+    $(wildcard include/config/user/ns.h) \
+  include/linux/highuid.h \
+  include/linux/list_lru.h \
+    $(wildcard include/config/memcg/kmem.h) \
+  include/linux/nodemask.h \
+    $(wildcard include/config/numa.h) \
+  include/linux/numa.h \
+    $(wildcard include/config/nodes/shift.h) \
+    $(wildcard include/config/numa/keep/meminfo.h) \
+  include/linux/shrinker.h \
+    $(wildcard include/config/memcg.h) \
+  include/linux/radix-tree.h \
+  include/linux/percpu.h \
+    $(wildcard include/config/need/per/cpu/embed/first/chunk.h) \
+    $(wildcard include/config/need/per/cpu/page/first/chunk.h) \
+  include/linux/mmdebug.h \
+    $(wildcard include/config/debug/vm.h) \
+    $(wildcard include/config/debug/vm/pgflags.h) \
+  include/linux/xarray.h \
+    $(wildcard include/config/xarray/multi.h) \
+  include/linux/gfp.h \
+    $(wildcard include/config/zone/dma.h) \
+    $(wildcard include/config/zone/dma32.h) \
+    $(wildcard include/config/zone/device.h) \
+    $(wildcard include/config/pm/sleep.h) \
+    $(wildcard include/config/contig/alloc.h) \
+    $(wildcard include/config/cma.h) \
+  include/linux/mmzone.h \
+    $(wildcard include/config/force/max/zoneorder.h) \
+    $(wildcard include/config/memory/isolation.h) \
+    $(wildcard include/config/zsmalloc.h) \
+    $(wildcard include/config/shadow/call/stack.h) \
+    $(wildcard include/config/need/multiple/nodes.h) \
+    $(wildcard include/config/memory/hotplug.h) \
+    $(wildcard include/config/compaction.h) \
+    $(wildcard include/config/transparent/hugepage.h) \
+    $(wildcard include/config/flat/node/mem/map.h) \
+    $(wildcard include/config/page/extension.h) \
+    $(wildcard include/config/deferred/struct/page/init.h) \
+    $(wildcard include/config/have/memoryless/nodes.h) \
+    $(wildcard include/config/sparsemem/extreme.h) \
+    $(wildcard include/config/memory/hotremove.h) \
+    $(wildcard include/config/holes/in/zone.h) \
+    $(wildcard include/config/arch/has/holes/memorymodel.h) \
+  include/linux/pageblock-flags.h \
+    $(wildcard include/config/hugetlb/page.h) \
+    $(wildcard include/config/hugetlb/page/size/variable.h) \
+  include/linux/page-flags-layout.h \
+    $(wildcard include/config/numa/balancing.h) \
+    $(wildcard include/config/kasan/sw/tags.h) \
+  include/linux/mm_types.h \
+    $(wildcard include/config/have/aligned/struct/page.h) \
+    $(wildcard include/config/userfaultfd.h) \
+    $(wildcard include/config/swap.h) \
+    $(wildcard include/config/have/arch/compat/mmap/bases.h) \
+    $(wildcard include/config/membarrier.h) \
+    $(wildcard include/config/aio.h) \
+    $(wildcard include/config/mmu/notifier.h) \
+    $(wildcard include/config/arch/want/batched/unmap/tlb/flush.h) \
+    $(wildcard include/config/iommu/support.h) \
+  include/linux/mm_types_task.h \
+    $(wildcard include/config/split/ptlock/cpus.h) \
+    $(wildcard include/config/arch/enable/split/pmd/ptlock.h) \
+  include/linux/auxvec.h \
+  include/uapi/linux/auxvec.h \
+  arch/arm/include/asm/auxvec.h \
+  arch/arm/include/uapi/asm/auxvec.h \
+  include/linux/rbtree.h \
+  include/linux/rwsem.h \
+    $(wildcard include/config/rwsem/spin/on/owner.h) \
+    $(wildcard include/config/debug/rwsems.h) \
+  include/linux/err.h \
+  include/linux/completion.h \
+  include/linux/swait.h \
+  include/linux/uprobes.h \
+    $(wildcard include/config/uprobes.h) \
+  include/linux/workqueue.h \
+    $(wildcard include/config/debug/objects/work.h) \
+    $(wildcard include/config/freezer.h) \
+    $(wildcard include/config/sysfs.h) \
+    $(wildcard include/config/wq/watchdog.h) \
+  include/linux/timer.h \
+    $(wildcard include/config/debug/objects/timers.h) \
+    $(wildcard include/config/no/hz/common.h) \
+  include/linux/ktime.h \
+  include/linux/jiffies.h \
+  include/vdso/jiffies.h \
+  include/generated/timeconst.h \
+  include/vdso/ktime.h \
+  include/linux/timekeeping.h \
+  include/linux/timekeeping32.h \
+  include/linux/debugobjects.h \
+    $(wildcard include/config/debug/objects.h) \
+    $(wildcard include/config/debug/objects/free.h) \
+  arch/arm/include/asm/mmu.h \
+    $(wildcard include/config/cpu/has/asid.h) \
+    $(wildcard include/config/vdso.h) \
+  include/linux/page-flags.h \
+    $(wildcard include/config/arch/uses/pg/uncached.h) \
+    $(wildcard include/config/memory/failure.h) \
+    $(wildcard include/config/idle/page/tracking.h) \
+    $(wildcard include/config/thp/swap.h) \
+    $(wildcard include/config/ksm.h) \
+  include/linux/memory_hotplug.h \
+    $(wildcard include/config/arch/has/add/pages.h) \
+    $(wildcard include/config/have/arch/nodedata/extension.h) \
+    $(wildcard include/config/have/bootmem/info/node.h) \
+  include/linux/notifier.h \
+    $(wildcard include/config/tree/srcu.h) \
+  include/linux/srcu.h \
+    $(wildcard include/config/tiny/srcu.h) \
+    $(wildcard include/config/srcu.h) \
+  include/linux/rcu_segcblist.h \
+  include/linux/srcutree.h \
+  include/linux/rcu_node_tree.h \
+    $(wildcard include/config/rcu/fanout.h) \
+    $(wildcard include/config/rcu/fanout/leaf.h) \
+  include/linux/topology.h \
+    $(wildcard include/config/use/percpu/numa/node/id.h) \
+    $(wildcard include/config/sched/smt.h) \
+  include/linux/arch_topology.h \
+    $(wildcard include/config/generic/arch/topology.h) \
+  arch/arm/include/asm/topology.h \
+    $(wildcard include/config/arm/cpu/topology.h) \
+    $(wildcard include/config/bl/switcher.h) \
+  include/asm-generic/topology.h \
+  include/linux/kconfig.h \
+  include/linux/local_lock.h \
+  include/linux/local_lock_internal.h \
+  include/linux/pid.h \
+  include/linux/refcount.h \
+  include/linux/capability.h \
+  include/uapi/linux/capability.h \
+  include/linux/semaphore.h \
+  include/linux/fcntl.h \
+    $(wildcard include/config/arch/32bit/off/t.h) \
+  include/uapi/linux/fcntl.h \
+  arch/arm/include/uapi/asm/fcntl.h \
+  include/uapi/asm-generic/fcntl.h \
+  include/uapi/linux/openat2.h \
+  include/linux/migrate_mode.h \
+  include/linux/percpu-rwsem.h \
+  include/linux/rcuwait.h \
+  include/linux/sched/signal.h \
+    $(wildcard include/config/sched/autogroup.h) \
+    $(wildcard include/config/bsd/process/acct.h) \
+    $(wildcard include/config/taskstats.h) \
+    $(wildcard include/config/audit.h) \
+    $(wildcard include/config/stack/growsup.h) \
+  include/linux/signal.h \
+    $(wildcard include/config/proc/fs.h) \
+  include/linux/signal_types.h \
+    $(wildcard include/config/old/sigaction.h) \
+  include/uapi/linux/signal.h \
+  arch/arm/include/asm/signal.h \
+  arch/arm/include/uapi/asm/signal.h \
+  include/uapi/asm-generic/signal-defs.h \
+  arch/arm/include/uapi/asm/sigcontext.h \
+  arch/arm/include/generated/uapi/asm/siginfo.h \
+  include/uapi/asm-generic/siginfo.h \
+  include/linux/sched.h \
+    $(wildcard include/config/virt/cpu/accounting/native.h) \
+    $(wildcard include/config/sched/info.h) \
+    $(wildcard include/config/schedstats.h) \
+    $(wildcard include/config/fair/group/sched.h) \
+    $(wildcard include/config/rt/group/sched.h) \
+    $(wildcard include/config/rt/mutexes.h) \
+    $(wildcard include/config/uclamp/task.h) \
+    $(wildcard include/config/uclamp/buckets/count.h) \
+    $(wildcard include/config/cgroup/sched.h) \
+    $(wildcard include/config/blk/dev/io/trace.h) \
+    $(wildcard include/config/psi.h) \
+    $(wildcard include/config/compat/brk.h) \
+    $(wildcard include/config/cgroups.h) \
+    $(wildcard include/config/blk/cgroup.h) \
+    $(wildcard include/config/stackprotector.h) \
+    $(wildcard include/config/arch/has/scaled/cputime.h) \
+    $(wildcard include/config/virt/cpu/accounting/gen.h) \
+    $(wildcard include/config/posix/cputimers.h) \
+    $(wildcard include/config/posix/cpu/timers/task/work.h) \
+    $(wildcard include/config/keys.h) \
+    $(wildcard include/config/sysvipc.h) \
+    $(wildcard include/config/detect/hung/task.h) \
+    $(wildcard include/config/io/uring.h) \
+    $(wildcard include/config/auditsyscall.h) \
+    $(wildcard include/config/ubsan.h) \
+    $(wildcard include/config/ubsan/trap.h) \
+    $(wildcard include/config/task/xacct.h) \
+    $(wildcard include/config/cpusets.h) \
+    $(wildcard include/config/x86/cpu/resctrl.h) \
+    $(wildcard include/config/futex.h) \
+    $(wildcard include/config/perf/events.h) \
+    $(wildcard include/config/rseq.h) \
+    $(wildcard include/config/task/delay/acct.h) \
+    $(wildcard include/config/fault/injection.h) \
+    $(wildcard include/config/latencytop.h) \
+    $(wildcard include/config/kunit.h) \
+    $(wildcard include/config/function/graph/tracer.h) \
+    $(wildcard include/config/bcache.h) \
+    $(wildcard include/config/vmap/stack.h) \
+    $(wildcard include/config/livepatch.h) \
+    $(wildcard include/config/gcc/plugin/stackleak.h) \
+    $(wildcard include/config/x86/mce.h) \
+    $(wildcard include/config/arch/task/struct/on/stack.h) \
+    $(wildcard include/config/debug/rseq.h) \
+  include/uapi/linux/sched.h \
+  include/linux/sem.h \
+  include/uapi/linux/sem.h \
+  include/linux/ipc.h \
+  include/linux/rhashtable-types.h \
+  include/uapi/linux/ipc.h \
+  arch/arm/include/generated/uapi/asm/ipcbuf.h \
+  include/uapi/asm-generic/ipcbuf.h \
+  arch/arm/include/generated/uapi/asm/sembuf.h \
+  include/uapi/asm-generic/sembuf.h \
+  include/linux/shm.h \
+  include/uapi/linux/shm.h \
+  include/uapi/asm-generic/hugetlb_encode.h \
+  arch/arm/include/generated/uapi/asm/shmbuf.h \
+  include/uapi/asm-generic/shmbuf.h \
+  arch/arm/include/asm/shmparam.h \
+  include/linux/kcov.h \
+  include/uapi/linux/kcov.h \
+  include/linux/plist.h \
+    $(wildcard include/config/debug/plist.h) \
+  include/linux/hrtimer.h \
+    $(wildcard include/config/high/res/timers.h) \
+    $(wildcard include/config/time/low/res.h) \
+    $(wildcard include/config/timerfd.h) \
+  include/linux/hrtimer_defs.h \
+  include/linux/timerqueue.h \
+  include/linux/seccomp.h \
+    $(wildcard include/config/seccomp.h) \
+    $(wildcard include/config/have/arch/seccomp/filter.h) \
+    $(wildcard include/config/seccomp/filter.h) \
+    $(wildcard include/config/checkpoint/restore.h) \
+  include/uapi/linux/seccomp.h \
+  arch/arm/include/generated/asm/seccomp.h \
+  include/asm-generic/seccomp.h \
+  include/uapi/linux/unistd.h \
+  arch/arm/include/asm/unistd.h \
+    $(wildcard include/config/oabi/compat.h) \
+  arch/arm/include/uapi/asm/unistd.h \
+  arch/arm/include/generated/uapi/asm/unistd-eabi.h \
+  arch/arm/include/generated/uapi/asm/unistd-common.h \
+  arch/arm/include/generated/asm/unistd-nr.h \
+  include/linux/resource.h \
+  include/uapi/linux/resource.h \
+  arch/arm/include/generated/uapi/asm/resource.h \
+  include/asm-generic/resource.h \
+  include/uapi/asm-generic/resource.h \
+  include/linux/latencytop.h \
+  include/linux/sched/prio.h \
+  include/linux/sched/types.h \
+  include/linux/task_io_accounting.h \
+    $(wildcard include/config/task/io/accounting.h) \
+  include/linux/posix-timers.h \
+  include/linux/alarmtimer.h \
+    $(wildcard include/config/rtc/class.h) \
+  include/linux/task_work.h \
+  include/uapi/linux/rseq.h \
+  include/linux/kcsan.h \
+  include/linux/sched/jobctl.h \
+  include/linux/sched/task.h \
+    $(wildcard include/config/have/exit/thread.h) \
+    $(wildcard include/config/arch/wants/dynamic/task/struct.h) \
+    $(wildcard include/config/have/arch/thread/struct/whitelist.h) \
+  include/linux/uaccess.h \
+    $(wildcard include/config/set/fs.h) \
+  include/linux/fault-inject-usercopy.h \
+    $(wildcard include/config/fault/injection/usercopy.h) \
+  include/linux/instrumented.h \
+  arch/arm/include/asm/uaccess.h \
+    $(wildcard include/config/cpu/sw/domain/pan.h) \
+    $(wildcard include/config/cpu/use/domains.h) \
+    $(wildcard include/config/uaccess/with/memcpy.h) \
+  arch/arm/include/asm/domain.h \
+    $(wildcard include/config/io/36.h) \
+    $(wildcard include/config/cpu/cp15/mmu.h) \
+  arch/arm/include/generated/asm/extable.h \
+  include/asm-generic/extable.h \
+  include/linux/cred.h \
+    $(wildcard include/config/debug/credentials.h) \
+  include/linux/key.h \
+    $(wildcard include/config/key/notifications.h) \
+    $(wildcard include/config/net.h) \
+    $(wildcard include/config/sysctl.h) \
+  include/linux/sysctl.h \
+  include/uapi/linux/sysctl.h \
+  include/linux/assoc_array.h \
+    $(wildcard include/config/associative/array.h) \
+  include/linux/sched/user.h \
+    $(wildcard include/config/fanotify.h) \
+    $(wildcard include/config/posix/mqueue.h) \
+    $(wildcard include/config/bpf/syscall.h) \
+    $(wildcard include/config/watch/queue.h) \
+  include/linux/ratelimit.h \
+  include/linux/rcu_sync.h \
+  include/linux/delayed_call.h \
+  include/linux/uuid.h \
+  include/uapi/linux/uuid.h \
+  include/linux/errseq.h \
+  include/linux/ioprio.h \
+  include/linux/sched/rt.h \
+  include/linux/iocontext.h \
+  include/linux/fs_types.h \
+  include/uapi/linux/fs.h \
+  include/uapi/linux/ioctl.h \
+  arch/arm/include/generated/uapi/asm/ioctl.h \
+  include/asm-generic/ioctl.h \
+  include/uapi/asm-generic/ioctl.h \
+  include/linux/quota.h \
+    $(wildcard include/config/quota/netlink/interface.h) \
+  include/linux/percpu_counter.h \
+  include/uapi/linux/dqblk_xfs.h \
+  include/linux/dqblk_v1.h \
+  include/linux/dqblk_v2.h \
+  include/linux/dqblk_qtree.h \
+  include/linux/projid.h \
+  include/uapi/linux/quota.h \
+  include/linux/nfs_fs_i.h \
+  include/linux/gpio.h \
+    $(wildcard include/config/gpiolib.h) \
+    $(wildcard include/config/arch/have/custom/gpio/h.h) \
+  arch/arm/include/asm/gpio.h \
+    $(wildcard include/config/arch/nr/gpio.h) \
+  include/asm-generic/gpio.h \
+  include/linux/gpio/driver.h \
+    $(wildcard include/config/irq/domain/hierarchy.h) \
+    $(wildcard include/config/gpio/generic.h) \
+    $(wildcard include/config/gpiolib/irqchip.h) \
+    $(wildcard include/config/of/gpio.h) \
+    $(wildcard include/config/of.h) \
+    $(wildcard include/config/pinctrl.h) \
+  include/linux/device.h \
+    $(wildcard include/config/debug/devres.h) \
+    $(wildcard include/config/energy/model.h) \
+    $(wildcard include/config/generic/msi/irq/domain.h) \
+    $(wildcard include/config/generic/msi/irq.h) \
+    $(wildcard include/config/dma/ops.h) \
+    $(wildcard include/config/dma/declare/coherent.h) \
+    $(wildcard include/config/dma/cma.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/device.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu.h) \
+    $(wildcard include/config/arch/has/sync/dma/for/cpu/all.h) \
+    $(wildcard include/config/dma/ops/bypass.h) \
+    $(wildcard include/config/devtmpfs.h) \
+    $(wildcard include/config/sysfs/deprecated.h) \
+  include/linux/dev_printk.h \
+  include/linux/energy_model.h \
+  include/linux/jump_label.h \
+    $(wildcard include/config/jump/label.h) \
+    $(wildcard include/config/have/arch/jump/label/relative.h) \
+  arch/arm/include/asm/jump_label.h \
+  include/linux/kobject.h \
+    $(wildcard include/config/uevent/helper.h) \
+    $(wildcard include/config/debug/kobject/release.h) \
+  include/linux/sysfs.h \
+  include/linux/kernfs.h \
+    $(wildcard include/config/kernfs.h) \
+  include/linux/idr.h \
+  include/linux/kobject_ns.h \
+  include/linux/kref.h \
+  include/linux/sched/cpufreq.h \
+    $(wildcard include/config/cpu/freq.h) \
+  include/linux/sched/topology.h \
+    $(wildcard include/config/sched/debug.h) \
+    $(wildcard include/config/sched/mc.h) \
+  include/linux/sched/idle.h \
+  include/linux/sched/sd_flags.h \
+  include/linux/ioport.h \
+    $(wildcard include/config/io/strict/devmem.h) \
+  include/linux/klist.h \
+  include/linux/pm.h \
+    $(wildcard include/config/vt/console/sleep.h) \
+    $(wildcard include/config/pm.h) \
+    $(wildcard include/config/pm/clk.h) \
+    $(wildcard include/config/pm/generic/domains.h) \
+  include/linux/overflow.h \
+  include/linux/device/bus.h \
+    $(wildcard include/config/acpi.h) \
+  include/linux/device/class.h \
+  include/linux/device/driver.h \
+  arch/arm/include/asm/device.h \
+    $(wildcard include/config/dmabounce.h) \
+    $(wildcard include/config/arm/dma/use/iommu.h) \
+    $(wildcard include/config/arch/omap.h) \
+  include/linux/pm_wakeup.h \
+  include/linux/irq.h \
+    $(wildcard include/config/generic/irq/effective/aff/mask.h) \
+    $(wildcard include/config/generic/irq/ipi.h) \
+    $(wildcard include/config/generic/irq/migration.h) \
+    $(wildcard include/config/generic/pending/irq.h) \
+    $(wildcard include/config/hardirqs/sw/resend.h) \
+    $(wildcard include/config/generic/irq/legacy/alloc/hwirq.h) \
+    $(wildcard include/config/generic/irq/legacy.h) \
+    $(wildcard include/config/generic/irq/multi/handler.h) \
+  include/linux/irqhandler.h \
+  include/linux/irqreturn.h \
+  include/linux/irqnr.h \
+  include/uapi/linux/irqnr.h \
+  include/linux/io.h \
+    $(wildcard include/config/have/arch/huge/vmap.h) \
+    $(wildcard include/config/has/ioport/map.h) \
+    $(wildcard include/config/pci.h) \
+  arch/arm/include/asm/io.h \
+    $(wildcard include/config/need/mach/io/h.h) \
+    $(wildcard include/config/pcmcia/soc/common.h) \
+    $(wildcard include/config/isa.h) \
+    $(wildcard include/config/pccard.h) \
+  include/asm-generic/pci_iomap.h \
+    $(wildcard include/config/no/generic/pci/ioport/map.h) \
+    $(wildcard include/config/generic/pci/iomap.h) \
+  include/asm-generic/io.h \
+    $(wildcard include/config/generic/iomap.h) \
+    $(wildcard include/config/generic/ioremap.h) \
+    $(wildcard include/config/virt/to/bus.h) \
+  include/linux/logic_pio.h \
+    $(wildcard include/config/indirect/pio.h) \
+  include/linux/fwnode.h \
+  include/linux/vmalloc.h \
+    $(wildcard include/config/kasan/vmalloc.h) \
+  arch/arm/include/asm/vmalloc.h \
+  include/linux/slab.h \
+    $(wildcard include/config/debug/slab.h) \
+    $(wildcard include/config/failslab.h) \
+    $(wildcard include/config/have/hardened/usercopy/allocator.h) \
+    $(wildcard include/config/slab.h) \
+    $(wildcard include/config/slub.h) \
+    $(wildcard include/config/slob.h) \
+  include/linux/percpu-refcount.h \
+  include/linux/kasan.h \
+    $(wildcard include/config/kasan/generic.h) \
+    $(wildcard include/config/kasan/inline.h) \
+  arch/arm/include/asm/irq.h \
+    $(wildcard include/config/sparse/irq.h) \
+  arch/arm/include/generated/asm/irq_regs.h \
+  include/asm-generic/irq_regs.h \
+  include/linux/irqdesc.h \
+    $(wildcard include/config/generic/irq/debugfs.h) \
+    $(wildcard include/config/handle/domain/irq.h) \
+    $(wildcard include/config/irq/domain.h) \
+  arch/arm/include/asm/hw_irq.h \
+  include/linux/irqchip/chained_irq.h \
+  include/linux/irqdomain.h \
+  include/linux/of.h \
+    $(wildcard include/config/of/dynamic.h) \
+    $(wildcard include/config/sparc.h) \
+    $(wildcard include/config/of/promtree.h) \
+    $(wildcard include/config/of/kobj.h) \
+    $(wildcard include/config/of/numa.h) \
+    $(wildcard include/config/of/overlay.h) \
+  include/linux/mod_devicetable.h \
+  include/linux/property.h \
+  include/linux/pinctrl/pinctrl.h \
+    $(wildcard include/config/generic/pinconf.h) \
+  include/linux/seq_file.h \
+  include/linux/pinctrl/pinctrl-state.h \
+  include/linux/pinctrl/devinfo.h \
+  include/linux/pinctrl/consumer.h \
+  include/linux/pinctrl/pinconf-generic.h \
+  include/linux/pinctrl/machine.h \
+  include/linux/gpio/consumer.h \
+    $(wildcard include/config/gpio/sysfs.h) \
+  include/linux/i2c.h \
+    $(wildcard include/config/i2c.h) \
+    $(wildcard include/config/i2c/slave.h) \
+    $(wildcard include/config/i2c/boardinfo.h) \
+    $(wildcard include/config/i2c/mux.h) \
+  include/linux/acpi.h \
+    $(wildcard include/config/acpi/debugger.h) \
+    $(wildcard include/config/x86.h) \
+    $(wildcard include/config/ia64.h) \
+    $(wildcard include/config/acpi/processor/cstate.h) \
+    $(wildcard include/config/acpi/hotplug/cpu.h) \
+    $(wildcard include/config/acpi/hotplug/ioapic.h) \
+    $(wildcard include/config/x86/io/apic.h) \
+    $(wildcard include/config/acpi/wmi.h) \
+    $(wildcard include/config/acpi/numa.h) \
+    $(wildcard include/config/hibernation.h) \
+    $(wildcard include/config/acpi/hotplug/memory.h) \
+    $(wildcard include/config/acpi/container.h) \
+    $(wildcard include/config/acpi/gtdt.h) \
+    $(wildcard include/config/acpi/table/upgrade.h) \
+    $(wildcard include/config/acpi/watchdog.h) \
+    $(wildcard include/config/acpi/spcr/table.h) \
+    $(wildcard include/config/acpi/generic/gsi.h) \
+    $(wildcard include/config/acpi/lpit.h) \
+    $(wildcard include/config/acpi/pptt.h) \
+  include/linux/resource_ext.h \
+  include/acpi/acpi.h \
+  include/acpi/platform/acenv.h \
+  include/acpi/platform/acgcc.h \
+  include/acpi/platform/aclinux.h \
+    $(wildcard include/config/acpi/reduced/hardware/only.h) \
+    $(wildcard include/config/acpi/debug.h) \
+  include/linux/ctype.h \
+  include/acpi/acnames.h \
+  include/acpi/actypes.h \
+  include/acpi/acexcep.h \
+  include/acpi/actbl.h \
+  include/acpi/actbl1.h \
+  include/acpi/actbl2.h \
+  include/acpi/actbl3.h \
+  include/acpi/acrestyp.h \
+  include/acpi/platform/acenvex.h \
+  include/acpi/platform/aclinuxex.h \
+  include/acpi/platform/acgccex.h \
+  include/acpi/acoutput.h \
+  include/acpi/acpiosxf.h \
+  include/acpi/acpixf.h \
+  include/acpi/acconfig.h \
+  include/acpi/acbuffer.h \
+  include/acpi/acpi_numa.h \
+    $(wildcard include/config/acpi/hmat.h) \
+  include/linux/rtmutex.h \
+    $(wildcard include/config/debug/rt/mutexes.h) \
+  include/uapi/linux/i2c.h \
+  include/linux/interrupt.h \
+    $(wildcard include/config/irq/forced/threading.h) \
+    $(wildcard include/config/generic/irq/probe.h) \
+    $(wildcard include/config/irq/timings.h) \
+  include/linux/hardirq.h \
+  include/linux/context_tracking_state.h \
+    $(wildcard include/config/context/tracking.h) \
+  include/linux/static_key.h \
+  include/linux/ftrace_irq.h \
+    $(wildcard include/config/hwlat/tracer.h) \
+  include/linux/vtime.h \
+    $(wildcard include/config/virt/cpu/accounting.h) \
+    $(wildcard include/config/irq/time/accounting.h) \
+  arch/arm/include/asm/hardirq.h \
+  include/linux/irq_cpustat.h \
+  arch/arm/include/asm/sections.h \
+  include/asm-generic/sections.h \
+  drivers/input/touchscreen/hxchipset/himax_common.h \
+    $(wildcard include/config/touchscreen/himax/ic/hx83192.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83193.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83195.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83180.h) \
+    $(wildcard include/config/touchscreen/himax/ic/hx83181.h) \
+    $(wildcard include/config/touchscreen/himax/self/test.h) \
+  include/linux/input.h \
+  include/uapi/linux/input.h \
+  include/uapi/linux/input-event-codes.h \
+  include/linux/module.h \
+    $(wildcard include/config/modules/tree/lookup.h) \
+    $(wildcard include/config/module/sig.h) \
+    $(wildcard include/config/kallsyms.h) \
+    $(wildcard include/config/tracepoints.h) \
+    $(wildcard include/config/bpf/events.h) \
+    $(wildcard include/config/event/tracing.h) \
+    $(wildcard include/config/kprobes.h) \
+    $(wildcard include/config/have/static/call/inline.h) \
+    $(wildcard include/config/module/unload.h) \
+    $(wildcard include/config/constructors.h) \
+    $(wildcard include/config/function/error/injection.h) \
+  include/linux/kmod.h \
+  include/linux/umh.h \
+  include/linux/elf.h \
+    $(wildcard include/config/arch/use/gnu/property.h) \
+    $(wildcard include/config/arch/have/elf/prot.h) \
+  arch/arm/include/asm/elf.h \
+  arch/arm/include/asm/vdso_datapage.h \
+  include/vdso/datapage.h \
+    $(wildcard include/config/arch/has/vdso/data.h) \
+  include/uapi/asm-generic/errno-base.h \
+  include/vdso/clocksource.h \
+    $(wildcard include/config/generic/gettimeofday.h) \
+  arch/arm/include/asm/vdso/clocksource.h \
+  include/vdso/processor.h \
+  arch/arm/include/asm/vdso/gettimeofday.h \
+    $(wildcard include/config/arm/arch/timer.h) \
+  arch/arm/include/asm/vdso/cp15.h \
+    $(wildcard include/config/cpu/cp15.h) \
+  arch/arm/include/asm/user.h \
+  include/uapi/linux/elf.h \
+  include/uapi/linux/elf-em.h \
+  include/linux/moduleparam.h \
+    $(wildcard include/config/alpha.h) \
+    $(wildcard include/config/ppc64.h) \
+  include/linux/rbtree_latch.h \
+  include/linux/error-injection.h \
+  include/asm-generic/error-injection.h \
+  include/linux/tracepoint-defs.h \
+  include/linux/static_call_types.h \
+    $(wildcard include/config/have/static/call.h) \
+  arch/arm/include/asm/module.h \
+    $(wildcard include/config/arm/unwind.h) \
+    $(wildcard include/config/arm/module/plts.h) \
+  include/asm-generic/module.h \
+    $(wildcard include/config/have/mod/arch/specific.h) \
+    $(wildcard include/config/modules/use/elf/rel.h) \
+    $(wildcard include/config/modules/use/elf/rela.h) \
+  include/linux/async.h \
+  include/linux/platform_device.h \
+    $(wildcard include/config/suspend.h) \
+    $(wildcard include/config/hibernate/callbacks.h) \
+    $(wildcard include/config/superh.h) \
+  include/linux/input/mt.h \
+  include/linux/firmware.h \
+    $(wildcard include/config/fw/loader.h) \
+  include/linux/buffer_head.h \
+  include/linux/pagemap.h \
+  include/linux/mm.h \
+    $(wildcard include/config/have/arch/mmap/rnd/bits.h) \
+    $(wildcard include/config/have/arch/mmap/rnd/compat/bits.h) \
+    $(wildcard include/config/mem/soft/dirty.h) \
+    $(wildcard include/config/arch/uses/high/vma/flags.h) \
+    $(wildcard include/config/arch/has/pkeys.h) \
+    $(wildcard include/config/ppc.h) \
+    $(wildcard include/config/parisc.h) \
+    $(wildcard include/config/sparc64.h) \
+    $(wildcard include/config/arm64/mte.h) \
+    $(wildcard include/config/shmem.h) \
+    $(wildcard include/config/dev/pagemap/ops.h) \
+    $(wildcard include/config/device/private.h) \
+    $(wildcard include/config/pci/p2pdma.h) \
+    $(wildcard include/config/arch/has/pte/special.h) \
+    $(wildcard include/config/arch/has/pte/devmap.h) \
+    $(wildcard include/config/debug/vm/rb.h) \
+    $(wildcard include/config/page/poisoning.h) \
+    $(wildcard include/config/init/on/alloc/default/on.h) \
+    $(wildcard include/config/init/on/free/default/on.h) \
+    $(wildcard include/config/debug/pagealloc.h) \
+    $(wildcard include/config/arch/has/set/direct/map.h) \
+    $(wildcard include/config/hugetlbfs.h) \
+    $(wildcard include/config/mapping/dirty/helpers.h) \
+  include/linux/mmap_lock.h \
+  include/linux/range.h \
+  include/linux/page_ext.h \
+  include/linux/stacktrace.h \
+    $(wildcard include/config/stacktrace.h) \
+    $(wildcard include/config/arch/stackwalk.h) \
+    $(wildcard include/config/have/reliable/stacktrace.h) \
+  include/linux/stackdepot.h \
+  include/linux/page_ref.h \
+    $(wildcard include/config/debug/page/ref.h) \
+  include/linux/memremap.h \
+  include/linux/pgtable.h \
+    $(wildcard include/config/pgtable/levels.h) \
+    $(wildcard include/config/highpte.h) \
+    $(wildcard include/config/have/arch/transparent/hugepage/pud.h) \
+    $(wildcard include/config/have/arch/soft/dirty.h) \
+    $(wildcard include/config/arch/enable/thp/migration.h) \
+    $(wildcard include/config/x86/espfix64.h) \
+  arch/arm/include/asm/pgtable.h \
+  arch/arm/include/asm/proc-fns.h \
+    $(wildcard include/config/big/little.h) \
+    $(wildcard include/config/harden/branch/predictor.h) \
+  arch/arm/include/asm/glue-proc.h \
+    $(wildcard include/config/cpu/arm7tdmi.h) \
+    $(wildcard include/config/cpu/arm720t.h) \
+    $(wildcard include/config/cpu/arm740t.h) \
+    $(wildcard include/config/cpu/arm9tdmi.h) \
+    $(wildcard include/config/cpu/arm920t.h) \
+    $(wildcard include/config/cpu/arm922t.h) \
+    $(wildcard include/config/cpu/arm925t.h) \
+    $(wildcard include/config/cpu/arm926t.h) \
+    $(wildcard include/config/cpu/arm940t.h) \
+    $(wildcard include/config/cpu/arm946e.h) \
+    $(wildcard include/config/cpu/arm1020.h) \
+    $(wildcard include/config/cpu/arm1020e.h) \
+    $(wildcard include/config/cpu/arm1022.h) \
+    $(wildcard include/config/cpu/arm1026.h) \
+    $(wildcard include/config/cpu/mohawk.h) \
+    $(wildcard include/config/cpu/feroceon.h) \
+    $(wildcard include/config/cpu/v6k.h) \
+    $(wildcard include/config/cpu/pj4b.h) \
+    $(wildcard include/config/cpu/v7.h) \
+  include/asm-generic/pgtable-nopud.h \
+  include/asm-generic/pgtable-nop4d.h \
+  arch/arm/include/asm/pgtable-hwdef.h \
+  arch/arm/include/asm/pgtable-2level-hwdef.h \
+  arch/arm/include/asm/tlbflush.h \
+    $(wildcard include/config/smp/on/up.h) \
+    $(wildcard include/config/cpu/tlb/v4wt.h) \
+    $(wildcard include/config/cpu/tlb/fa.h) \
+    $(wildcard include/config/cpu/tlb/v4wbi.h) \
+    $(wildcard include/config/cpu/tlb/feroceon.h) \
+    $(wildcard include/config/cpu/tlb/v4wb.h) \
+    $(wildcard include/config/cpu/tlb/v6.h) \
+    $(wildcard include/config/cpu/tlb/v7.h) \
+    $(wildcard include/config/arm/errata/720789.h) \
+    $(wildcard include/config/arm/errata/798181.h) \
+  arch/arm/include/asm/pgtable-2level.h \
+  include/asm-generic/pgtable_uffd.h \
+    $(wildcard include/config/have/arch/userfaultfd/wp.h) \
+  include/linux/huge_mm.h \
+  include/linux/sched/coredump.h \
+    $(wildcard include/config/core/dump/default/elf/headers.h) \
+  include/linux/vmstat.h \
+    $(wildcard include/config/vm/event/counters.h) \
+    $(wildcard include/config/debug/tlbflush.h) \
+    $(wildcard include/config/debug/vm/vmacache.h) \
+  include/linux/vm_event_item.h \
+    $(wildcard include/config/memory/balloon.h) \
+    $(wildcard include/config/balloon/compaction.h) \
+  include/linux/highmem.h \
+    $(wildcard include/config/x86/32.h) \
+    $(wildcard include/config/debug/highmem.h) \
+  arch/arm/include/asm/cacheflush.h \
+    $(wildcard include/config/arm/errata/411920.h) \
+    $(wildcard include/config/cpu/cache/vipt.h) \
+    $(wildcard include/config/outer/cache.h) \
+    $(wildcard include/config/frame/pointer.h) \
+    $(wildcard include/config/cpu/icache/mismatch/workaround.h) \
+  arch/arm/include/asm/glue-cache.h \
+    $(wildcard include/config/cpu/cache/v4.h) \
+    $(wildcard include/config/cpu/cache/v4wb.h) \
+    $(wildcard include/config/cache/b15/rac.h) \
+  arch/arm/include/asm/cachetype.h \
+    $(wildcard include/config/cpu/cache/vivt.h) \
+  arch/arm/include/asm/outercache.h \
+    $(wildcard include/config/outer/cache/sync.h) \
+  arch/arm/include/asm/kmap_types.h \
+  include/linux/hugetlb_inline.h \
+  include/linux/proc_fs.h \
+    $(wildcard include/config/proc/pid/arch/status.h) \
+  include/linux/kallsyms.h \
+    $(wildcard include/config/kallsyms/all.h) \
+  include/linux/of_gpio.h \
+  include/generated/uapi/linux/version.h \
+  include/linux/rtc.h \
+    $(wildcard include/config/rtc/intf/dev/uie/emul.h) \
+    $(wildcard include/config/rtc/hctosys/device.h) \
+    $(wildcard include/config/rtc/nvmem.h) \
+    $(wildcard include/config/rtc/intf/sysfs.h) \
+  include/linux/nvmem-provider.h \
+    $(wildcard include/config/nvmem.h) \
+  include/uapi/linux/rtc.h \
+  include/linux/cdev.h \
+  include/linux/poll.h \
+  include/uapi/linux/poll.h \
+  arch/arm/include/generated/uapi/asm/poll.h \
+  include/uapi/asm-generic/poll.h \
+  include/uapi/linux/eventpoll.h \
+  include/linux/fb.h \
+    $(wildcard include/config/gumstix/am200epd.h) \
+    $(wildcard include/config/fb/notify.h) \
+    $(wildcard include/config/fb/deferred/io.h) \
+    $(wildcard include/config/fb/tileblitting.h) \
+    $(wildcard include/config/fb/backlight.h) \
+    $(wildcard include/config/fb/foreign/endian.h) \
+    $(wildcard include/config/fb/both/endian.h) \
+    $(wildcard include/config/fb/big/endian.h) \
+    $(wildcard include/config/fb/little/endian.h) \
+  include/linux/kgdb.h \
+    $(wildcard include/config/have/arch/kgdb.h) \
+    $(wildcard include/config/kgdb.h) \
+    $(wildcard include/config/serial/kgdb/nmi.h) \
+    $(wildcard include/config/kgdb/honour/blocklist.h) \
+  include/linux/kprobes.h \
+    $(wildcard include/config/kretprobes.h) \
+    $(wildcard include/config/kprobes/sanity/test.h) \
+    $(wildcard include/config/optprobes.h) \
+    $(wildcard include/config/kprobes/on/ftrace.h) \
+  include/linux/ftrace.h \
+    $(wildcard include/config/function/tracer.h) \
+    $(wildcard include/config/dynamic/ftrace.h) \
+    $(wildcard include/config/dynamic/ftrace/with/regs.h) \
+    $(wildcard include/config/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/have/dynamic/ftrace/with/direct/calls.h) \
+    $(wildcard include/config/stack/tracer.h) \
+    $(wildcard include/config/function/profiler.h) \
+    $(wildcard include/config/ftrace/syscalls.h) \
+  include/linux/trace_clock.h \
+  arch/arm/include/generated/asm/trace_clock.h \
+  include/asm-generic/trace_clock.h \
+  include/linux/ptrace.h \
+  include/linux/pid_namespace.h \
+    $(wildcard include/config/pid/ns.h) \
+  include/linux/nsproxy.h \
+  include/linux/ns_common.h \
+  include/uapi/linux/ptrace.h \
+  arch/arm/include/asm/ftrace.h \
+  arch/arm/include/asm/kprobes.h \
+  include/asm-generic/kprobes.h \
+  arch/arm/include/asm/probes.h \
+  arch/arm/include/asm/kgdb.h \
+  include/uapi/linux/fb.h \
+  include/linux/backlight.h \
+    $(wildcard include/config/backlight/class/device.h) \
+  drivers/input/touchscreen/hxchipset/himax_ic_core.h \
+
+drivers/input/touchscreen/hxchipset/himax_self_test.o: $(deps_drivers/input/touchscreen/hxchipset/himax_self_test.o)
+
+$(deps_drivers/input/touchscreen/hxchipset/himax_self_test.o):
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.modules.order.cmd linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.modules.order.cmd
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/.modules.order.cmd	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/.modules.order.cmd	2024-06-14 10:43:31.775519389 +0200
@@ -0,0 +1 @@
+cmd_drivers/input/touchscreen/hxchipset/modules.order := {   echo drivers/input/touchscreen/hxchipset/himax_mmi.ko; :; } | awk '!x[$$0]++' - > drivers/input/touchscreen/hxchipset/modules.order
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/Kconfig linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/Kconfig
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/Kconfig	2024-06-14 10:43:31.775519389 +0200
@@ -0,0 +1,111 @@
+#
+# Himax Touchscreen driver configuration
+#
+
+config TOUCHSCREEN_HIMAX_COMMON
+		tristate "HIMAX chipset i2c touchscreen"
+		depends on TOUCHSCREEN_HIMAX_CHIPSET
+		depends on SPI
+		help
+		This enables support for HIMAX CHIPSET touchscreens.
+		Himax common is library for functions which IC use
+		Such as register read write function for common usage
+		Could be include when need common function.
+
+config TOUCHSCREEN_HIMAX_INCELL
+		bool "HIMAX chipset in-cell function"
+		depends on TOUCHSCREEN_HIMAX_COMMON
+		help
+		This enables support for HIMAX CHIPSET of in-cell function.
+		The purpose of this is to implement incell IC functions
+		which might be the same function for every different IC
+		INCELL files for doing INCELL IC functions
+
+config TOUCHSCREEN_HIMAX_IC_HX8530
+        tristate "HIMAX chipset HX8530 function"
+		depends on TOUCHSCREEN_HIMAX_CHIPSET
+		help
+		This enables support for HIMAX CHIPSET of HX8530.
+
+config TOUCHSCREEN_HIMAX_IC_HX83181
+        tristate "HIMAX chipset HX83181 function"
+		depends on TOUCHSCREEN_HIMAX_INCELL
+		help
+		This enables support for HIMAX CHIPSET of HX83181.
+		The purpose of this is to implement incell IC functions
+		which might be different like FW update or sense on off
+		and other IC flow
+
+config TOUCHSCREEN_HIMAX_IC_HX83180
+        tristate "HIMAX chipset HX83180 function"
+		depends on TOUCHSCREEN_HIMAX_INCELL
+		help
+		This enables support for HIMAX CHIPSET of HX83180.
+		The purpose of this is to implement incell IC functions
+		which might be different like FW update or sense on off
+		and other IC flow
+
+config TOUCHSCREEN_HIMAX_IC_HX83195
+		tristate "HIMAX chipset HX83195 function"
+		depends on TOUCHSCREEN_HIMAX_INCELL
+		help
+		This enables support for HIMAX CHIPSET of HX83195.
+		The purpose of this is to implement incell IC functions
+		which might be different like FW update or sense on off
+		and other IC flow
+
+config TOUCHSCREEN_HIMAX_IC_HX83194
+		tristate "HIMAX chipset HX83194 function"
+		depends on TOUCHSCREEN_HIMAX_INCELL
+		help
+		This enables support for HIMAX CHIPSET of HX83194.
+		The purpose of this is to implement incell IC functions
+		which might be different like FW update or sense on off
+		and other IC flow
+
+config TOUCHSCREEN_HIMAX_IC_HX83193
+		tristate "HIMAX chipset HX83193 function"
+		depends on TOUCHSCREEN_HIMAX_INCELL
+		help
+		This enables support for HIMAX CHIPSET of HX83193.
+		The purpose of this is to implement incell IC functions
+		which might be different like FW update or sense on off
+		and other IC flow
+
+config TOUCHSCREEN_HIMAX_IC_HX83192
+        tristate "HIMAX chipset HX83192 function"
+		depends on TOUCHSCREEN_HIMAX_INCELL
+		help
+		This enables support for HIMAX CHIPSET of HX83192.
+		The purpose of this is to implement incell IC functions
+		which might be different like FW update or sense on off
+		and other IC flow
+
+config TOUCHSCREEN_HIMAX_DEBUG
+		bool "HIMAX debug function"
+		depends on TOUCHSCREEN_HIMAX_INCELL
+		help
+		This enables support for HIMAX debug function.
+		The purpose of this is to implement IC debug functions
+		which enable node for user to use for debug usage
+		It's a debug function that could be open when need
+		using debug node to see debug message or manufactory
+		functions test
+
+config TOUCHSCREEN_HIMAX_SELF_TEST
+        bool "HIMAX self_test function"
+		depends on TOUCHSCREEN_HIMAX_INCELL
+		help
+		This enables support for HIMAX self test function.
+		The purpose of this is to implement IC to run self test
+		functions, there are several functions for IC self check
+		make a open/short check
+
+config TOUCHSCREEN_HIMAX_EMBEDDED_FIRMWARE
+	bool "HIMAX embedded firmware function"
+		depends on TOUCHSCREEN_HIMAX_INCELL
+		help
+		This enables built-in FW inside kernel as binary array
+		The purpose of this is to build in FW with binary header
+		array, let driver has it's own default FW code instead of
+		using flash FW
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/Makefile linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/Makefile
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/Makefile	2024-06-14 10:43:31.775519389 +0200
@@ -0,0 +1,77 @@
+# Makefile for the Himax touchscreen drivers.
+
+ifndef CONFIG_HIMAX_SUPPORT_KERNEL_419
+ifneq ($(filter y, $(CONFIG_FB)),)
+	ccflags-y += -DHX_CONFIG_FB
+endif
+
+ifneq ($(filter y, $(CONFIG_DRM)),)
+	ccflags-y += -DHX_CONFIG_DRM
+endif
+endif
+
+ifneq ($(filter m, $(CONFIG_TOUCHSCREEN_HIMAX_COMMON)),)
+  ccflags-y += -D__HIMAX_MOD__
+endif
+# obj-y += himax_modular_table.o
+
+ifneq ($(filter y m, $(CONFIG_TOUCHSCREEN_HIMAX_DEBUG)),)
+	himax_mmi-objs += himax_debug.o
+endif
+
+ifneq ($(filter y m, $(CONFIG_TOUCHSCREEN_HIMAX_SELF_TEST)),)
+	himax_mmi-objs += himax_self_test.o
+endif
+
+ifneq ($(filter y m, $(CONFIG_TOUCHSCREEN_HIMAX_INCELL)),)
+	himax_mmi-objs += himax_ic_incell_core.o
+endif
+
+
+ifneq ($(filter y m, $(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83192)),)
+  ccflags-y += -D__HIMAX_HX83192_MOD__
+	himax_mmi-objs += himax_ic_HX83192.o
+endif
+
+ifneq ($(filter y m, $(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83193)),)
+  ccflags-y += -D__HIMAX_HX83193_MOD__
+	himax_mmi-objs += himax_ic_HX83193.o
+endif
+
+ifneq ($(filter y m, $(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83194)),)
+  ccflags-y += -D__HIMAX_HX83194_MOD__
+	himax_mmi-objs += himax_ic_HX83194.o
+endif
+
+ifneq ($(filter y m, $(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83195)),)
+  ccflags-y += -D__HIMAX_HX83195_MOD__
+	himax_mmi-objs += himax_ic_HX83195.o
+endif
+
+ifneq ($(filter y m, $(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83180)),)
+  ccflags-y += -D__HIMAX_HX83180_MOD__
+	himax_mmi-objs += himax_ic_HX83180.o
+endif
+
+ifneq ($(filter y m, $(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83181)),)
+  ccflags-y += -D__HIMAX_HX83181_MOD__
+	himax_mmi-objs += himax_ic_HX83181.o
+endif
+
+ifneq ($(filter y m, $(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)),)
+  ccflags-y += -D__HIMAX_HX8530_MOD__
+	himax_mmi-objs += himax_ic_HX8530.o
+endif
+
+ifneq ($(filter m, $(CONFIG_TOUCHSCREEN_HIMAX_COMMON)),)
+  ccflags-y += -D__HIMAX_MOD__
+  himax_mmi-objs += himax_common.o
+  himax_mmi-objs += himax_platform.o
+  obj-m += himax_mmi.o
+endif
+ifneq ($(filter y, $(CONFIG_TOUCHSCREEN_HIMAX_COMMON)),)
+  himax_mmi-objs += himax_common.o
+  himax_mmi-objs += himax_platform.o
+  obj-y += himax_mmi.o
+endif
+
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/built-in.a linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/built-in.a
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/built-in.a	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/built-in.a	2024-06-14 10:43:31.775519389 +0200
@@ -0,0 +1 @@
+!<arch>
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_common.c linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_common.c
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_common.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_common.c	2024-06-14 10:43:31.778852722 +0200
@@ -0,0 +1,3502 @@
+// SPDX-License-Identifier: GPL-2.0
+/*  Himax Android Driver Sample Code for common functions
+ *
+ *  Copyright (C) 2024 Himax Corporation.
+ *
+ *  This software is licensed under the terms of the GNU General Public
+ *  License version 2,  as published by the Free Software Foundation,  and
+ *  may be copied,  distributed,  and modified under those terms.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+/*#include "himax_common.h"*/
+/*#include "himax_ic_core.h"*/
+#include "himax_self_test.h"
+
+/*------------------------- define block -------------------------------------*/
+/*------------------------- define block -------------------------------------*/
+/*------------------------- parameter block ----------------------------------*/
+
+#if (HX_SMART_WAKEUP == 0x01) || (HX_TP_GTS_MODE == 0x01)
+	static bool HX_PROC_SEND_FLAG;
+#endif
+
+static uint8_t HX_TOUCH_INFO_POINT_CNT;
+static uint8_t AA_press;
+static int probe_fail_flag;
+
+#if (HX_GESTURE_TRACK == 0x01)
+	static uint16_t gest_pt_cnt;
+	static uint16_t gest_pt_x[GEST_PT_MAX_NUM];
+	static uint16_t gest_pt_y[GEST_PT_MAX_NUM];
+	static uint16_t gest_start_x, gest_start_y, gest_end_x, gest_end_y;
+	static uint16_t gest_width, gest_height;
+	static uint16_t gest_mid_x, gest_mid_y;
+	static uint16_t hx_gesture_coor[16];
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_SELF_TEST)
+	static bool chip_test_r_flag;
+#endif
+
+bool		g_hx_chip_inited;
+EXPORT_SYMBOL(g_hx_chip_inited);
+
+uint8_t		g_mmi_refcnt;
+EXPORT_SYMBOL(g_mmi_refcnt);
+
+int			g_ts_dbg;
+EXPORT_SYMBOL(g_ts_dbg);
+
+#if (HX_BOOT_UPGRADE == 0x01)
+	bool g_boot_upgrade_flag;
+	const struct firmware *hxfw;
+	uint16_t g_i_FW_VER;
+	uint16_t g_i_CFG_VER;
+	uint8_t g_i_CID_MAJ; /*GUEST ID*/
+	uint8_t g_i_CID_MIN; /*VER for GUEST*/
+#endif
+
+#if (HX_EXCP_RECOVERY == 0x01)
+	bool HX_EXCP_RESET_ACTIVATE;
+	int g_zero_event_count;
+#endif
+
+#if (HX_TP_INSPECT_MODE == 0x01)
+	uint8_t inspect_mode_flag;
+#endif
+
+#if (HX_SMART_WAKEUP == 0x01)
+	uint8_t gest_event[GEST_SUP_NUM] = { 0x80, 0x90 };
+	/*gest_event mapping to gest_key_def*/
+	uint16_t gest_key_def[GEST_SUP_NUM] = { HX_KEY_DOUBLE_CLICK,
+						HX_KEY_SINGLE_CLICK };
+	uint8_t *wake_event_buffer;
+#endif
+
+/*------------------------- parameter block ----------------------------------*/
+/*------------------------- structure block ----------------------------------*/
+#if (HX_TP_INSPECT_MODE == 0x01)
+	struct proc_dir_entry *himax_proc_INSPECT_MODE_file;
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_SELF_TEST)
+	static struct proc_dir_entry *himax_proc_self_test_file;
+#endif
+
+#if (HX_TP_GTS_MODE == 0x01)
+	struct proc_dir_entry *himax_proc_GTS_file;
+#endif
+
+#if (HX_SMART_WAKEUP == 0x01)
+	static struct proc_dir_entry *himax_proc_GESTURE_file;
+#endif
+
+struct himax_ts_data *private_ts;
+EXPORT_SYMBOL(private_ts);
+
+struct himax_ic_data *ic_data;
+EXPORT_SYMBOL(ic_data);
+
+struct himax_report_data *hx_touch_data;
+EXPORT_SYMBOL(hx_touch_data);
+
+struct himax_debug *debug_data;
+EXPORT_SYMBOL(debug_data);
+
+struct proc_dir_entry *himax_touch_proc_dir;
+EXPORT_SYMBOL(himax_touch_proc_dir);
+
+struct himax_target_report_data *g_target_report_data;
+EXPORT_SYMBOL(g_target_report_data);
+
+struct himax_core_fp g_core_fp;
+EXPORT_SYMBOL(g_core_fp);
+#if (HX_TP_GTS_MODE == 0x01)
+static struct himax_target_report_data *fixed_point_label;
+#endif
+static struct proc_dir_entry *himax_proc_WPBPlock_node_file;
+static struct proc_dir_entry *himax_proc_fail_det_file;
+
+/*------------------------- structure block ----------------------------------*/
+
+#if defined(KERNEL_VER_5_10)
+struct timespec64 time_diff(struct timespec64 start, struct timespec64 end)
+{
+	struct timespec64 delta;
+#else
+struct timespec time_diff(struct timespec start, struct timespec end)
+{
+	struct timespec delta;
+#endif
+	if ((end.tv_nsec - start.tv_nsec) < 0) {
+		delta.tv_sec = end.tv_sec - start.tv_sec - 1;
+		delta.tv_nsec = 1000000000 + end.tv_nsec - start.tv_nsec;
+	} else {
+		delta.tv_sec = end.tv_sec - start.tv_sec;
+		delta.tv_nsec = end.tv_nsec - start.tv_nsec;
+	}
+	return delta;
+}
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_SELF_TEST)
+ssize_t himax_self_test(struct seq_file *s, void *v)
+{
+	ssize_t ret = 0;
+
+	I("%s: enter, %d\n", __func__, __LINE__);
+
+	if (private_ts->suspended == 1) {
+		E("%s: please do self test in normal active mode\n", __func__);
+		return HX_FAIL;
+	}
+	himax_int_enable(0); /* disable irq */
+
+	private_ts->in_self_test = 1;
+
+	himax_chip_self_test(s, v);
+
+	private_ts->in_self_test = 0;
+
+#if (HX_EXCP_RECOVERY == 0x01)
+	HX_EXCP_RESET_ACTIVATE = true;
+#endif
+	himax_int_enable(1);
+
+	return ret;
+}
+
+int himax_self_test_show(struct seq_file *s, void *v)
+{
+	ssize_t ret = 0;
+
+	if (chip_test_r_flag) {
+		if (g_rslt_data != NULL) {
+			seq_printf(s, "%s", g_rslt_data);
+		} else {
+			seq_puts(s, "No chip test data.\n");
+		}
+	} else {
+		ret = himax_self_test(s, v);
+	}
+
+	return ret;
+}
+
+ssize_t himax_self_test_store(struct file *filp,
+				      const char __user *buff, size_t len,
+				      loff_t *data)
+{
+	char buf[80];
+	unsigned int i;
+	bool flag = false;
+
+	UNUSED(filp);
+	UNUSED(data);
+
+	if (len >= 80U) {
+		I("%s: no command exceeds 80 chars.\n", __func__);
+		return -EFAULT;
+	}
+
+	if (copy_from_user(buf, buff, len) != 0) {
+		return -EFAULT;
+	}
+
+	if (buf[0] == 'r') {
+		chip_test_r_flag = true;
+		I("%s: Start to read chip test data.\n", __func__);
+	} else {
+		chip_test_r_flag = false;
+		I("%s: Back to do self test.\n", __func__);
+	}
+
+
+	if (len > 4U) {
+
+		for (i = 2; i < len; i++) {
+			if ((buf[i - 2U] == 'c') && (buf[i - 1U] == 's') && (buf[i] == 'v')) {
+				flag = true;
+			}
+		}
+		if (flag) {
+			(void)memset(private_ts->self_test_file_ch, 0, sizeof(private_ts->self_test_file_ch));
+			(void)memcpy(private_ts->self_test_file_ch, buf, len - 1U);	/* remove last eol */
+			I("%s: Start to set self test file as name |%s|.\n", __func__, private_ts->self_test_file_ch);
+		}
+	}
+
+	if ((buf[0] == 'M') && (buf[1] == 'P') && (buf[2] == 'A') && (buf[3] == 'P')
+	&& (buf[4] == '_') && ((buf[5] == 'E') || (buf[5] == 'e'))) {
+		I("%s: MPAP test enable.\n", __func__);
+		private_ts->chip_test_mpap_flag = true;
+	}
+	if ((buf[0] == 'M') && (buf[1] == 'P') && (buf[2] == 'A') && (buf[3] == 'P')
+	&& (buf[4] == '_') && ((buf[5] == 'D') || (buf[5] == 'd'))) {
+		I("%s: MPAP test disable.\n", __func__);
+		private_ts->chip_test_mpap_flag = false;
+	}
+
+
+	return len;
+}
+int himax_self_test_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_self_test_show, NULL);
+}
+
+const struct proc_ops_name himax_self_test_ops = {
+	owner_line
+	.proc_op(open) = himax_self_test_open,
+	.proc_op(write) = himax_self_test_store,
+	.proc_op(read) = seq_read,
+	.proc_opl(lseek) = seq_lseek,
+	.proc_op(release) = single_release,
+};
+#endif
+
+static int himax_WPBPlock_node_show(struct seq_file *s, void *v)
+{
+	ssize_t ret = 0;
+	int status;
+
+	UNUSED(v);
+	status = himax_mcu_WP_BP_status();
+
+	if (status == HX_LOCK) {
+		seq_puts(s, "WP BP value & lock status is lock\n");
+	} else if (status == HX_UNLOCK) {
+		seq_puts(s, "WP BP lock status is unlock\n");
+	} else {
+		seq_puts(s, "Can't recognize flash id\n");
+	}
+
+	return ret;
+}
+
+ssize_t himax_WPBPlock_node_store(struct file *filp,
+				      const char __user *buff, size_t len,
+				      loff_t *data)
+{
+	char buf[80];
+	ssize_t result = 0;
+
+	UNUSED(filp);
+	UNUSED(data);
+
+	if (len >= 80U) {
+		I("%s: no command exceeds 80 chars.\n", __func__);
+		result = -EFAULT;
+	} else if (copy_from_user(buf, buff, len) != 0) {
+		result = -EFAULT;
+	} else if ((buf[0] == 'd') || (buf[0] == 'D')) {
+		I("%s: Start to disable BP lock.\n", __func__);
+		himax_disable_flash_protected_mode();
+		result = (ssize_t) len;
+	} else if ((buf[0] == 'e') || (buf[0] == 'E')) {
+		I("%s: Start to enable BP lock.\n", __func__);
+		himax_enable_flash_protected_mode();
+		result = (ssize_t) len;
+	} else {
+		I("%s: Input cmd is incorrect!\n", __func__);
+		result = -EFAULT;
+	}
+
+	return result;
+}
+
+int himax_WPBPlock_node_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_WPBPlock_node_show, NULL);
+}
+
+const struct proc_ops_name himax_WPBPlock_node_ops = {
+	owner_line
+	.proc_op(open) = himax_WPBPlock_node_open,
+	.proc_op(write) = himax_WPBPlock_node_store,
+	.proc_op(read) = seq_read,
+	.proc_opl(lseek) = seq_lseek,
+	.proc_op(release) = single_release,
+};
+
+#define PA_LOG_1                                                               \
+	"%s:para[1]=0x%02X, para[2]=0x%02X, para[3]=0x%02X, para[4]=0x%02X\n"
+#define PA_LOG_2                                                               \
+	"%s:para[5]=0x%02X, para[6]=0x%02X, para[7]=0x%02X\n"
+#define PA_LOG_3                                                               \
+	"%s:para[5]=0x%02X, para[6]=0x%02X, para[7]=0x%02X, para[8]=0x%02X\n"
+#define PA_LOG_4                                                               \
+	"%s:para[9]=0x%02X, para[10]=0x%02X, para[11]=0x%02X, para[12]=0x%02X\n"
+#define PA_LOG_5                                                               \
+	"%s:para[13]=0x%02X, para[14]=0x%02X, para[15]=0x%02X, para[16]=0x%02X\n"
+#define PA_LOG_6                                                               \
+	"%s:para[17]=0x%02X, para[18]=0x%02X, para[19]=0x%02X, para[20]=0x%02X\n"
+#define PA_LOG_7                                                               \
+	"%s:para[21]=0x%02X\n"
+int himax_fail_det_show(struct seq_file *s, void *v)
+{
+	ssize_t ret = 0;
+	uint8_t data[30] = { 0 };
+
+	UNUSED(v);
+
+	himax_mcu_write_dd_reg_password(IC_MASTER);
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83195)
+	himax_mcu_dd_reg_read(0xE5, 0, 10, &data[0], 0, IC_MASTER);
+	himax_mcu_dd_reg_read(0xE5, 10, 10, &data[10], 0, IC_MASTER);
+	himax_mcu_dd_reg_read(0xE5, 20, 2, &data[20], 0, IC_MASTER);
+	seq_printf(s, PA_LOG_1, "E5_Bank0:", data[1], data[2], data[3], data[4]);
+	seq_printf(s, PA_LOG_3, "E5_Bank0:", data[5], data[6], data[7], data[8]);
+	seq_printf(s, PA_LOG_4, "E5_Bank0:", data[9], data[10], data[11], data[12]);
+	seq_printf(s, PA_LOG_5, "E5_Bank0:", data[13], data[14], data[15], data[16]);
+	seq_printf(s, PA_LOG_6, "E5_Bank0:", data[17], data[18], data[19], data[20]);
+	seq_printf(s, PA_LOG_7, "E5_Bank0:", data[21]);
+
+	himax_mcu_dd_reg_read(0xE5, 0, 10, &data[0], 4, IC_MASTER);
+	himax_mcu_dd_reg_read(0xE5, 10, 10, &data[10], 4, IC_MASTER);
+	himax_mcu_dd_reg_read(0xE5, 20, 1, &data[20], 4, IC_MASTER);
+	seq_printf(s, PA_LOG_1, "E5_Bank1:", data[1], data[2], data[3], data[4]);
+	seq_printf(s, PA_LOG_3, "E5_Bank1:", data[5], data[6], data[7], data[8]);
+	seq_printf(s, PA_LOG_4, "E5_Bank1:", data[9], data[10], data[11], data[12]);
+	seq_printf(s, PA_LOG_5, "E5_Bank1:", data[13], data[14], data[15], data[16]);
+	seq_printf(s, PA_LOG_6, "E5_Bank1:", data[17], data[18], data[19], data[20]);
+#else
+	himax_mcu_dd_reg_read(0xE5, 0, 8, data, 0, IC_MASTER);
+	seq_printf(s, PA_LOG_1, "E5_Bank0:", data[1], data[2], data[3], data[4]);
+	seq_printf(s, PA_LOG_2, "E5_Bank0:", data[5], data[6], data[7]);
+
+	himax_mcu_dd_reg_read(0xE5, 0, 8, data, 4, IC_MASTER);
+	seq_printf(s, PA_LOG_1, "E5_Bank1:", data[1], data[2], data[3], data[4]);
+	seq_printf(s, PA_LOG_2, "E5_Bank1:", data[5], data[6], data[7]);
+
+	himax_mcu_dd_reg_read(0xE5, 0, 8, data, 12, IC_MASTER);
+	seq_printf(s, PA_LOG_1, "E5_Bank3:", data[1], data[2], data[3], data[4]);
+	seq_printf(s, PA_LOG_2, "E5_Bank3:", data[5], data[6], data[7]);
+#endif
+
+	himax_mcu_clear_dd_reg_password(IC_MASTER);
+
+	himax_mcu_register_read(addr_fail_det_GPIO1_msg, DATA_LEN_4, data);
+	I(TEMP_LOG, __func__, "0x100074C0", data[0], data[1], data[2], data[3]);
+	seq_printf(s, TEMP_LOG, __func__, "0x100074C0",
+		data[0], data[1], data[2], data[3]);
+
+	return ret;
+}
+
+ssize_t himax_fail_det_store(struct file *filp,
+				      const char __user *buff, size_t len,
+				      loff_t *data)
+{
+	/*not implement write function*/
+	char buf[80];
+	uint8_t tmp_data[4] = { 0 };
+	ssize_t result = 0;
+
+	UNUSED(filp);
+	UNUSED(data);
+
+	if (len >= 80U) {
+		I("%s: no command exceeds 80 chars.\n", __func__);
+		result = -EFAULT;
+	} else if (copy_from_user(buf, buff, len) != 0) {
+		result = -EFAULT;
+	} else if ((buf[0] == 'c') || (buf[0] == 'C')) {
+		I("%s: now clear E5 Bank3 value.\n", __func__);
+		himax_mcu_write_dd_reg_password(IC_MASTER);
+
+		himax_mcu_dd_reg_read(0xE5, 0, 4, tmp_data, 0, IC_MASTER);
+		I("0xE5 Bank0 pa1: data[0] = 0x%2.2x, data[1] = 0x%2.2x, data[2] = 0x%2.2x, data[3] = 0x%2.2x.\n",
+		  tmp_data[0], tmp_data[1], tmp_data[2], tmp_data[3]);
+
+		tmp_data[0] = 0x03;
+		himax_mcu_dd_reg_write(0xE5, 1, 1, tmp_data, 0, IC_MASTER);
+
+		tmp_data[0] = 0x00;
+		himax_mcu_dd_reg_read(0xE5, 0, 4, tmp_data, 0, IC_MASTER);
+		I("0xE5 Bank0 pa1: data[0] = 0x%2.2x, data[1] = 0x%2.2x, data[2] = 0x%2.2x, data[3] = 0x%2.2x.\n",
+		  tmp_data[0], tmp_data[1], tmp_data[2], tmp_data[3]);
+
+		himax_mcu_clear_dd_reg_password(IC_MASTER);
+		result = (int) len;
+	} else {
+		/* do nothing*/
+	}
+
+	return result;
+}
+
+int himax_fail_det_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_fail_det_show, NULL);
+}
+
+const struct proc_ops_name himax_fail_det_ops = {
+	owner_line
+	.proc_op(open) = himax_fail_det_open,
+	.proc_op(write) = himax_fail_det_store,
+	.proc_op(read) = seq_read,
+	.proc_opl(lseek) = seq_lseek,
+	.proc_op(release) = single_release,
+};
+
+#if (HX_TP_INSPECT_MODE == 0x01)
+static void himax_chip_inspect_mode(struct seq_file *s, void *v)
+{
+	uint32_t tmp_addr_32 = 0;
+	uint32_t addr_stack_depth = 0x8006000CU;
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	uint8_t buf[64] = { 0 };
+	uint16_t cnt = 0;
+	bool is_done = false;
+	uint16_t tmp_value = 0;
+	int16_t Min_value = 0;
+	uint16_t Max_value = 0;
+	uint16_t Short_lower_bound = 0;
+	uint16_t Short_upper_bound = 0;
+	uint16_t Open_lower_bound = 0;
+	uint16_t Open_upper_bound = 0;
+	uint16_t Noise_lower_bound = 0;
+	uint16_t Noise_upper_bound = 0;
+	struct time_var timeStart;
+	struct time_var timeEnd;
+	struct time_var timeDelta;
+	int ret = NO_ERR;
+
+	UNUSED(v);
+
+	switch (inspect_mode_flag) {
+	case 0x01: /*Start to do Short_test*/
+		tmp_data[3] = 0x5A;
+		tmp_data[2] = 0x00;
+		tmp_data[1] = 0x01;
+		tmp_data[0] = 0xA5;
+		seq_puts(s, "Item : Short_test.\n");
+		break;
+	case 0x02: /*Start to do Open_test*/
+		tmp_data[3] = 0x5A;
+		tmp_data[2] = 0x00;
+		tmp_data[1] = 0x02;
+		tmp_data[0] = 0xA4;
+		seq_puts(s, "Item : Open_test.\n");
+		break;
+	case 0x08: /*Start to do Noise_test*/
+		tmp_data[3] = 0x5A;
+		tmp_data[2] = 0x00;
+		tmp_data[1] = 0x08;
+		tmp_data[0] = 0x9E;
+		seq_puts(s, "Item : Noise_test.\n");
+		break;
+	case 0x0B: /*Start to do All_test*/
+		tmp_data[3] = 0x5A;
+		tmp_data[2] = 0x00;
+		tmp_data[1] = 0x0B;
+		tmp_data[0] = 0x9B;
+		seq_puts(s, "Item : All_test.\n");
+		break;
+	default:
+		seq_puts(s, "Input cmd is incorrect.\n");
+		ret = HX_FAIL;
+		break;
+	}
+	time_func(&timeStart);
+
+	if (ret == NO_ERR) {
+		himax_mcu_config_reload_disable();
+		himax_set_BS_UDT_frame(HX_INSPECT_MODE);
+
+		usleep_range(20000, 21000);
+
+		himax_mcu_register_write(addr_inspect_mode, DATA_LEN_4, tmp_data);
+		himax_mcu_register_read(addr_inspect_mode, DATA_LEN_4, tmp_data);
+
+		I("Now register =0x%02X, 0x%02X, 0x%02X, 0x%02X\n", tmp_data[3],
+		  tmp_data[2], tmp_data[1], tmp_data[0]);
+
+		cnt = 0;
+
+		while (cnt < 100U) {
+			himax_mcu_register_read(addr_inspect_mode, DATA_LEN_4, tmp_data);
+			usleep_range(20000, 21000);
+			I("%s : Current Status = 0x%02X\n", __func__, tmp_data[3]);
+			if (tmp_data[3] == 0xA5U) {
+				break;
+			}
+			cnt += 1U;
+		}
+		I("%s : Waiting for Inspect mode , loop conut = %d\n", __func__, cnt);
+		if (tmp_data[3] != 0xA5U) {
+			I("%s : Fail Status = 0x%02X, 0x%02X, 0x%02X, 0x%02X\n", __func__,
+			tmp_data[3], tmp_data[2], tmp_data[1], tmp_data[0]);
+			seq_puts(s, "FW not support Inspect mode.\n");
+			ret = HX_FAIL;
+		}
+	}
+
+	if (ret == NO_ERR) {
+		cnt = 0;
+
+		while (cnt < 600U) {
+			usleep_range(20000, 21000);
+			himax_mcu_register_read(addr_stack_depth, DATA_LEN_4, tmp_data);
+			if (tmp_data[0] == 0x28U) {
+				is_done = true;
+				break;
+			}
+			cnt += 1U;
+		}
+		I("%s : stack depth 0x%02X , loop conut %d\n", __func__, tmp_data[0],
+		  cnt);
+		himax_mcu_config_reload_enable();
+
+		is_done = himax_mcu_read_event_stack(buf, 40);
+
+		I("%s : %s = 0x%02X, 0x%02X, 0x%02X, 0x%02X , loop conut %d\n",
+		  __func__, "Stack result", buf[0], buf[1], buf[2], buf[3], cnt);
+
+		time_func(&timeEnd);
+		timeDelta = time_diff(timeStart, timeEnd);
+#if defined(KERNEL_VER_5_10)
+		seq_printf(s, "\tDuration :  %lld.%ld s\n", timeDelta.tv_sec, timeDelta.tv_nsec);
+#else
+		seq_printf(s, "\tDuration :  %ld.%ld s\n", timeDelta.tv_sec, timeDelta.tv_nsec);
+#endif
+	}
+
+	if (is_done) {
+		tmp_addr_32 = 0x100074A0U;
+		himax_mcu_register_read(tmp_addr_32, DATA_LEN_4, tmp_data);
+		Short_lower_bound = tmp_data[1];
+		Short_lower_bound = (Short_lower_bound << 8U) + tmp_data[0];
+		Short_upper_bound = tmp_data[3];
+		Short_upper_bound = (Short_upper_bound << 8U) + tmp_data[2];
+		tmp_addr_32 = 0x100074A4U;
+		himax_mcu_register_read(tmp_addr_32, DATA_LEN_4, tmp_data);
+		Open_lower_bound = tmp_data[1];
+		Open_lower_bound = (Open_lower_bound << 8U) + tmp_data[0];
+		Open_upper_bound = tmp_data[3];
+		Open_upper_bound = (Open_upper_bound << 8U) + tmp_data[2];
+		tmp_addr_32 = 0x100074ACU;
+		himax_mcu_register_read(tmp_addr_32, DATA_LEN_4, tmp_data);
+		Noise_lower_bound = tmp_data[1];
+		Noise_lower_bound = (Noise_lower_bound << 8U) + tmp_data[0];
+		Noise_upper_bound = tmp_data[3];
+		Noise_upper_bound = (Noise_upper_bound << 8U) + tmp_data[2];
+
+		if (buf[3] == 0x01U) {
+			switch (inspect_mode_flag) {
+			case 0x01:
+				seq_printf(s, "\tShort Test : %s\n",
+					   ((buf[7] & 0x01U) == 0x01U) ? "Fail" :
+									     "Pass");
+				tmp_value = buf[14];
+				tmp_value = (tmp_value << 8U) + buf[15];
+				Min_value = (int16_t)tmp_value;
+				Max_value = buf[12];
+				Max_value = (Max_value << 8U) + buf[13];
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Short Max. / Min.",
+					   Max_value,
+					   Min_value);
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Short Upper. / Lower. bound",
+					   Short_upper_bound,
+					   Short_lower_bound);
+				break;
+			case 0x02:
+				seq_printf(s, "\tOpen  Test : %s\n",
+					   ((buf[7] & 0x02U) == 0x02U) ? "Fail" :
+									     "Pass");
+				tmp_value = buf[18];
+				tmp_value = (tmp_value << 8U) + buf[19];
+				Min_value = (int16_t)tmp_value;
+				Max_value = buf[16];
+				Max_value = (Max_value << 8U) + buf[17];
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Open  Max. / Min.",
+					   Max_value,
+					   Min_value);
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Open  Upper. / Lower. bound",
+					   Open_upper_bound,
+					   Open_lower_bound);
+				break;
+			case 0x08:
+				seq_printf(s, "\tNoise Test : %s\n",
+					   ((buf[7] & 0x08U) == 0x08U) ? "Fail" :
+									     "Pass");
+				tmp_value = buf[26];
+				tmp_value = (tmp_value << 8U) + buf[27];
+				Min_value = (int16_t)tmp_value;
+				Max_value = buf[24];
+				Max_value = (Max_value << 8U) + buf[25];
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Noise Max. / Min.",
+					   Max_value,
+					   Min_value);
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Noise Upper. / Lower. bound",
+					   Noise_upper_bound,
+					   Noise_lower_bound);
+				break;
+			case 0x0B: /*Start to do All_test*/
+				seq_printf(s, "\tShort Test : %s\n",
+					   ((buf[7] & 0x01U) == 0x01U) ? "Fail" :
+									     "Pass");
+				seq_printf(s, "\tOpen  Test : %s\n",
+					   ((buf[7] & 0x02U) == 0x02U) ? "Fail" :
+									     "Pass");
+				seq_printf(s, "\tNoise Test : %s\n",
+					   ((buf[7] & 0x08U) == 0x08U) ? "Fail" :
+									     "Pass");
+				tmp_value = buf[14];
+				tmp_value = (tmp_value << 8U) + buf[15];
+				Min_value = (int16_t)tmp_value;
+				Max_value = buf[12];
+				Max_value = (Max_value << 8U) + buf[13];
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Short Max. / Min.",
+					   Max_value,
+					   Min_value);
+				tmp_value = buf[18];
+				tmp_value = (tmp_value << 8U) + buf[19];
+				Min_value = (int16_t)tmp_value;
+				Max_value = buf[16];
+				Max_value = (Max_value << 8U) + buf[17];
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Open  Max. / Min.",
+					   Max_value,
+					   Min_value);
+				tmp_value = buf[26];
+				tmp_value = (tmp_value << 8U) + buf[27];
+				Min_value = (int16_t)tmp_value;
+				Max_value = buf[24];
+				Max_value = (Max_value << 8U) + buf[25];
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Noise Max. / Min.",
+					   Max_value,
+					   Min_value);
+
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Short Upper. / Lower. bound",
+					   Short_upper_bound,
+					   Short_lower_bound);
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Open  Upper. / Lower. bound",
+					   Open_upper_bound,
+					   Open_lower_bound);
+				seq_printf(s, "\t%s = %5d / %5d\n",
+					   "Noise Upper. / Lower. bound",
+					   Noise_upper_bound,
+					   Noise_lower_bound);
+				break;
+			default:
+				seq_puts(s, "Input cmd is incorrect.\n");
+				break;
+			}
+		} else if (buf[3] == 0x10U) {
+			seq_printf(s, "%s\n", "Self Test command error.");
+		} else if (buf[3] == 0x20U) {
+			seq_printf(s, "%s\n", "Self Test command CRC error.");
+		} else {
+			/* do nothing*/
+		}
+
+		I("%s = 0x%02X, 0x%02X, 0x%02X, 0x%02X\n", "Test Result",
+		  buf[4], buf[5], buf[6], buf[7]);
+		I("%s = 0x%02X, 0x%02X, 0x%02X, 0x%02X\n", "Result Information",
+		  buf[8], buf[9], buf[10], buf[11]);
+
+	} else {
+		seq_puts(
+			s,
+			"[ERROR] Inspect Mode Suspended! Please check if FW support it!\n");
+	}
+
+}
+
+static ssize_t himax_inspect_mode(struct seq_file *s, void *v)
+{
+	ssize_t ret = 0;
+
+	I("%s: enter, %d\n", __func__, __LINE__);
+
+	if (private_ts->suspended == 1) {
+		E("%s: please do self test in normal active mode\n", __func__);
+		ret = HX_FAIL;
+	} else if (inspect_mode_flag == 0x0FU) { /*User Call HELP!*/
+		seq_puts(s, "\n");
+		seq_printf(s, "@ Short Test : %s\n",
+			   "#echo Short > Inspect_mode ; #cat Inspect_mode");
+		seq_printf(s, "@ Open  Test : %s\n",
+			   "#echo Open  > Inspect_mode ; #cat Inspect_mode");
+		seq_printf(s, "@ Noise Test : %s\n",
+			   "#echo Noise > Inspect_mode ; #cat Inspect_mode");
+		seq_printf(s, "@ All Test   : %s\n",
+			   "#echo All   > Inspect_mode ; #cat Inspect_mode");
+		seq_puts(s, "\n");
+		seq_puts(
+			s,
+			"@ Set Inspect_mode Threshold by writing register :\n");
+		seq_puts(
+			s,
+			"	Address    |  Threshold Item |    [31:16]    |    [15:0]\n");
+		seq_puts(
+			s,
+			"	0x100074A0 |  Short Test     | High Boundary | Low Boundary\n");
+		seq_puts(
+			s,
+			"	0x100074A4 |  Open Test      | High Boundary | Low Boundary\n");
+		seq_puts(
+			s,
+			"	0x100074AC |  Noise Test     | High Boundary | Low Boundary\n");
+		seq_puts(
+			s,
+			"	0x100074B0 |  Raw data       | High Boundary | Low Boundary\n");
+		seq_puts(s, "\n");
+		seq_puts(
+			s,
+			"Example : To set High Boundary = 0xFF ; Low Boundary = 0x11\n");
+		seq_puts(s, "#echo register,w:x100074A4:x00FF0011 > debug\n");
+		seq_puts(s, "\n");
+	} else {
+		himax_int_enable(0); /* disable irq */
+		himax_chip_inspect_mode(s, v);
+		himax_int_enable(1);
+	}
+
+	return ret;
+}
+
+int himax_inspect_mode_show(struct seq_file *s, void *v)
+{
+	ssize_t ret = 0;
+
+	ret = himax_inspect_mode(s, v);
+
+	return ret;
+}
+
+ssize_t himax_inspect_mode_store(struct file *filp,
+				      const char __user *buff, size_t len,
+				      loff_t *data)
+{
+	char buf[80];
+	size_t len_tmp = len;
+	ssize_t ret = (ssize_t) len_tmp;
+
+	UNUSED(filp);
+	UNUSED(data);
+
+	if (len >= 80U) {
+		I("%s: no command exceeds 80 chars.\n", __func__);
+		ret = -EFAULT;
+	} else if (copy_from_user(buf, buff, len) != 0) {
+		ret = -EFAULT;
+	} else if ((buf[0] == 's') || (buf[0] == 'S')) {
+		inspect_mode_flag = 0x01;
+		I("%s: Start to do Short_test.\n", __func__);
+	} else if ((buf[0] == 'o') || (buf[0] == 'O')) {
+		inspect_mode_flag = 0x02;
+		I("%s: Start to do Open_test.\n", __func__);
+	} else if ((buf[0] == 'n') || (buf[0] == 'N')) {
+		inspect_mode_flag = 0x08;
+		I("%s: Start to do Noise_test.\n", __func__);
+	} else if ((buf[0] == 'a') || (buf[0] == 'A')) {
+		inspect_mode_flag = 0x0B;
+		I("%s: Start to do All_test.\n", __func__);
+	} else if (buf[0] == 'h') {
+		inspect_mode_flag = 0x0F;
+		I("%s: User Call HELP! Lest's assist user to operate.\n",
+		  __func__);
+	} else {
+		I("%s: Input cmd is incorrect!\n", __func__);
+		ret = -EFAULT;
+	}
+
+	return ret;
+}
+
+int himax_inspect_mode_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_inspect_mode_show, NULL);
+}
+
+const struct proc_ops_name himax_inspect_mode_ops = {
+	owner_line
+	.proc_op(open) = himax_inspect_mode_open,
+	.proc_op(write) = himax_inspect_mode_store,
+	.proc_op(read) = seq_read,
+	.proc_opl(lseek) = seq_lseek,
+	.proc_op(release) = single_release,
+};
+
+#endif
+
+#if (HX_TP_GTS_MODE == 0x01)
+ssize_t himax_GTS_read(struct file *file, char *buf, size_t len,
+			      loff_t *pos)
+{
+	ssize_t count = 0;
+	struct himax_ts_data *ts = private_ts;
+	char *temp_buf = NULL;
+
+	if (!HX_PROC_SEND_FLAG) {
+		temp_buf = kcalloc(len, sizeof(char), GFP_KERNEL);
+		if (temp_buf != NULL) {
+			count = (ssize_t)snprintf(temp_buf, PAGE_SIZE, "%d\n",
+					 ts->GTS_range);
+
+			if (copy_to_user(buf, temp_buf, len)) {
+				I("%s, here:%d\n", __func__, __LINE__);
+			}
+
+			kfree(temp_buf);
+			temp_buf = NULL;
+			HX_PROC_SEND_FLAG = true;
+		} else {
+			E("%s, Failed to allocate memory\n", __func__);
+		}
+	} else {
+		HX_PROC_SEND_FLAG = false;
+	}
+
+	return count;
+}
+
+ssize_t himax_GTS_write(struct file *file, const char *buff, size_t len,
+			       loff_t *pos)
+{
+	struct himax_ts_data *ts = private_ts;
+	char buf[80] = { 0 };
+	ssize_t ret = 0;
+	int value = 0;
+
+	if (copy_from_user(buf, buff, len) != 0) {
+		ret = -EFAULT;
+	} else if (kstrtoint(&buf[0], 10, &value) == 0) {
+		if (value == 0) {
+			ts->GTS_range = (uint8_t)value;
+			I("%s: Ghost point protection disable, %d\n",
+				__func__, value);
+			ret = len;
+		} else if ((value > 0) && (value < 9)) {
+			ts->GTS_range = (uint8_t)value;
+			I("%s: Ghost point protection enable, %d\n",
+				__func__, value);
+			ret = len;
+		} else {
+			/*Undefined behavior*/
+			W("Undefined behavior\n");
+		}
+	} else {
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static const struct proc_ops_name himax_proc_GTS_ops = {
+	owner_line
+	.proc_op(read) = himax_GTS_read,
+	.proc_op(write) = himax_GTS_write,
+};
+#endif
+
+#if (HX_SMART_WAKEUP == 0x01)
+ssize_t himax_GESTURE_read(struct file *file, char *buf, size_t len,
+				  loff_t *pos)
+{
+	struct himax_ts_data *ts = private_ts;
+	uint8_t i = 0;
+	size_t ret = 0;
+	char *temp_buf = NULL;
+
+	if (!HX_PROC_SEND_FLAG) {
+		temp_buf = kcalloc(len, sizeof(char), GFP_KERNEL);
+		if (temp_buf != NULL) {
+			for (i = 0; i < GEST_SUP_NUM; i++) {
+				ret += (size_t)snprintf(&temp_buf[ret], len - ret,
+						"ges_en[%d]=%d\n", i,
+						ts->gesture_cust_en[i]);
+			}
+
+			if (copy_to_user(buf, temp_buf, len)) {
+				I("%s, here:%d\n", __func__, __LINE__);
+			}
+
+			kfree(temp_buf);
+			temp_buf = NULL;
+			HX_PROC_SEND_FLAG = true;
+		} else {
+			E("%s, Failed to allocate memory\n", __func__);
+		}
+	} else {
+		HX_PROC_SEND_FLAG = false;
+		ret = 0;
+	}
+
+	return ret;
+}
+
+ssize_t himax_GESTURE_write(struct file *file, const char *buff,
+				   size_t len, loff_t *pos)
+{
+	struct himax_ts_data *ts = private_ts;
+	uint8_t i = 0;
+	uint8_t j = 0;
+	char buf[80] = { 0 };
+	ssize_t ret = 0;
+
+	if (len >= 80U) {
+		I("%s: no command exceeds 80 chars.\n", __func__);
+		ret =  -EFAULT;
+	} else if (copy_from_user(buf, buff, len) != 0) {
+		ret =  -EFAULT;
+	} else {
+		I("himax_GESTURE_store= %s, len = %d\n", buf, (int)len);
+		for (i = 0; i < len; i++) {
+			if (buf[i] == '0' && j < GEST_SUP_NUM) {
+				ts->gesture_cust_en[j] = 0;
+				I("gesture en[%d]=%d\n", j, ts->gesture_cust_en[j]);
+				j++;
+			} else if (buf[i] == '1' && j < GEST_SUP_NUM) {
+				ts->gesture_cust_en[j] = 1;
+				I("gesture en[%d]=%d\n", j, ts->gesture_cust_en[j]);
+				j++;
+			} else {
+				/*do nothing*/
+				I("Not 0/1 or >=GEST_SUP_NUM : buf[%d] = %c\n", i,
+				  buf[i]);
+			}
+		}
+		ret = len;
+	}
+	return ret;
+}
+
+static const struct proc_ops_name himax_proc_Gesture_ops = {
+	owner_line
+	.proc_op(read) = himax_GESTURE_read,
+	.proc_op(write) = himax_GESTURE_write,
+};
+#endif
+
+void himax_mcu_check_cascade_ic_num(void)
+{
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	uint8_t slave_enb = 0xFFU;
+	uint8_t i = 0x00U;
+	struct himax_ts_data *ts = private_ts;
+
+	for (i = 0; i < HIMAX_I2C_RETRY_TIMES; i++) {
+		(void)memset(tmp_data, 0xFFU, sizeof(tmp_data));
+		himax_mcu_register_read(addr_chk_tp_status, DATA_LEN_4, tmp_data);
+		slave_enb = ((tmp_data[1] & 0x0CU) >> 2U);
+
+		if (slave_enb == 0x00U) {
+			ts->slave_ic_num = 0x02U;
+			I("[IC_SLAVE_2] detected!\n");
+			break;
+		} else if (slave_enb == 0x02U) {
+			ts->slave_ic_num = 0x01U;
+			I("[IC_SLAVE_1] detected!\n");
+			break;
+		} else if (slave_enb == 0x03U) {
+			ts->slave_ic_num = 0x00U;
+			break;
+		} else {
+			slave_enb = 0xFFU;
+		}
+	}
+	if (slave_enb == 0xFFU) {
+		ts->slave_ic_num = 0x02U;
+		W("Unexpected status, Default %d chips\n", (ts->slave_ic_num + 1U));
+	} else {
+		I("Number of cascaded ICs : [%d]\n", (ts->slave_ic_num + 1U));
+	}
+}
+
+void himax_report_data_deinit(void)
+{
+	if (g_target_report_data->finger_id != NULL) {
+		kfree(g_target_report_data->finger_id);
+		g_target_report_data->finger_id = NULL;
+	}
+	if (g_target_report_data->w != NULL) {
+		kfree(g_target_report_data->w);
+		g_target_report_data->w = NULL;
+	}
+	if (g_target_report_data->y != NULL) {
+		kfree(g_target_report_data->y);
+		g_target_report_data->y = NULL;
+	}
+	if (g_target_report_data->x != NULL) {
+		kfree(g_target_report_data->x);
+		g_target_report_data->x = NULL;
+	}
+	if (g_target_report_data != NULL) {
+		kfree(g_target_report_data);
+		g_target_report_data = NULL;
+	}
+#if (HX_TP_GTS_MODE == 0x01)
+	if (fixed_point_label->fpt_cnt != NULL) {
+		kfree(fixed_point_label->fpt_cnt);
+		fixed_point_label->fpt_cnt = NULL;
+	}
+	if (fixed_point_label->finger_id != NULL) {
+		kfree(fixed_point_label->finger_id);
+		fixed_point_label->finger_id = NULL;
+	}
+	if (fixed_point_label->y != NULL) {
+		kfree(fixed_point_label->y);
+		fixed_point_label->y = NULL;
+	}
+	if (fixed_point_label->x != NULL) {
+		kfree(fixed_point_label->x);
+		fixed_point_label->x = NULL;
+	}
+	if (fixed_point_label != NULL) {
+		kfree(fixed_point_label);
+		fixed_point_label = NULL;
+	}
+#endif
+#if (HX_SMART_WAKEUP == 0x01)
+	if (wake_event_buffer != NULL) {
+		kfree(wake_event_buffer);
+		wake_event_buffer = NULL;
+	}
+#endif
+	if (hx_touch_data->hx_rawdata_buf != NULL) {
+		kfree(hx_touch_data->hx_rawdata_buf);
+		hx_touch_data->hx_rawdata_buf = NULL;
+	}
+	if (hx_touch_data->hx_coord_buf != NULL) {
+		kfree(hx_touch_data->hx_coord_buf);
+		hx_touch_data->hx_coord_buf = NULL;
+	}
+}
+
+static void himax_common_proc_deinit(void)
+{
+	/*Remove all*/
+#if (HX_TP_GTS_MODE == 0x01)
+	if (himax_proc_GTS_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_GTS_FILE, himax_touch_proc_dir);
+	}
+#endif
+#if (HX_TP_INSPECT_MODE == 0x01)
+	if (himax_proc_INSPECT_MODE_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_INSPECT_MODE_FILE, himax_touch_proc_dir);
+	}
+#endif
+	if (himax_proc_fail_det_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_FAIL_DET_FILE, himax_touch_proc_dir);
+	}
+	if (himax_proc_WPBPlock_node_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_WP_BP_LOCK_FILE, himax_touch_proc_dir);
+	}
+#if (HX_SMART_WAKEUP == 0x01)
+	if (himax_proc_GESTURE_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_GESTURE_FILE, himax_touch_proc_dir);
+	}
+#endif
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_SELF_TEST)
+	if (himax_proc_self_test_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_SELF_TEST_FILE, himax_touch_proc_dir);
+	}
+#endif
+	if (himax_touch_proc_dir != NULL) {
+		remove_proc_entry(HIMAX_PROC_TOUCH_FOLDER, NULL);
+	}
+}
+
+static bool himax_common_proc_init(void)
+{
+	himax_touch_proc_dir = proc_mkdir(HIMAX_PROC_TOUCH_FOLDER, NULL);
+
+	if (himax_touch_proc_dir == NULL) {
+		E(" %s: himax_touch_proc_dir file create failed!\n", __func__);
+		return false;
+	} else {
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_SELF_TEST)
+		himax_proc_self_test_file =
+			proc_create(HIMAX_PROC_SELF_TEST_FILE, S_IRUGO,
+					himax_touch_proc_dir, &himax_self_test_ops);
+		if (himax_proc_self_test_file == NULL) {
+			E(" %s: proc self_test file create failed!\n", __func__);
+			himax_common_proc_deinit();
+			return false;
+		}
+#endif
+#if (HX_SMART_WAKEUP == 0x01)
+		himax_proc_GESTURE_file =
+			proc_create(HIMAX_PROC_GESTURE_FILE, (S_IRUGO | S_IWUGO), himax_touch_proc_dir,
+					&himax_proc_Gesture_ops);
+
+		if (himax_proc_GESTURE_file == NULL) {
+			E(" %s: proc GESTURE file create failed!\n", __func__);
+			himax_common_proc_deinit();
+			return false;
+		}
+#endif
+		himax_proc_WPBPlock_node_file =
+			proc_create(HIMAX_PROC_WP_BP_LOCK_FILE, S_IRUGO,
+					himax_touch_proc_dir,
+					&himax_WPBPlock_node_ops);
+		if (himax_proc_WPBPlock_node_file == NULL) {
+			E(" %s: proc BPlock file create failed!\n", __func__);
+			himax_common_proc_deinit();
+			return false;
+		}
+
+		himax_proc_fail_det_file =
+			proc_create(HIMAX_PROC_FAIL_DET_FILE, S_IRUGO,
+					himax_touch_proc_dir, &himax_fail_det_ops);
+		if (himax_proc_fail_det_file == NULL) {
+			E(" %s: proc fail det file create failed!\n", __func__);
+			himax_common_proc_deinit();
+			return false;
+		}
+#if (HX_TP_INSPECT_MODE == 0x01)
+		himax_proc_INSPECT_MODE_file =
+			proc_create(HIMAX_PROC_INSPECT_MODE_FILE, (S_IRUGO | S_IWUGO),
+					himax_touch_proc_dir, &himax_inspect_mode_ops);
+
+		if (himax_proc_INSPECT_MODE_file == NULL) {
+			E(" %s: proc INSPECT_MODE file create failed!\n", __func__);
+			himax_common_proc_deinit();
+			return false;
+		}
+#endif
+#if (HX_TP_GTS_MODE == 0x01)
+		himax_proc_GTS_file =
+			proc_create(HIMAX_PROC_GTS_FILE, (S_IRUGO | S_IWUGO), himax_touch_proc_dir,
+					&himax_proc_GTS_ops);
+
+		if (himax_proc_GTS_file == NULL) {
+			E(" %s: proc GTS file create failed!\n", __func__);
+			himax_common_proc_deinit();
+			return false;
+		}
+#endif
+	}
+
+	return true;
+
+}
+
+void himax_parse_assign_cmd(uint32_t addr, uint8_t *cmd, uint32_t len)
+{
+	/*I("%s: Entering!\n", __func__);*/
+	switch (len) {
+	case 1:
+		cmd[0] = (uint8_t)(addr % 0x100U);
+		break;
+	case 2:
+		cmd[0] = (uint8_t)(addr % 0x100U);
+		cmd[1] = (uint8_t)((addr >> 8U) % 0x100U);
+		break;
+	case 4:
+		cmd[0] = (uint8_t)(addr % 0x100U);
+		cmd[1] = (uint8_t)((addr >> 8U) % 0x100U);
+		cmd[2] = (uint8_t)((addr >> 16U) % 0x100U);
+		cmd[3] = (uint8_t)(addr / 0x1000000U);
+		break;
+	default:
+		E("%s: input length fault,len = %d!\n", __func__, len);
+		break;
+	}
+}
+EXPORT_SYMBOL(himax_parse_assign_cmd);
+
+int himax_input_register(struct himax_ts_data *ts)
+{
+	int ret = NO_ERR;
+#if (HX_SMART_WAKEUP == 0x01)
+	uint8_t i = 0;
+#endif
+
+	ret = himax_dev_set(ts);
+
+	if (ret < 0) {
+		E("%s, input device register fail!\n", __func__);
+		ret = INPUT_REGISTER_FAIL;
+		goto input_device_fail;
+	}
+
+	set_bit(EV_SYN, ts->input_dev->evbit);
+	set_bit(EV_ABS, ts->input_dev->evbit);
+	set_bit(EV_KEY, ts->input_dev->evbit);
+	set_bit(KEY_BACK, ts->input_dev->keybit);
+	set_bit(KEY_HOME, ts->input_dev->keybit);
+	set_bit(KEY_MENU, ts->input_dev->keybit);
+	set_bit(KEY_SEARCH, ts->input_dev->keybit);
+
+#if (HX_SMART_WAKEUP == 0x01)
+	for (i = 0; i < GEST_SUP_NUM; i++) {
+		set_bit(gest_key_def[i], ts->input_dev->keybit);
+	}
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_SELF_TEST)
+	set_bit(KEY_POWER, ts->input_dev->keybit);
+#endif
+	set_bit(BTN_TOUCH, ts->input_dev->keybit);
+	set_bit(KEY_APPSELECT, ts->input_dev->keybit);
+	set_bit(INPUT_PROP_DIRECT, ts->input_dev->propbit);
+#if (HX_PROTOCOL_A == 0x01)
+	/*ts->input_dev->mtsize = ts->nFinger_support;*/
+	input_set_abs_params(ts->input_dev, ABS_MT_TRACKING_ID, 1, ts->nFinger_support, 0, 0);
+#else
+	set_bit(MT_TOOL_FINGER, ts->input_dev->keybit);
+#if (HX_PROTOCOL_B_3PA == 0x01)
+	input_mt_init_slots(ts->input_dev, ts->nFinger_support,
+			    INPUT_MT_DIRECT);
+#else
+	input_mt_init_slots(ts->input_dev, ts->nFinger_support);
+#endif
+#endif
+	I("%s: mix_x %d, max_x %d, min_y %d, max_y %d\n", __func__,
+	  ts->pdata->abs_x_min, ts->pdata->abs_x_max, ts->pdata->abs_y_min,
+	  ts->pdata->abs_y_max);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_X,
+			     ts->pdata->abs_x_min, (ts->pdata->abs_x_max - 1U),
+			     ts->pdata->abs_x_fuzz, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_POSITION_Y,
+			     ts->pdata->abs_y_min, (ts->pdata->abs_y_max - 1U),
+			     ts->pdata->abs_y_fuzz, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_TOUCH_MAJOR,
+			     ts->pdata->abs_pressure_min,
+			     ts->pdata->abs_pressure_max,
+			     ts->pdata->abs_pressure_fuzz, 0);
+#if (HX_PROTOCOL_A == 0x00)
+	input_set_abs_params(ts->input_dev, ABS_MT_PRESSURE,
+			     ts->pdata->abs_pressure_min,
+			     ts->pdata->abs_pressure_max,
+			     ts->pdata->abs_pressure_fuzz, 0);
+	input_set_abs_params(ts->input_dev, ABS_MT_WIDTH_MAJOR,
+			     ts->pdata->abs_width_min, ts->pdata->abs_width_max,
+			     ts->pdata->abs_pressure_fuzz, 0);
+#endif
+	/*	input_set_abs_params(ts->input_dev, ABS_MT_AMPLITUDE, 0,*/
+	/*			((ts->pdata->abs_pressure_max << 16)*/
+	/*			| ts->pdata->abs_width_max),*/
+	/*			0, 0);*/
+	/*	input_set_abs_params(ts->input_dev, ABS_MT_POSITION,*/
+	/*			0, (BIT(31)*/
+	/*			| (ts->pdata->abs_x_max << 16)*/
+	/*			| ts->pdata->abs_y_max),*/
+	/*			0, 0);*/
+
+	if (himax_input_register_device(ts->input_dev) == 0) {
+		ret = NO_ERR;
+	} else {
+		E("%s: input register fail\n", __func__);
+		ret = INPUT_REGISTER_FAIL;
+	}
+
+input_device_fail:
+	return ret;
+}
+EXPORT_SYMBOL(himax_input_register);
+
+static void calculate_point_number(void)
+{
+	HX_TOUCH_INFO_POINT_CNT = ic_data->HX_MAX_PT * 4U;
+
+	if ((ic_data->HX_MAX_PT % 4U) == 0U) {
+		HX_TOUCH_INFO_POINT_CNT += (ic_data->HX_MAX_PT / 4U) * 4U;
+	} else {
+		HX_TOUCH_INFO_POINT_CNT += ((ic_data->HX_MAX_PT / 4U) + 1U) * 4U;
+	}
+}
+
+#if (HX_BOOT_UPGRADE == 0x01)
+/*-------------------------------------------------------------------------
+ *
+ *	Create: Unknown
+ *
+ *	Description: Read FW_VER and CFG_VER value from FW file and compare with
+ *		         FW/CFG version from MCU.
+ *	Parameters: void
+ *
+ *	Returns: int (0 need update/ 1 no need update)
+ *
+ *	Side effects: None
+ */
+static int himax_auto_update_check(void)
+{
+	int32_t ret;
+
+	if ((ic_data->vendor_touch_cfg_ver >= 0x80U) ||
+	    (ic_data->vendor_display_cfg_ver >= 0x80U)) {
+		ic_data->FW_update_flag = 0x03U;
+		I("%s: Test FW, Need to update\n", __func__);
+		ret = 0;
+	} else if (himax_mcu_fw_ver_bin() == NO_ERR) {
+		if ((ic_data->vendor_arch_ver < g_i_FW_VER) ||
+		    (ic_data->vendor_config_ver < g_i_CFG_VER)) {
+			ic_data->FW_update_flag = 0x04U;
+			I("%s: FW BIN is newer version, Need to update\n",
+			  __func__);
+			ret = 0;
+		} else if ((ic_data->vendor_arch_ver == g_i_FW_VER) &&
+			   (ic_data->vendor_config_ver == g_i_CFG_VER)) {
+			ic_data->FW_update_flag = 0x05U;
+			if (himax_mcu_flash_lastdata_check_with_bin(
+				    FW_SIZE_128k) == 1) {
+				W("%s: Flash FW is different from BIN, Need update\n",
+				  __func__);
+				ret = 0;
+			} else {
+				I("%s: Flash FW is same with BIN, No need update!\n",
+				  __func__);
+				ret = 1;
+			}
+		} else {
+			I("%s: Flash FW is newer version, No need update!\n",
+			  __func__);
+			ret = 1;
+		}
+	} else {
+		E("%s: FW bin fail!\n", __func__);
+		ret = 1;
+	}
+
+	return ret;
+}
+
+static int himax_force_update_FW_check(void)
+{
+	int ret = NO_ERR;
+
+	ret = request_firmware(&hxfw, BOOT_FORCE_UPGRADE_FWNAME, private_ts->dev);
+	if (ret < 0) {
+		ret = OPEN_FILE_FAIL;
+	} else {
+		I("<<<Force update FW detected!!!>>>\n");
+	}
+
+	return ret;
+}
+
+static int i_get_FW(void)
+{
+	int ret = NO_ERR;
+
+	I("%s: file name = %s\n", __func__, BOOT_UPGRADE_FWNAME);
+	ret = request_firmware(&hxfw, BOOT_UPGRADE_FWNAME, private_ts->dev);
+	if (ret < 0) {
+		E("%s,%d: error code = %d\n", __func__, __LINE__, ret);
+		ret = OPEN_FILE_FAIL;
+	}
+
+	return ret;
+}
+
+static int i_update_FW(void)
+{
+	uint8_t upgrade_times = 0;
+	int8_t result = HX_FAIL;
+
+	himax_int_enable(0);
+	if (private_ts->hx_fail_det > 0) {
+		himax_fail_det_enable(0);
+	}
+
+	while (upgrade_times < 3U) {
+		if (!g_core_fp.fp_fts_ctpm_fw_upgrade(
+			hxfw->data, (unsigned int)hxfw->size)) {
+			upgrade_times++;
+			E("%s: FW upgrade fail %d times\n", __func__,
+				upgrade_times);
+		} else {
+			himax_mcu_config_reload_enable();
+			himax_mcu_power_on_init();
+			himax_mcu_read_FW_ver();
+			g_core_fp.fp_touch_information();
+			result = 1; /*upgrade success*/
+			I("%s: FW upgrade OK\n", __func__);
+#if defined(FW_update_history_record)
+			himax_FW_update_record();
+#endif
+			break;
+		}
+	}
+
+#if (HX_WPBP_ENABLE == 0x01)
+	himax_enable_flash_protected_mode();
+#endif
+	himax_int_enable(1);
+	if (private_ts->hx_fail_det > 0) {
+		himax_fail_det_enable(1);
+	}
+	return result;
+}
+#endif
+/*
+ *static int himax_loadSensorConfig(struct himax_i2c_platform_data *pdata)
+ *{
+ *	I("%s: initialization complete\n", __func__);
+ *	return NO_ERR;
+ *}
+ */
+#if (HX_EXCP_RECOVERY == 0x01)
+void himax_mcu_excp_ic_reset(void)
+{
+	HX_EXCP_RESET_ACTIVATE = false;
+#if (HX_RST_PIN_FUNC == 0x01)
+	himax_mcu_toggle_rst_gpio();
+#elif (HX_RST_PIN_FUNC == 0x02)
+	/* Need Customer do TP reset pin */
+#else
+	himax_mcu_system_reset();
+#endif
+	I("%s:\n", __func__);
+}
+
+static void himax_excp_hw_reset(void)
+{
+	if (g_ts_dbg != 0) {
+		I("%s: Entering\n", __func__);
+	}
+
+	I("%s: START EXCEPTION Reset\n", __func__);
+
+	if (private_ts->in_self_test == 1) {
+		I("%s: In self test, not TP EXCEPTION Reset\n", __func__);
+	} else {
+		himax_mcu_excp_ic_reset();
+	}
+
+	I("%s: END EXCEPTION Reset\n", __func__);
+}
+#endif
+
+#if (HX_SMART_WAKEUP == 0x01)
+#if (HX_GESTURE_TRACK == 0x01)
+static void gest_pt_log_coordinate(uint8_t rx, uint8_t tx)
+{
+	/*driver report x y with range 0 - 255 , we scale it up to x/y pixel*/
+	gest_pt_x[gest_pt_cnt] = rx * (ic_data->HX_X_RES) / 255U;
+	gest_pt_y[gest_pt_cnt] = tx * (ic_data->HX_Y_RES) / 255U;
+}
+#endif
+static int himax_wake_event_parse(struct himax_ts_data *ts)
+{
+	uint8_t *buf = wake_event_buffer;
+#if (HX_GESTURE_TRACK == 0x01)
+	uint16_t tmp_max_x = 0x00U;
+	uint16_t tmp_min_x = 0xFFFFU;
+	uint16_t tmp_max_y = 0x00U;
+	uint16_t tmp_min_y = 0xFFFFU;
+	uint8_t gest_len;
+#endif
+	int ret = 0;
+	uint8_t i = 0, check_FC = 0;
+	uint8_t j = 0, gesture_pos = 0;
+	uint8_t gesture_flag = 0;
+
+	if (buf == NULL) {
+		ret = -ENOMEM;
+		goto END;
+	}
+
+	(void)memcpy(buf, hx_touch_data->hx_event_buf, hx_touch_data->event_size);
+
+	for (i = 0; i < GEST_PTLG_ID_LEN; i++) {
+		for (j = 0; j < GEST_SUP_NUM; j++) {
+			if (buf[i] == gest_event[j]) {
+				gesture_flag = buf[i];
+				gesture_pos = j;
+				break;
+			}
+		}
+		I("0x%2.2X ", buf[i]);
+		if (buf[i] == gesture_flag) {
+			check_FC++;
+		} else {
+			I("ID START at 0x%02X , value = 0x%02X skip the event\n", i,
+			  buf[i]);
+			break;
+		}
+	}
+	I("gesture_flag= 0x%02X, check_FC= %d\\n", gesture_flag, check_FC);
+
+	if (check_FC != GEST_PTLG_ID_LEN) {
+		ret = 0;
+		goto END;
+	}
+
+	if (buf[GEST_PTLG_ID_LEN] != GEST_PTLG_HDR_ID1 ||
+	    buf[GEST_PTLG_ID_LEN + 1U] != GEST_PTLG_HDR_ID2) {
+		ret = 0;
+		goto END;
+	}
+
+#if (HX_GESTURE_TRACK == 0x01)
+	if (buf[GEST_PTLG_ID_LEN] == GEST_PTLG_HDR_ID1 &&
+	    buf[GEST_PTLG_ID_LEN + 1U] == GEST_PTLG_HDR_ID2) {
+		gest_len = buf[GEST_PTLG_ID_LEN + 2U];
+		I("gest_len = %d\n", gest_len);
+		i = 0;
+		gest_pt_cnt = 0U;
+		I("gest doornidate start\n %s", __func__);
+
+		while (i < ((gest_len + 1U) / 2U)) {
+			gest_pt_log_coordinate(
+				buf[GEST_PTLG_ID_LEN + 4U + (i * 2U)],
+				buf[GEST_PTLG_ID_LEN + 4U + (i * 2U) + 1U]);
+			i++;
+			I("gest_pt_x[%d]=%d,gest_pt_y[%d]=%d\n", gest_pt_cnt,
+			  gest_pt_x[gest_pt_cnt], gest_pt_cnt,
+			  gest_pt_y[gest_pt_cnt]);
+			gest_pt_cnt += 1U;
+		}
+
+		if (gest_pt_cnt > 0U) {
+			for (i = 0; i < gest_pt_cnt; i++) {
+				if (tmp_max_x < gest_pt_x[i]) {
+					tmp_max_x = gest_pt_x[i];
+				}
+				if (tmp_min_x > gest_pt_x[i]) {
+					tmp_min_x = gest_pt_x[i];
+				}
+				if (tmp_max_y < gest_pt_y[i]) {
+					tmp_max_y = gest_pt_y[i];
+				}
+				if (tmp_min_y > gest_pt_y[i]) {
+					tmp_min_y = gest_pt_y[i];
+				}
+			}
+
+			I("gest_point x_min=%d,x_max=%d,y_min=%d,y_max=%d\n",
+			  tmp_min_x, tmp_max_x, tmp_min_y, tmp_max_y);
+
+			gest_start_x = gest_pt_x[0];
+			hx_gesture_coor[0] = gest_start_x;
+			gest_start_y = gest_pt_y[0];
+			hx_gesture_coor[1] = gest_start_y;
+			gest_end_x = gest_pt_x[gest_pt_cnt - 1U];
+			hx_gesture_coor[2] = gest_end_x;
+			gest_end_y = gest_pt_y[gest_pt_cnt - 1U];
+			hx_gesture_coor[3] = gest_end_y;
+			if (tmp_max_x > tmp_min_x) {
+				gest_width = tmp_max_x - tmp_min_x;
+			}
+			hx_gesture_coor[4] = gest_width;
+			if (tmp_max_y > tmp_min_y) {
+				gest_height = tmp_max_y - tmp_min_y;
+			}
+			hx_gesture_coor[5] = gest_height;
+			gest_mid_x = (tmp_max_x + tmp_min_x) / 2U;
+			hx_gesture_coor[6] = gest_mid_x;
+			gest_mid_y = (tmp_max_y + tmp_min_y) / 2U;
+			hx_gesture_coor[7] = gest_mid_y;
+			/*gest_up_x*/
+			hx_gesture_coor[8] = gest_mid_x;
+			/*gest_up_y*/
+			hx_gesture_coor[9] = gest_mid_y - (gest_height / 2U);
+			/*gest_down_x*/
+			hx_gesture_coor[10] = gest_mid_x;
+			/*gest_down_y*/
+			hx_gesture_coor[11] = gest_mid_y + (gest_height / 2U);
+			/*gest_left_x*/
+			hx_gesture_coor[12] = gest_mid_x - (gest_width / 2U);
+			/*gest_left_y*/
+			hx_gesture_coor[13] = gest_mid_y;
+			/*gest_right_x*/
+			hx_gesture_coor[14] = gest_mid_x + (gest_width / 2U);
+			/*gest_right_y*/
+			hx_gesture_coor[15] = gest_mid_y;
+		}
+	}
+#endif
+
+	/*if (!ts->gesture_cust_en[gesture_pos]) {*/
+	if (gesture_flag == 0U) {
+		I("%s NOT report key [%d] = %d\n", __func__, gesture_pos,
+		  gest_key_def[gesture_pos]);
+		g_target_report_data->SMWP_event_chk = 0;
+		ret = 0;
+	} else {
+		g_target_report_data->SMWP_event_chk =
+			(int)gest_key_def[gesture_pos];
+		ret = (int)gesture_pos;
+	}
+END:
+	return ret;
+}
+
+static void himax_wake_event_report(void)
+{
+	int KEY_EVENT = g_target_report_data->SMWP_event_chk;
+
+	if (g_ts_dbg != 0) {
+		I("%s: Entering!\n", __func__);
+	}
+
+	if (KEY_EVENT != 0) {
+		I("%s SMART WAKEUP KEY event %d press\n", __func__, KEY_EVENT);
+		input_report_key(private_ts->input_dev, KEY_EVENT, 1);
+		input_sync(private_ts->input_dev);
+		I("%s SMART WAKEUP KEY event %d release\n", __func__,
+		  KEY_EVENT);
+		input_report_key(private_ts->input_dev, KEY_EVENT, 0);
+		input_sync(private_ts->input_dev);
+#if (HX_GESTURE_TRACK == 0x01)
+		I("gest_start_x=%d,start_y=%d,end_x=%d,end_y=%d\n",
+		  gest_start_x, gest_start_y, gest_end_x, gest_end_y);
+		I("gest_width=%d,height=%d,mid_x=%d,mid_y=%d\n", gest_width,
+		  gest_height, gest_mid_x, gest_mid_y);
+		I("gest_up_x=%d,up_y=%d,down_x=%d,down_y=%d\n",
+		  hx_gesture_coor[8], hx_gesture_coor[9], hx_gesture_coor[10],
+		  hx_gesture_coor[11]);
+		I("gest_left_x=%d,left_y=%d,right_x=%d,right_y=%d\n",
+		  hx_gesture_coor[12], hx_gesture_coor[13], hx_gesture_coor[14],
+		  hx_gesture_coor[15]);
+#endif
+		g_target_report_data->SMWP_event_chk = 0;
+	}
+}
+
+#endif
+
+static int himax_report_data_init(void)
+{
+	int err = NO_ERR;
+
+	if (hx_touch_data->hx_coord_buf != NULL) {
+		kfree(hx_touch_data->hx_coord_buf);
+		hx_touch_data->hx_coord_buf = NULL;
+	}
+	if (hx_touch_data->hx_rawdata_buf != NULL) {
+		kfree(hx_touch_data->hx_rawdata_buf);
+		hx_touch_data->hx_rawdata_buf = NULL;
+	}
+
+#if (HX_SMART_WAKEUP == 0x01)
+	hx_touch_data->event_size = HIMAX_TOUCH_DATA_SIZE;
+
+	if (hx_touch_data->hx_event_buf != NULL) {
+		kfree(hx_touch_data->hx_event_buf);
+		hx_touch_data->hx_event_buf = NULL;
+	}
+
+	if (wake_event_buffer != NULL) {
+		kfree(wake_event_buffer);
+		wake_event_buffer = NULL;
+	}
+
+#endif
+	hx_touch_data->touch_all_size = HIMAX_TOUCH_DATA_SIZE;
+	hx_touch_data->raw_cnt_max = ic_data->HX_MAX_PT / 4U;
+	hx_touch_data->raw_cnt_rmd = ic_data->HX_MAX_PT % 4U;
+	/* more than 4 fingers */
+	if (hx_touch_data->raw_cnt_rmd != 0x00U) {
+		hx_touch_data->rawdata_size =
+			himax_mcu_cal_data_len(hx_touch_data->raw_cnt_rmd,
+					       ic_data->HX_MAX_PT,
+					       hx_touch_data->raw_cnt_max);
+
+		hx_touch_data->touch_info_size =
+			(ic_data->HX_MAX_PT + hx_touch_data->raw_cnt_max + 2U) *
+			4U;
+	} else { /* less than 4 fingers */
+		hx_touch_data->rawdata_size =
+			himax_mcu_cal_data_len(hx_touch_data->raw_cnt_rmd,
+					       ic_data->HX_MAX_PT,
+					       hx_touch_data->raw_cnt_max);
+
+		hx_touch_data->touch_info_size =
+			(ic_data->HX_MAX_PT + hx_touch_data->raw_cnt_max + 1U) *
+			4U;
+	}
+
+	I("%s:HX_MAX_PT:%d,hx_raw_cnt_max:%d\n", __func__,
+	  ic_data->HX_MAX_PT, hx_touch_data->raw_cnt_max);
+	I("%s:hx_raw_cnt_rmd:%d,hx_rawdata_size:%d,touch_info_size:%d\n",
+	  __func__, hx_touch_data->raw_cnt_rmd, hx_touch_data->rawdata_size,
+	  hx_touch_data->touch_info_size);
+
+	hx_touch_data->hx_coord_buf = kzalloc(
+		sizeof(uint8_t) * (hx_touch_data->touch_info_size), GFP_KERNEL);
+
+	if (hx_touch_data->hx_coord_buf == NULL) {
+		himax_report_data_deinit();
+		E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+		err = MEM_ALLOC_FAIL;
+	}
+
+#if (HX_SMART_WAKEUP == 0x01)
+	wake_event_buffer =
+		kcalloc(hx_touch_data->event_size, sizeof(uint8_t), GFP_KERNEL);
+	if (wake_event_buffer == NULL) {
+		himax_report_data_deinit();
+		E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+		err = MEM_ALLOC_FAIL;
+	}
+
+	hx_touch_data->hx_event_buf = kzalloc(
+		sizeof(uint8_t) * (hx_touch_data->event_size), GFP_KERNEL);
+	if (hx_touch_data->hx_event_buf == NULL) {
+		himax_report_data_deinit();
+		E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+		err = MEM_ALLOC_FAIL;
+	}
+#endif
+
+	hx_touch_data->hx_rawdata_buf =
+		kzalloc((uint8_t)sizeof(uint8_t) * (hx_touch_data->touch_all_size -
+					   hx_touch_data->touch_info_size),
+			GFP_KERNEL);
+	if (hx_touch_data->hx_rawdata_buf == NULL) {
+		himax_report_data_deinit();
+		E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+		err = MEM_ALLOC_FAIL;
+	}
+
+	if (g_target_report_data == NULL) {
+		g_target_report_data = kzalloc(
+			sizeof(struct himax_target_report_data), GFP_KERNEL);
+		if (g_target_report_data == NULL) {
+			himax_report_data_deinit();
+			E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+			err = MEM_ALLOC_FAIL;
+		}
+
+		g_target_report_data->x =
+			kzalloc(sizeof(int) * (ic_data->HX_MAX_PT), GFP_KERNEL);
+		if (g_target_report_data->x == NULL) {
+			himax_report_data_deinit();
+			E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+			err = MEM_ALLOC_FAIL;
+		}
+
+		g_target_report_data->y =
+			kzalloc(sizeof(int) * (ic_data->HX_MAX_PT), GFP_KERNEL);
+		if (g_target_report_data->y == NULL) {
+			himax_report_data_deinit();
+			E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+			err = MEM_ALLOC_FAIL;
+		}
+
+		g_target_report_data->w =
+			kzalloc(sizeof(int) * (ic_data->HX_MAX_PT), GFP_KERNEL);
+		if (g_target_report_data->w == NULL) {
+			himax_report_data_deinit();
+			E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+			err = MEM_ALLOC_FAIL;
+		}
+
+		g_target_report_data->finger_id =
+			kzalloc(sizeof(int) * (ic_data->HX_MAX_PT), GFP_KERNEL);
+		if (g_target_report_data->finger_id == NULL) {
+			himax_report_data_deinit();
+			E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+			err = MEM_ALLOC_FAIL;
+		}
+	}
+#if (HX_TP_GTS_MODE == 0x01)
+	if (fixed_point_label == NULL) {
+		fixed_point_label = kzalloc(
+			sizeof(struct himax_target_report_data), GFP_KERNEL);
+		if (fixed_point_label == NULL) {
+			himax_report_data_deinit();
+			E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+			err = MEM_ALLOC_FAIL;
+		}
+
+		fixed_point_label->x =
+			kzalloc(sizeof(int) * (ic_data->HX_MAX_PT), GFP_KERNEL);
+		if (fixed_point_label->x == NULL) {
+			himax_report_data_deinit();
+			E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+			err = MEM_ALLOC_FAIL;
+		}
+
+		fixed_point_label->y =
+			kzalloc(sizeof(int) * (ic_data->HX_MAX_PT), GFP_KERNEL);
+		if (fixed_point_label->y == NULL) {
+			himax_report_data_deinit();
+			E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+			err = MEM_ALLOC_FAIL;
+		}
+
+		fixed_point_label->finger_id =
+			kzalloc(sizeof(int) * (ic_data->HX_MAX_PT), GFP_KERNEL);
+		if (fixed_point_label->finger_id == NULL) {
+			himax_report_data_deinit();
+			E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+			err = MEM_ALLOC_FAIL;
+		}
+
+		fixed_point_label->fpt_cnt =
+			kzalloc(sizeof(int) * (ic_data->HX_MAX_PT), GFP_KERNEL);
+		if (fixed_point_label->fpt_cnt == NULL) {
+			himax_report_data_deinit();
+			E("%s: Failed to allocate memory, %d\n", __func__, __LINE__);
+			err = MEM_ALLOC_FAIL;
+		}
+
+	}
+	(void)memset(fixed_point_label->x, 0xFF, ic_data->HX_MAX_PT * sizeof(int));
+	(void)memset(fixed_point_label->y, 0xFF, ic_data->HX_MAX_PT * sizeof(int));
+#endif
+
+	return err;
+}
+
+static int himax_ts_work_status(struct himax_ts_data *ts)
+{
+	/* 1: normal */
+	int result = HX_REPORT_COORD;
+
+	hx_touch_data->diag_cmd = ts->diag_cmd;
+	if (hx_touch_data->diag_cmd != 0U) {
+		result = HX_REPORT_COORD_RAWDATA;
+	}
+
+#if (HX_SMART_WAKEUP == 0x01)
+	if (atomic_read(&ts->suspend_mode) && (ts->SMWP_enable) &&
+	    (!hx_touch_data->diag_cmd)) {
+		result = HX_REPORT_SMWP_EVENT;
+	}
+#endif
+	/* I("Now Status is %d\n", result); */
+	return result;
+}
+
+static void himax_touch_get(struct himax_ts_data *ts, uint8_t *buf, int ts_path,
+			   int *ts_status)
+{
+	UNUSED(ts);
+
+	if (g_ts_dbg != 0) {
+		I("%s: Entering, ts_status=%d!\n", __func__, *ts_status);
+	}
+
+	switch (ts_path) {
+	/*normal*/
+	case HX_REPORT_COORD:
+#if (HX_EXCP_RECOVERY == 0x01)
+		if (HX_EXCP_RESET_ACTIVATE) {
+			if (!himax_mcu_read_event_stack(buf, 128)) {
+				E("%s: can't read data from chip!\n", __func__);
+				*ts_status = HX_TS_GET_DATA_FAIL;
+			}
+		} else {
+			if (!himax_mcu_read_event_stack(
+				    buf, hx_touch_data->touch_info_size)) {
+				E("%s: can't read data from chip!\n", __func__);
+				*ts_status = HX_TS_GET_DATA_FAIL;
+			}
+		}
+		break;
+#else
+		if (!himax_mcu_read_event_stack(
+			    buf, hx_touch_data->touch_info_size)) {
+			E("%s: can't read data from chip!\n", __func__);
+			*ts_status = HX_TS_GET_DATA_FAIL;
+		}
+		break;
+#endif
+
+#if (HX_SMART_WAKEUP == 0x01)
+
+	/*SMWP*/
+	case HX_REPORT_SMWP_EVENT:
+		__pm_wakeup_event(ts->ts_SMWP_wake_lock, TS_WAKE_LOCK_TIMEOUT);
+		msleep(20);
+
+		if (!himax_mcu_read_event_stack(buf,
+						hx_touch_data->event_size)) {
+			E("%s: can't read data from chip!\n", __func__);
+			*ts_status = HX_TS_GET_DATA_FAIL;
+		}
+		break;
+#endif
+	case HX_REPORT_COORD_RAWDATA:
+		if (!himax_mcu_read_event_stack(buf, 128)) {
+			E("%s: can't read data from chip!\n", __func__);
+			*ts_status = HX_TS_GET_DATA_FAIL;
+		}
+		break;
+	default:
+		/*do nothing*/
+		break;
+	}
+
+}
+
+/* start error_control*/
+static void himax_checksum_cal(struct himax_ts_data *ts, uint8_t *buf,
+			      int ts_path, int *ts_status)
+{
+	uint16_t check_sum_cal = 0;
+	uint16_t i = 0;
+	uint16_t length = 0;
+	uint16_t zero_cnt = 0;
+	uint8_t raw_data_sel = 0;
+
+	if (g_ts_dbg != 0) {
+		I("%s: Entering, ts_status=%d!\n", __func__, *ts_status);
+	}
+
+	/* Normal */
+	switch (ts_path) {
+	case HX_REPORT_COORD:
+		length = hx_touch_data->touch_info_size;
+		break;
+#if (HX_SMART_WAKEUP == 0x01)
+		/* SMWP */
+	case HX_REPORT_SMWP_EVENT:
+		length = (GEST_PTLG_ID_LEN + GEST_PTLG_HDR_LEN);
+		break;
+#endif
+	case HX_REPORT_COORD_RAWDATA:
+		length = hx_touch_data->touch_info_size;
+		break;
+	default:
+		I("%s, Normal error!\n", __func__);
+		*ts_status = HX_PATH_FAIL;
+		break;
+	}
+	if (*ts_status != HX_PATH_FAIL) {
+
+		for (i = 0; i < length; i++) {
+			check_sum_cal += buf[i];
+			if (buf[i] == 0x00U) {
+				zero_cnt++;
+			}
+		}
+
+		if (ts_path == HX_REPORT_COORD_RAWDATA) {
+			zero_cnt = 0;
+		}
+
+		if ((check_sum_cal % 0x100U) != 0U) {
+			I("point data_checksum not match check_sum_cal: 0x%02X",
+			  check_sum_cal);
+			*ts_status = HX_CHKSUM_FAIL;
+		} else if (zero_cnt == length) {
+			if (ts->use_irq) {
+				I("[HIMAX TP MSG] All Zero event\n");
+			}
+
+			*ts_status = HX_CHKSUM_FAIL;
+		} else {
+			raw_data_sel = (buf[HX_TOUCH_INFO_POINT_CNT] >> 4U) & 0x0FU;
+			/*I("%s:raw_out_sel=%x , hx_touch_data->diag_cmd=%x.\n",*/
+			/*		__func__, raw_data_sel,*/
+			/*		hx_touch_data->diag_cmd);*/
+			/*raw data out not match skip it*/
+			if ((raw_data_sel != 0x0FU) &&
+				(raw_data_sel != hx_touch_data->diag_cmd)) {
+				/*I("%s:raw data out not match.\n", __func__);*/
+				if (hx_touch_data->diag_cmd == 0U) {
+					/*Need to clear event stack here*/
+					(void)himax_mcu_read_event_stack(
+						buf,
+						(128U - hx_touch_data->touch_info_size));
+					/*I("%s: size =%d, buf[0]=%x ,buf[1]=%x,*/
+					/*	buf[2]=%x, buf[3]=%x.\n",*/
+					/*	__func__,*/
+					/*	(128-hx_touch_data->touch_info_size),*/
+					/*	buf[0], buf[1], buf[2], buf[3]);*/
+					/*I("%s:also clear event stack.\n", __func__);*/
+				}
+				*ts_status = HX_READY_SERVE;
+			}
+		}
+	}
+
+	if (g_ts_dbg != 0) {
+		I("%s: END, ts_status=%d!\n", __func__, *ts_status);
+	}
+
+}
+
+#if (HX_EXCP_RECOVERY == 0x01)
+int himax_mcu_ic_excp_recovery(uint32_t hx_excp_event, uint32_t hx_zero_event,
+			       uint32_t length)
+{
+	int ret_val = NO_ERR;
+
+	if (hx_excp_event == length) {
+		g_zero_event_count = 0;
+		ret_val = HX_EXCP_EVENT;
+	} else if (hx_zero_event == length) {
+		if (g_zero_event_count > 5) {
+			g_zero_event_count = 0;
+			I("EXCEPTION event checked - ALL Zero.\n");
+			ret_val = HX_EXCP_EVENT;
+		} else {
+			g_zero_event_count++;
+			I("ALL Zero event is %d times.\n", g_zero_event_count);
+			ret_val = HX_ZERO_EVENT_COUNT;
+		}
+	} else {
+		/* do nothing*/
+	}
+
+	return ret_val;
+}
+
+static void himax_ts_event_check(struct himax_ts_data *ts, uint8_t *buf,
+				int ts_path, int *ts_status)
+{
+	uint32_t hx_excp_event = 0;
+	uint32_t hx_zero_event = 0;
+	int shaking_ret = 0;
+
+	uint32_t loop_i = 0;
+	uint32_t length = 0;
+
+	if (g_ts_dbg != 0) {
+		I("%s: Entering, ts_status=%d!\n", __func__, *ts_status);
+	}
+
+	/* Normal */
+	switch (ts_path) {
+	case HX_REPORT_COORD:
+		length = hx_touch_data->touch_info_size;
+		break;
+#if (HX_SMART_WAKEUP == 0x01)
+		/* SMWP */
+	case HX_REPORT_SMWP_EVENT:
+		length = (GEST_PTLG_ID_LEN + GEST_PTLG_HDR_LEN);
+		break;
+#endif
+	case HX_REPORT_COORD_RAWDATA:
+		length = hx_touch_data->touch_info_size;
+		break;
+	default:
+		I("%s, Neither Normal Nor SMWP error!\n", __func__);
+		*ts_status = HX_PATH_FAIL;
+		break;
+	}
+
+	if (*ts_status != HX_PATH_FAIL) {
+		if (g_ts_dbg != 0) {
+			I("Now Path=%d, Now status=%d, length=%d\n", ts_path, *ts_status,
+			  length);
+		}
+
+		for (loop_i = 0; loop_i < length; loop_i++) {
+			if (ts_path == HX_REPORT_COORD ||
+				ts_path == HX_REPORT_COORD_RAWDATA) {
+				/* case 2 EXCEPTION recovery flow-Disable */
+				if (buf[loop_i] == 0x00U) {
+					hx_zero_event++;
+				} else {
+					hx_zero_event = 0;
+					g_zero_event_count = 0;
+				}
+			}
+		}
+
+		if ((hx_excp_event == length || hx_zero_event == length) &&
+			(!HX_EXCP_RESET_ACTIVATE) && (hx_touch_data->diag_cmd == 0U) &&
+			(ts->in_self_test == 0)) {
+			shaking_ret = himax_mcu_ic_excp_recovery(hx_excp_event,
+								 hx_zero_event, length);
+
+			if (shaking_ret == HX_EXCP_EVENT) {
+				himax_excp_hw_reset();
+				*ts_status = HX_EXCP_EVENT;
+			} else if (shaking_ret == HX_ZERO_EVENT_COUNT) {
+				*ts_status = HX_ZERO_EVENT_COUNT;
+			} else {
+				I("I2C running. Nothing to be done!\n");
+				*ts_status = HX_IC_RUNNING;
+			}
+
+			/* drop 1st interrupts after chip reset */
+		} else if (HX_EXCP_RESET_ACTIVATE) {
+			HX_EXCP_RESET_ACTIVATE = false;
+			I("%s: Skip by HX_EXCP_RESET_ACTIVATE.\n", __func__);
+			*ts_status = HX_EXCP_REC_OK;
+		} else {
+			/* do nothing*/
+		}
+	}
+
+	if (g_ts_dbg != 0) {
+		I("%s: END, ts_status=%d!\n", __func__, *ts_status);
+	}
+
+}
+#endif
+
+static void himax_err_ctrl(struct himax_ts_data *ts, uint8_t *buf, int ts_path,
+			  int *ts_status)
+{
+	himax_checksum_cal(ts, buf, ts_path, ts_status);
+
+#if (HX_EXCP_RECOVERY == 0x01)
+	if (*ts_status == HX_CHKSUM_FAIL) {
+		himax_ts_event_check(ts, buf, ts_path, ts_status);
+	} else {
+		/* continuous N times record, not total N times. */
+		g_zero_event_count = 0;
+	}
+#endif
+	if (g_ts_dbg != 0) {
+		I("%s: END, ts_status=%d!\n", __func__, *ts_status);
+	}
+}
+/* end error_control*/
+
+/* start distribute_data*/
+static void himax_distribute_touch_data(uint8_t *buf, int ts_path, int *ts_status)
+{
+	uint8_t hx_state_info_pos = hx_touch_data->touch_info_size - 3U;
+
+	if (g_ts_dbg != 0) {
+		I("%s: Entering, ts_status=%d!\n", __func__, *ts_status);
+	}
+
+	if (ts_path == HX_REPORT_COORD) {
+		(void)memcpy(hx_touch_data->hx_coord_buf, &buf[0],
+		       hx_touch_data->touch_info_size);
+
+		if ((buf[hx_state_info_pos] != 0xFFU) &&
+		    (buf[hx_state_info_pos + 1U] != 0xFFU)) {
+			(void)memcpy(hx_touch_data->hx_state_info,
+			       &buf[hx_state_info_pos], 2);
+		} else {
+			(void)memset(hx_touch_data->hx_state_info, 0x00,
+			       sizeof(hx_touch_data->hx_state_info));
+		}
+
+#if (HX_EXCP_RECOVERY == 0x01)
+		if (HX_EXCP_RESET_ACTIVATE) {
+			(void)memcpy(hx_touch_data->hx_rawdata_buf,
+			       &buf[hx_touch_data->touch_info_size],
+			       hx_touch_data->touch_all_size -
+				       hx_touch_data->touch_info_size);
+		}
+#endif
+
+	} else if (ts_path == HX_REPORT_COORD_RAWDATA) {
+		(void)memcpy(hx_touch_data->hx_coord_buf, &buf[0],
+		       hx_touch_data->touch_info_size);
+
+		if ((buf[hx_state_info_pos] != 0xFFU) &&
+		    (buf[hx_state_info_pos + 1U] != 0xFFU)) {
+			(void)memcpy(hx_touch_data->hx_state_info,
+			       &buf[hx_state_info_pos], 2);
+		} else {
+			(void)memset(hx_touch_data->hx_state_info, 0x00,
+			       sizeof(hx_touch_data->hx_state_info));
+		}
+
+		(void)memcpy(hx_touch_data->hx_rawdata_buf,
+		       &buf[hx_touch_data->touch_info_size],
+		       hx_touch_data->touch_all_size -
+			       hx_touch_data->touch_info_size);
+#if (HX_SMART_WAKEUP == 0x01)
+	} else if (ts_path == HX_REPORT_SMWP_EVENT) {
+		(void)memcpy(hx_touch_data->hx_event_buf, buf,
+		       hx_touch_data->event_size);
+#endif
+	} else {
+		E("%s, Fail Path!\n", __func__);
+		*ts_status = HX_PATH_FAIL;
+	}
+
+	if (g_ts_dbg != 0) {
+		I("%s: End, ts_status=%d!\n", __func__, *ts_status);
+	}
+
+}
+/* end assign_data*/
+
+/* start parse_report_data*/
+static void himax_parse_report_points(struct himax_ts_data *ts, int ts_path)
+{
+	uint32_t x = 0;
+	uint32_t y = 0;
+	uint32_t w = 0;
+	uint8_t base = 0;
+	uint8_t event_id = 0;
+	uint8_t	palm_id = 0;
+	uint8_t loop_i = 0;
+
+	if (g_ts_dbg != 0) {
+		I("%s: start!\n", __func__);
+	}
+
+	ts->old_finger = ts->pre_finger_mask;
+	if (ts->hx_point_num == 0U) {
+		if (g_ts_dbg != 0) {
+			I("%s: hx_point_num = 0!\n", __func__);
+		}
+		return;
+	}
+	ts->pre_finger_mask = 0;
+	hx_touch_data->finger_on = 1;
+	AA_press = 1;
+
+	g_target_report_data->finger_num = ts->hx_point_num;
+	g_target_report_data->finger_on = hx_touch_data->finger_on;
+
+	if (g_ts_dbg != 0) {
+		I("%s:finger_num = 0x%2X, finger_on = %d\n", __func__, g_target_report_data->finger_num, g_target_report_data->finger_on);
+	}
+
+	for (loop_i = 0; loop_i < ts->nFinger_support; loop_i++) {
+		base = loop_i * 4U;
+
+		x = hx_touch_data->hx_coord_buf[base];
+		x = (x << 8U) | hx_touch_data->hx_coord_buf[base + 1U];
+		y = hx_touch_data->hx_coord_buf[base + 2U];
+		y = (y << 8U) | hx_touch_data->hx_coord_buf[base + 3U];
+		w = hx_touch_data
+			    ->hx_coord_buf[(ts->nFinger_support * 4U) + loop_i];
+
+		if (g_ts_dbg != 0) {
+			D("%s: now parsing[%d]:x=%d, y=%d, w=%d\n", __func__,
+			  loop_i, x, y, w);
+		}
+
+		if (ic_data->HX_IS_ID_EN) {
+			event_id = hx_touch_data->hx_coord_buf[base] >> 0x06U;
+			x = (uint32_t)hx_touch_data->hx_coord_buf[base] & 0x3FU;
+			x = (x << 8U) | hx_touch_data->hx_coord_buf[base + 1U];
+
+			if (ic_data->HX_ID_PALM_EN) {
+				palm_id = hx_touch_data->hx_coord_buf[base + 2U] >> 0x06U;
+				y = (uint32_t)hx_touch_data->hx_coord_buf[base + 2U] & 0x3FU;
+				y = (y << 8U) | hx_touch_data->hx_coord_buf[base + 3U];
+			}
+
+			if ((event_id == 0U) || (event_id == 3U)) { /*No touch event or Leave event*/
+				x = 0xFFFF;
+				y = 0xFFFF;
+			}
+			if (g_ts_dbg != 0) {
+				switch (event_id) {
+				case 1:
+					I("%s Event Enter!\n", __func__);
+					break;
+				case 2:
+					I("%s Event Moving!\n", __func__);
+					break;
+				case 3:
+					I("%s Event Leave!\n", __func__);
+					break;
+				default:
+					W("%s Undefined behavior!\n", __func__);
+					break;
+				}
+
+				if (ic_data->HX_ID_PALM_EN) {
+					if (palm_id == 1U) {
+						I("Plam event\n");
+					}
+				}
+				I("Parsing[%d]:x=%d, y=%d, event_id=%d, palm_id=%d\n",
+					loop_i, x, y, event_id, palm_id);
+			}
+		}
+
+		if ((x < ts->pdata->abs_x_max) &&
+		    (y < ts->pdata->abs_y_max)) {
+
+			g_target_report_data->x[loop_i] = x;
+			g_target_report_data->y[loop_i] = y;
+			g_target_report_data->w[loop_i] = w;
+			g_target_report_data->finger_id[loop_i] = 1;
+
+			if (ts->first_pressed == 0U) {
+				ts->first_pressed = 1;
+				I("S1@%d, %d\n", x, y);
+			}
+
+			ts->pre_finger_data[loop_i][0] = x;
+			ts->pre_finger_data[loop_i][1] = y;
+
+			ts->pre_finger_mask += (uint16_t)(1U << loop_i);
+		} else { /* report coordinates */
+			g_target_report_data->x[loop_i] = x;
+			g_target_report_data->y[loop_i] = y;
+			g_target_report_data->w[loop_i] = w;
+			g_target_report_data->finger_id[loop_i] = 0;
+
+			if ((loop_i == 0U) && (ts->first_pressed == 1U)) {
+				ts->first_pressed = 2;
+				I("E1@%d, %d\n", ts->pre_finger_data[0][0],
+				  ts->pre_finger_data[0][1]);
+			}
+		}
+	}
+
+	if (g_ts_dbg != 0) {
+		for (loop_i = 0; loop_i < 10U; loop_i++) {
+			D("DBG X=%d  Y=%d ID=%d\n",
+			  g_target_report_data->x[loop_i],
+			  g_target_report_data->y[loop_i],
+			  g_target_report_data->finger_id[loop_i]);
+		}
+
+		D("DBG finger number %d\n", g_target_report_data->finger_num);
+	}
+
+	if (g_ts_dbg != 0) {
+		I("%s: end!\n", __func__);
+	}
+
+}
+
+static void himax_parse_report_data(struct himax_ts_data *ts, int ts_path,
+				   int *ts_status)
+{
+	uint8_t EN_NoiseFilter;
+
+	if (g_ts_dbg != 0) {
+		I("%s: start now_status=%d!\n", __func__, *ts_status);
+	}
+
+	EN_NoiseFilter =
+		(hx_touch_data->hx_coord_buf[HX_TOUCH_INFO_POINT_CNT + 2U] >> 3U);
+	/* I("EN_NoiseFilter=%d\n", EN_NoiseFilter); */
+	EN_NoiseFilter = EN_NoiseFilter & 0x01U;
+	/* I("EN_NoiseFilter2=%d\n", EN_NoiseFilter); */
+
+	if (hx_touch_data->hx_coord_buf[HX_TOUCH_INFO_POINT_CNT] == 0xFFU) {
+		ts->hx_point_num = 0;
+	} else {
+		ts->hx_point_num =
+			hx_touch_data->hx_coord_buf[HX_TOUCH_INFO_POINT_CNT] &
+			0x0FU;
+	}
+
+	switch (ts_path) {
+	case HX_REPORT_COORD:
+		himax_parse_report_points(ts, ts_path);
+		break;
+	case HX_REPORT_COORD_RAWDATA:
+		/* touch monitor rawdata */
+		if (debug_data != NULL) {
+			if (debug_data->fp_set_diag_cmd(ic_data, hx_touch_data) != 0) {
+				I("%s:raw data_checksum not match\n", __func__);
+			}
+		} else {
+			E("%s,There is no init set_diag_cmd\n", __func__);
+		}
+		himax_parse_report_points(ts, ts_path);
+		break;
+#if (HX_SMART_WAKEUP == 0x01)
+	case HX_REPORT_SMWP_EVENT:
+		(void)himax_wake_event_parse(ts);
+		break;
+#endif
+	default:
+		E("%s:Fail Path!\n", __func__);
+		*ts_status = HX_PATH_FAIL;
+		break;
+	}
+	if (g_ts_dbg != 0) {
+		I("%s: end now_status=%d!\n", __func__, *ts_status);
+	}
+}
+
+/* end parse_report_data*/
+
+static void himax_report_all_leave_event(struct himax_ts_data *ts)
+{
+	uint8_t loop_i = 0;
+
+	for (loop_i = 0; loop_i < ts->nFinger_support; loop_i++) {
+#if (HX_PROTOCOL_A == 0x00)
+		input_mt_slot(ts->input_dev, loop_i);
+		input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+		input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+		input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 0);
+		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
+#endif
+	}
+	input_report_key(ts->input_dev, BTN_TOUCH, 0);
+	input_sync(ts->input_dev);
+}
+
+void himax_mcu_clear_event_stack(void)
+{
+	uint32_t addr_clear_event_stack = 0x80060014U;
+	uint8_t data[DATA_LEN_4] = {0};
+
+	himax_mcu_register_read(addr_clear_event_stack, DATA_LEN_4, data);
+	data[0] |= 0x02U;
+	himax_mcu_register_write(addr_clear_event_stack, DATA_LEN_4,
+					 data);
+
+}
+
+/* start report_point*/
+static void himax_finger_report(struct himax_ts_data *ts)
+{
+	uint8_t i = 0;
+	bool valid = false;
+#if (HX_TP_GTS_MODE == 0x01)
+	int debounce_cnt = 3620; /* 3620 * 8.3ms = 30 sec. */
+#endif
+
+	if (g_ts_dbg != 0) {
+		I("%s:start ts->hx_point_num=%d\n", __func__, ts->hx_point_num);
+	}
+
+	for (i = 0; i < ts->nFinger_support; i++) {
+#if (HX_TP_GTS_MODE == 0x01)
+		if (ts->GTS_range > 0U) {
+			if ((g_target_report_data->x[i] != 0xFFFFU) ||
+			    (g_target_report_data->y[i] != 0xFFFFU)) {
+				/*
+				 *I("report_data->x[i]=%d,y[i]=%d",
+					g_target_report_data->x[i],
+					g_target_report_data->y[i]);
+				I("pre_report_data->pre_x[i]=%d,pre_y[i]=%d",
+					fixed_point_label->x[i],
+					fixed_point_label->y[i]);
+				*/
+				if ((fixed_point_label->x[i] == 0xFFFFU) &&
+				    (fixed_point_label->y[i] == 0xFFFFU)) {
+					/*I("fixed point appears\n");*/
+					fixed_point_label->fpt_cnt[i] = 0;
+					fixed_point_label->x[i] =
+						g_target_report_data->x[i];
+					fixed_point_label->y[i] =
+						g_target_report_data->y[i];
+				}
+				if (((g_target_report_data->x[i] -
+					     fixed_point_label->x[i]) <
+				     ts->GTS_range) &&
+				    ((fixed_point_label->x[i] -
+					     g_target_report_data->x[i]) <
+				     ts->GTS_range) &&
+				    ((fixed_point_label->y[i] -
+					     g_target_report_data->y[i]) <
+				     ts->GTS_range) &&
+				    ((g_target_report_data->y[i] -
+					     fixed_point_label->y[i]) <
+				     ts->GTS_range)) { /* in range */
+					fixed_point_label->fpt_cnt[i]++;
+					/*I("fpt_cnt[%d] = %d\n", i, fixed_point_label->fpt_cnt[i]);*/
+				} else { /* out of range */
+					fixed_point_label->fpt_cnt[i] = 0;
+					fixed_point_label->x[i] = 0xFFFF;
+					fixed_point_label->y[i] = 0xFFFF;
+				}
+			} else { /* finger leave */
+				fixed_point_label->fpt_cnt[i] = 0;
+				fixed_point_label->x[i] = 0xFFFF;
+				fixed_point_label->y[i] = 0xFFFF;
+			}
+			if (fixed_point_label->fpt_cnt[i] >
+			    debounce_cnt) { /* 3620 * 8.3ms = 30 sec. */
+				I("[Ghost] point happens !!!");
+				fixed_point_label->fpt_cnt[i] = 0;
+				himax_report_all_leave_event(ts);
+				himax_mcu_system_reset();
+				return;
+			}
+		}
+#endif
+
+		if ((g_target_report_data->x[i] < ts->pdata->abs_x_max) &&
+		    (g_target_report_data->y[i] < ts->pdata->abs_y_max)) {
+			valid = true;
+		} else {
+			valid = false;
+		}
+		if (g_ts_dbg != 0) {
+			I("valid=%d\n", valid);
+		}
+		if (valid) {
+			if (g_ts_dbg != 0) {
+				I("report_data->x[i]=%d,y[i]=%d,w[i]=%d",
+				  g_target_report_data->x[i],
+				  g_target_report_data->y[i],
+				  g_target_report_data->w[i]);
+			}
+#if (HX_PROTOCOL_A == 0x00)
+			input_mt_slot(ts->input_dev, i);
+#else
+			input_report_key(ts->input_dev, BTN_TOUCH, 1);
+#endif
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR,
+					 g_target_report_data->w[i]);
+#if (HX_PROTOCOL_A == 0x00)
+			input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR,
+					 g_target_report_data->w[i]);
+			input_report_abs(ts->input_dev, ABS_MT_PRESSURE,
+					 g_target_report_data->w[i]);
+#else
+			input_report_abs(ts->input_dev, ABS_MT_TRACKING_ID, i);
+#endif
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_X,
+					 g_target_report_data->x[i]);
+			input_report_abs(ts->input_dev, ABS_MT_POSITION_Y,
+					 g_target_report_data->y[i]);
+#if (HX_PROTOCOL_A == 0x00)
+			ts->last_slot = i;
+			input_mt_report_slot_state(ts->input_dev,
+						   MT_TOOL_FINGER, 1);
+#else
+			input_mt_sync(ts->input_dev);
+#endif
+		} else {
+#if (HX_PROTOCOL_A == 0x00)
+			input_mt_slot(ts->input_dev, i);
+			input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+			input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+			input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 0);
+			input_mt_report_slot_state(ts->input_dev,
+						   MT_TOOL_FINGER, 0);
+#endif
+		}
+	}
+#if (HX_PROTOCOL_A == 0x00)
+	input_report_key(ts->input_dev, BTN_TOUCH, 1);
+#endif
+	input_sync(ts->input_dev);
+
+	if (g_ts_dbg != 0) {
+		I("%s:end\n", __func__);
+	}
+}
+
+static void himax_finger_leave(struct himax_ts_data *ts)
+{
+#if (HX_PROTOCOL_A == 0x00)
+	uint8_t loop_i = 0;
+#endif
+
+	if (g_ts_dbg != 0) {
+		I("%s: start!\n", __func__);
+	}
+
+	hx_touch_data->finger_on = 0;
+	g_target_report_data->finger_on = 0;
+	g_target_report_data->finger_num = 0;
+	AA_press = 0;
+
+#if (HX_PROTOCOL_A == 0x01)
+	input_mt_sync(ts->input_dev);
+#endif
+#if (HX_PROTOCOL_A == 0x00)
+	for (loop_i = 0; loop_i < ts->nFinger_support; loop_i++) {
+		input_mt_slot(ts->input_dev, loop_i);
+		input_report_abs(ts->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+		input_report_abs(ts->input_dev, ABS_MT_WIDTH_MAJOR, 0);
+		input_report_abs(ts->input_dev, ABS_MT_PRESSURE, 0);
+		input_mt_report_slot_state(ts->input_dev, MT_TOOL_FINGER, 0);
+	}
+#endif
+	if (ts->pre_finger_mask > 0U) {
+		ts->pre_finger_mask = 0U;
+	}
+
+	if (ts->first_pressed == 1U) {
+		ts->first_pressed = 2U;
+		I("E1@%d, %d\n", ts->pre_finger_data[0][0],
+		  ts->pre_finger_data[0][1]);
+	}
+
+	input_report_key(ts->input_dev, BTN_TOUCH, 0);
+	input_sync(ts->input_dev);
+
+	if (g_ts_dbg != 0) {
+		I("%s: end!\n", __func__);
+	}
+
+}
+
+static void himax_report_points(struct himax_ts_data *ts)
+{
+	if (g_ts_dbg != 0) {
+		I("%s: start!\n", __func__);
+	}
+
+	if (ts->hx_point_num != 0U) {
+		himax_finger_report(ts);
+	} else {
+		himax_finger_leave(ts);
+	}
+
+	if (g_ts_dbg != 0) {
+		I("%s: end!\n", __func__);
+	}
+}
+/* end report_points*/
+
+static void himax_report_data(struct himax_ts_data *ts, int ts_path, int *ts_status)
+{
+	if (g_ts_dbg != 0) {
+		I("%s: Entering, ts_status=%d!\n", __func__, *ts_status);
+	}
+
+	if ((ts_path == HX_REPORT_COORD) || (ts_path == HX_REPORT_COORD_RAWDATA)) {
+		/* Touch Point information */
+		himax_report_points(ts);
+
+#if (HX_SMART_WAKEUP == 0x01)
+	} else if (ts_path == HX_REPORT_SMWP_EVENT) {
+		himax_wake_event_report();
+#endif
+	} else {
+		E("%s:Fail Path!\n", __func__);
+		*ts_status = HX_PATH_FAIL;
+	}
+
+	if (g_ts_dbg != 0) {
+		I("%s: END, ts_status=%d!\n", __func__, *ts_status);
+	}
+}
+/* end report_data */
+
+static void himax_ts_operation(struct himax_ts_data *ts, int ts_path,
+			      int *ts_status)
+{
+	(void)memset(ts->xfer_buff, 0x00, 128U * sizeof(uint8_t));
+
+	himax_touch_get(ts, ts->xfer_buff, ts_path, ts_status);
+	if (*ts_status == HX_TS_GET_DATA_FAIL) {
+		/* do nothing */
+	} else {
+		himax_distribute_touch_data(ts->xfer_buff, ts_path, ts_status);
+		himax_err_ctrl(ts, ts->xfer_buff, ts_path, ts_status);
+
+		if ((*ts_status == HX_REPORT_DATA) || (*ts_status == HX_TS_NORMAL_END) ||
+			(*ts_status == HX_READY_SERVE)) {
+			himax_parse_report_data(ts, ts_path, ts_status);
+			himax_report_data(ts, ts_path, ts_status);
+		}
+	}
+}
+
+#if defined(PANEL_ID_CHECK)
+static int himax_check_panel_id(void)
+{
+	uint8_t data[10] = { 0 };
+	int ret = -1;
+
+	himax_mcu_write_dd_reg_password(IC_MASTER);
+
+	himax_mcu_dd_reg_read(0xD1, 1, 10, data, 2 * 4, IC_MASTER);
+
+	himax_mcu_clear_dd_reg_password(IC_MASTER);
+
+	if (((char) data[0] == 'S') && ((char) data[1] == '1') && ((char) data[2] == '0') &&
+	    ((char) data[3] == '6') && ((char) data[4] == 'A') && ((char) data[5] == 'K') &&
+	    ((char) data[6] == '1') && ((char) data[7] == '1') && ((char) data[8] == '0') &&
+	    ((char) data[9] == '0')) {
+		I("%s: Current panel id is TIANMA\n", __func__);
+		ret = PANEL_TIANMA;
+	} else if (((char) data[0] == 'S') && ((char) data[1] == '1') && ((char) data[2] == '0') &&
+		   ((char) data[3] == '6') && ((char) data[4] == 'A') && ((char) data[5] == 'K') &&
+		   ((char) data[6] == '1') && ((char) data[7] == '3') && ((char) data[8] == '0') &&
+		   ((char) data[9] == '0')) {
+		I("%s: Current panel id is BOE\n", __func__);
+		ret = PANEL_BOE;
+	} else {
+		/* do nothing*/
+	}
+
+	return ret;
+}
+#endif
+
+
+void himax_fail_det_work(void)
+{
+	uint8_t data[30] = { 0 };
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	/*
+	 *	uint8_t addr[4] = {0xD4, 0x74, 0x00, 0x10};
+	 *	uint32_t tmp_addr_32 = 0x100074D4;
+	 *	Clear Simulation Register
+	 *	himax_mcu_register_write(tmp_addr_32, DATA_LEN_4, data);
+	 */
+	himax_mcu_write_dd_reg_password(IC_MASTER);
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83195)
+	himax_mcu_dd_reg_read(0xE5, 0, 10, &data[0], 0, IC_MASTER);
+	himax_mcu_dd_reg_read(0xE5, 10, 10, &data[10], 0, IC_MASTER);
+	himax_mcu_dd_reg_read(0xE5, 20, 2, &data[20], 0, IC_MASTER);
+	I(PA_LOG_1, "E5_Bank0:", data[1], data[2], data[3], data[4]);
+	I(PA_LOG_3, "E5_Bank0:", data[5], data[6], data[7], data[8]);
+	I(PA_LOG_4, "E5_Bank0:", data[9], data[10], data[11], data[12]);
+	I(PA_LOG_5, "E5_Bank0:", data[13], data[14], data[15], data[16]);
+	I(PA_LOG_6, "E5_Bank0:", data[17], data[18], data[19], data[20]);
+	I(PA_LOG_7, "E5_Bank0:", data[21]);
+
+	himax_mcu_dd_reg_read(0xE5, 0, 10, &data[0], 4, IC_MASTER);
+	himax_mcu_dd_reg_read(0xE5, 10, 10, &data[10], 4, IC_MASTER);
+	himax_mcu_dd_reg_read(0xE5, 20, 1, &data[20], 4, IC_MASTER);
+	I(PA_LOG_1, "E5_Bank1:", data[1], data[2], data[3], data[4]);
+	I(PA_LOG_3, "E5_Bank1:", data[5], data[6], data[7], data[8]);
+	I(PA_LOG_4, "E5_Bank1:", data[9], data[10], data[11], data[12]);
+	I(PA_LOG_5, "E5_Bank1:", data[13], data[14], data[15], data[16]);
+	I(PA_LOG_6, "E5_Bank1:", data[17], data[18], data[19], data[20]);
+#else
+	himax_mcu_dd_reg_read(0xE5, 0, 8, data, 0, IC_MASTER);
+	I(PA_LOG_1, "E5_Bank0:", data[1], data[2], data[3], data[4]);
+	I(PA_LOG_2, "E5_Bank0:", data[5], data[6], data[7]);
+
+	himax_mcu_dd_reg_read(0xE5, 0, 8, data, 4, IC_MASTER);
+	I(PA_LOG_1, "E5_Bank1:", data[1], data[2], data[3], data[4]);
+	I(PA_LOG_2, "E5_Bank1:", data[5], data[6], data[7]);
+
+	himax_mcu_dd_reg_read(0xE5, 0, 8, data, 12, IC_MASTER);
+	I(PA_LOG_1, "E5_Bank3:", data[1], data[2], data[3], data[4]);
+	I(PA_LOG_2, "E5_Bank3:", data[5], data[6], data[7]);
+#endif
+
+	himax_mcu_clear_dd_reg_password(IC_MASTER);
+
+	himax_mcu_register_read(addr_fail_det_GPIO1_msg, DATA_LEN_4, tmp_data);
+	I("%s: 100074C0 value is: tmp_data[1] = 0x%2.2x, tmp_data[1] = 0x%2.2x\n",
+	  __func__, tmp_data[0], tmp_data[1]);
+	I("%s: 100074C0 value is: tmp_data[2] = 0x%2.2x, tmp_data[3] = 0x%2.2x\n",
+	  __func__, tmp_data[2], tmp_data[3]);
+
+	/*	It depends on customer: */
+	goto AP_recovery;
+
+AP_recovery:
+
+	I("%s: Now FAIL_DET pulls high means IC need external recovery\n",
+	  __func__);
+#if (HX_RST_PIN_FUNC == 0x01)
+	if (himax_mcu_tp_lcm_pin_reset()) {
+		himax_mcu_tp_reset();
+	}
+#elif (HX_RST_PIN_FUNC == 0x02)
+	/* Need Customer do AP recovery */
+#endif
+}
+
+void himax_ts_work(struct himax_ts_data *ts)
+{
+	int *ts_status = kzalloc(sizeof(int), GFP_KERNEL);
+	int ts_path = 0;
+
+	*ts_status = HX_TS_NORMAL_END;
+
+	if (debug_data != NULL) {
+		debug_data->fp_ts_dbg_func(ts, HX_FINGER_ON);
+	}
+
+	ts_path = himax_ts_work_status(ts);
+
+	switch (ts_path) {
+	case HX_REPORT_COORD:
+		himax_ts_operation(ts, ts_path, ts_status);
+		break;
+	case HX_REPORT_COORD_RAWDATA:
+		himax_ts_operation(ts, ts_path, ts_status);
+		break;
+#if (HX_SMART_WAKEUP == 0x01)
+	case HX_REPORT_SMWP_EVENT:
+		himax_ts_operation(ts, ts_path, ts_status);
+		break;
+#endif
+	default:
+		E("%s:Path Fault! value=%d\n", __func__, ts_path);
+		*ts_status = HX_PATH_FAIL;
+		break;
+	}
+	if (*ts_status != HX_PATH_FAIL) {
+		if (*ts_status == HX_TS_GET_DATA_FAIL) {
+			I("%s: Now reset the Touch chip.\n", __func__);
+#if (HX_RST_PIN_FUNC == 0x01)
+			himax_mcu_hw_reset(true);
+#elif (HX_RST_PIN_FUNC == 0x02)
+			/* Need Customer do TP reset pin */
+#else
+			himax_mcu_system_reset();
+#endif
+		}
+	}
+
+	if (debug_data != NULL) {
+		debug_data->fp_ts_dbg_func(ts, HX_FINGER_LEAVE);
+	}
+	kfree(ts_status);
+	ts_status = NULL;
+}
+/*end ts_work*/
+enum hrtimer_restart himax_ts_timer_func(struct hrtimer *timer)
+{
+	struct himax_ts_data *ts;
+
+	ts = container_of(timer, struct himax_ts_data, timer);
+	queue_work(ts->himax_wq, &ts->work);
+	hrtimer_start(&ts->timer, ktime_set(0, 12500000), HRTIMER_MODE_REL);
+	return HRTIMER_NORESTART;
+}
+
+#if (HX_BOOT_UPGRADE == 0x01)
+void himax_boot_upgrade(struct work_struct *work)
+{
+#if (HX_FIX_TOUCH_INFO == 0x00)
+	int ret = 0;
+#endif
+
+	if (himax_force_update_FW_check() == 0) {
+		ic_data->FW_update_flag = 0x01U;
+		goto UPDATE_FW;
+	}
+
+	if (i_get_FW() != 0) {
+		return;
+	}
+
+	(void)hx_mcu_bin_desc_get((unsigned char *)hxfw->data, HX1K);
+
+	if (g_boot_upgrade_flag == true) {
+		ic_data->FW_update_flag = 0x02U;
+		I("%s: Forced upgrade\n", __func__);
+		goto UPDATE_FW;
+	}
+
+	if (himax_auto_update_check() != 0) {
+		goto SKIP_UPDATE_FW;
+	}
+
+UPDATE_FW:
+	if (i_update_FW() <= 0) {
+		E("%s: Update FW fail\n", __func__);
+	} else {
+		g_boot_upgrade_flag = false;
+		I("%s: Update FW success\n", __func__);
+#if (HX_FIX_TOUCH_INFO == 0x00)
+		if (private_ts->input_dev) {
+			input_unregister_device(private_ts->input_dev);
+		} else {
+			input_free_device(private_ts->input_dev);
+		}
+
+		himax_report_data_deinit();
+		calculate_point_number();
+		ret |= himax_input_register(private_ts);
+		ret |= himax_report_data_init();
+#endif
+	}
+
+SKIP_UPDATE_FW:
+	release_firmware(hxfw);
+	hxfw = NULL;
+}
+#endif
+
+#if defined(HX_CONFIG_FB) || defined(HX_CONFIG_DRM)
+static void himax_fb_register(struct work_struct *work)
+{
+	int ret = 0;
+
+	struct himax_ts_data *ts =
+		container_of(work, struct himax_ts_data, work_att.work);
+
+	I("%s in\n", __func__);
+#if defined(HX_CONFIG_FB)
+	ts->fb_notif.notifier_call = fb_notifier_callback;
+	ret = fb_register_client(&ts->fb_notif);
+#elif defined(HX_CONFIG_DRM)
+#if defined(__HIMAX_MOD__)
+	hx_msm_drm_register_client =
+		(void *)kallsyms_lookup_name("msm_drm_register_client");
+	if (hx_msm_drm_register_client != NULL) {
+		ts->fb_notif.notifier_call = drm_notifier_callback;
+		ret = hx_msm_drm_register_client(&ts->fb_notif);
+	} else {
+		E("hx_msm_drm_register_client is NULL\n");
+	}
+#else
+	ts->fb_notif.notifier_call = drm_notifier_callback;
+	ret = msm_drm_register_client(&ts->fb_notif);
+#endif
+#endif
+	if (ret != 0) {
+		E("Unable to register fb_notifier: %d\n", ret);
+	}
+}
+#endif
+
+static bool hx_ic_register(void)
+{
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83192)
+	if (hx83192_init()) {
+		return true;
+	}
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83193)
+	if (hx83193_init()) {
+		return true;
+	}
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83194)
+	if (hx83194_init()) {
+		return true;
+	}
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83195)
+	if (hx83195_init()) {
+		return true;
+	}
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83180)
+	if (hx83180_init()) {
+		return true;
+	}
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83181)
+	if (hx83181_init()) {
+		return true;
+	}
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+	if (hx8530_init()) {
+		return true;
+	}
+#endif
+	E("%s: There is no IC!\n", __func__);
+	return false;
+}
+
+int himax_chip_common_init(void)
+{
+	int ret = 0;
+	int err = PROBE_FAIL;
+	struct himax_ts_data *ts = private_ts;
+	struct himax_i2c_platform_data *pdata;
+
+#if (HX_TP_GTS_MODE == 0x01)
+	ts->GTS_range = 4;
+#endif
+
+	himax_print_define_function();
+
+	ts->xfer_buff =
+		devm_kzalloc(ts->dev, 128U * sizeof(uint8_t), GFP_KERNEL);
+	if (ts->xfer_buff == NULL) {
+		err = -ENOMEM;
+		goto err_xfer_buff_fail;
+	}
+
+	pdata = kzalloc(sizeof(struct himax_i2c_platform_data), GFP_KERNEL);
+	if (pdata == NULL) { /*Allocate Platform data space*/
+		err = -ENOMEM;
+		goto err_dt_platform_data_fail;
+	}
+
+	ic_data = kzalloc(sizeof(struct himax_ic_data), GFP_KERNEL);
+	if (ic_data == NULL) { /*Allocate IC data space*/
+		err = -ENOMEM;
+		goto err_dt_ic_data_fail;
+	}
+
+	/* allocate report data */
+	hx_touch_data = kzalloc(sizeof(struct himax_report_data), GFP_KERNEL);
+	if (hx_touch_data == NULL) {
+		err = -ENOMEM;
+		goto err_alloc_touch_data_failed;
+	}
+
+	ts->pdata = pdata;
+	if (himax_parse_dt(ts, pdata) < 0) {
+		I(" pdata is NULL for DT\n");
+		goto err_alloc_dt_pdata_failed;
+	}
+
+	ts->lcm_gpio = pdata->RESX;
+	ts->pon_gpio = pdata->PON;
+	ts->chip_test_mpap_flag = false;
+
+#if (HX_RST_PIN_FUNC == 0x01)
+	ts->rst_gpio = pdata->tp_ext_rstn;
+#endif
+	(void)himax_gpio_power_config(pdata);
+	(void)himax_interrupt_gpio_config(pdata);
+
+#if defined(HIMAX_I2C_PLATFORM)
+	himax_mcu_interface_on();
+#endif
+
+	g_hx_chip_inited = false;
+
+	if (!hx_ic_register()) {
+		E("%s: can't detect IC!\n", __func__);
+		goto error_ic_detect_failed;
+	}
+
+	if (!g_core_fp.fp_calculateChecksum(ic_data->HX_FW_SIZE)) {
+		E("%s: check flash fail, please upgrade FW\n", __func__);
+#if (HX_BOOT_UPGRADE == 0x01)
+		g_boot_upgrade_flag = true;
+#endif
+
+#if (HX_FIX_TOUCH_INFO == 0x01)
+		g_core_fp.fp_touch_information();
+#endif
+
+	} else {
+		himax_mcu_config_reload_enable();
+		himax_mcu_power_on_init();
+		himax_mcu_read_FW_ver();
+		g_core_fp.fp_touch_information();
+	}
+
+	ret = himax_mcu_flash_id_check();
+
+	if (ret == HX_FAIL) {
+		I("%s: Cannot recognize flash id type\n", __func__);
+	}
+
+#if (HX_BOOT_UPGRADE == 0x01)
+	ts->himax_boot_upgrade_wq =
+		create_singlethread_workqueue("HX_boot_upgrade");
+	if (!ts->himax_boot_upgrade_wq) {
+		E("allocate himax_boot_upgrade_wq failed\n");
+		err = -ENOMEM;
+		goto err_boot_upgrade_wq_failed;
+	}
+	INIT_DELAYED_WORK(&ts->work_boot_upgrade, himax_boot_upgrade);
+	queue_delayed_work(ts->himax_boot_upgrade_wq, &ts->work_boot_upgrade,
+			   msecs_to_jiffies(2000));
+#endif
+	calculate_point_number();
+
+#if defined(PANEL_ID_CHECK)
+	ts->panel_id = himax_check_panel_id();
+#endif
+
+#if defined(CONFIG_OF)
+	ts->power = pdata->power;
+#endif
+
+#if defined(CONFIG_OF)
+	ts->pdata->abs_pressure_min = 0;
+	ts->pdata->abs_pressure_max = 200;
+	ts->pdata->abs_width_min = 0;
+	ts->pdata->abs_width_max = 200;
+#endif
+	ts->suspended = false;
+
+#if (HX_PROTOCOL_A == 0x01)
+	ts->protocol_type = (uint8_t)PROTOCOL_TYPE_A;
+#else
+	ts->protocol_type = (uint8_t)PROTOCOL_TYPE_B;
+#endif
+	I("%s: Use Protocol Type %c\n", __func__,
+	  (ts->protocol_type == (uint8_t)PROTOCOL_TYPE_A) ? 'A' : 'B');
+
+	ret = himax_input_register(ts);
+	if (ret != 0) {
+		goto err_input_register_device_failed;
+	}
+
+	spin_lock_init(&ts->irq_lock);
+	ts->initialized = true;
+
+#if defined(HX_CONFIG_FB) || defined(HX_CONFIG_DRM)
+	ts->himax_att_wq = create_singlethread_workqueue("HMX_ATT_request");
+
+	if (!ts->himax_att_wq) {
+		E(" allocate himax_att_wq failed\n");
+		err = -ENOMEM;
+		goto err_get_intr_bit_failed;
+	}
+
+	INIT_DELAYED_WORK(&ts->work_att, himax_fb_register);
+	queue_delayed_work(ts->himax_att_wq, &ts->work_att,
+			   msecs_to_jiffies(15000));
+#endif
+
+#if (HX_SMART_WAKEUP == 0x01)
+	ts->SMWP_enable = true;
+#if defined(KERNEL_VER_ABOVE_4_14)
+	ts->ts_SMWP_wake_lock =
+		wakeup_source_register(ts->dev, HIMAX_common_NAME);
+#else
+	wakeup_source_init(ts->ts_SMWP_wake_lock, HIMAX_common_NAME);
+#endif
+#endif
+
+	/*touch data init*/
+	err = himax_report_data_init();
+
+	if (err < 0) {
+		goto err_report_data_init_failed;
+	}
+
+	if (!himax_common_proc_init()) {
+		E(" %s: himax_common proc_init failed!\n", __func__);
+		goto err_creat_proc_file_failed;
+	}
+
+	(void)himax_ts_register_interrupt();
+#if (HX_BOOT_UPGRADE == 0x01)
+	if (g_boot_upgrade_flag) {
+		himax_int_enable(0);
+	}
+#endif
+
+	(void)himax_fail_det_register_interrupt();
+
+	spin_lock_init(&ts->fail_det_lock);
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_DEBUG)
+	if (himax_debug_init() != 0) {
+		E(" %s: debug initial failed!\n", __func__);
+	}
+#endif
+
+	g_hx_chip_inited = true;
+	return 0;
+
+err_creat_proc_file_failed:
+	himax_report_data_deinit();
+err_report_data_init_failed:
+#if (HX_SMART_WAKEUP == 0x01)
+#if defined(KERNEL_VER_ABOVE_4_14)
+	wakeup_source_unregister(ts->ts_SMWP_wake_lock);
+#else
+	wakeup_source_trash(ts->ts_SMWP_wake_lock);
+#endif
+#endif
+#if defined(HX_CONFIG_FB) || defined(HX_CONFIG_DRM)
+	cancel_delayed_work_sync(&ts->work_att);
+	destroy_workqueue(ts->himax_att_wq);
+err_get_intr_bit_failed:
+#endif
+err_input_register_device_failed:
+	if (ts->input_dev != NULL) {
+		input_unregister_device(ts->input_dev);
+	} else {
+		input_free_device(ts->input_dev);
+	}
+	/*err_detect_failed:*/
+
+#if (HX_BOOT_UPGRADE == 0x01)
+	cancel_delayed_work_sync(&ts->work_boot_upgrade);
+	destroy_workqueue(ts->himax_boot_upgrade_wq);
+err_boot_upgrade_wq_failed:
+#endif
+
+error_ic_detect_failed:
+	himax_gpio_power_deconfig(pdata);
+#if !defined(CONFIG_OF)
+err_power_failed:
+#endif
+err_alloc_dt_pdata_failed:
+	kfree(hx_touch_data);
+	hx_touch_data = NULL;
+err_alloc_touch_data_failed:
+	kfree(ic_data);
+	ic_data = NULL;
+err_dt_ic_data_fail:
+	kfree(pdata);
+	pdata = NULL;
+err_dt_platform_data_fail:
+	devm_kfree(ts->dev, ts->xfer_buff);
+	ts->xfer_buff = NULL;
+err_xfer_buff_fail:
+	probe_fail_flag = 1;
+	return err;
+}
+
+void himax_chip_common_deinit(void)
+{
+	struct himax_ts_data *ts = private_ts;
+
+	(void)himax_ts_unregister_interrupt();
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_SELF_TEST)
+	himax_self_test_data_clear();
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_DEBUG)
+	himax_debug_remove();
+#endif
+
+	himax_common_proc_deinit();
+	himax_report_data_deinit();
+
+#if (HX_SMART_WAKEUP == 0x01)
+#if defined(KERNEL_VER_ABOVE_4_14)
+	wakeup_source_unregister(ts->ts_SMWP_wake_lock);
+#else
+	wakeup_source_trash(ts->ts_SMWP_wake_lock);
+#endif
+#endif
+#if defined(HX_CONFIG_FB)
+	if (fb_unregister_client(&ts->fb_notif) != 0) {
+		E("Error occurred while unregistering fb_notifier.\n");
+	}
+	cancel_delayed_work_sync(&ts->work_att);
+	destroy_workqueue(ts->himax_att_wq);
+#elif defined(HX_CONFIG_DRM)
+#if defined(__HIMAX_MOD__)
+	hx_msm_drm_unregister_client =
+		(void *)kallsyms_lookup_name("msm_drm_unregister_client");
+	if (hx_msm_drm_unregister_client != NULL) {
+		if (hx_msm_drm_unregister_client(&ts->fb_notif) != 0) {
+			E("Error occurred while unregistering drm_notifier.\n");
+		}
+	} else {
+		E("hx_msm_drm_unregister_client is NULL\n");
+	}
+#else
+	if (msm_drm_unregister_client(&ts->fb_notif) != 0) {
+		E("Error occurred while unregistering drm_notifier.\n");
+	}
+#endif
+	cancel_delayed_work_sync(&ts->work_att);
+	destroy_workqueue(ts->himax_att_wq);
+#endif
+	if (ts->input_dev != NULL) {
+		input_unregister_device(ts->input_dev);
+	} else {
+		input_free_device(ts->input_dev);
+	}
+
+#if (HX_BOOT_UPGRADE == 0x01)
+	cancel_delayed_work_sync(&ts->work_boot_upgrade);
+	destroy_workqueue(ts->himax_boot_upgrade_wq);
+#endif
+	himax_gpio_power_deconfig(ts->pdata);
+
+	kfree(hx_touch_data);
+	hx_touch_data = NULL;
+	kfree(ic_data);
+	ic_data = NULL;
+	devm_kfree(ts->dev, ts->xfer_buff);
+	ts->xfer_buff = NULL;
+	kfree(ts->pdata);
+	ts->pdata = NULL;
+	kfree(ts);
+	ts = NULL;
+	probe_fail_flag = 0;
+
+	I("%s: Common section deinited!\n", __func__);
+}
+
+void himax_chip_common_suspend(struct himax_ts_data *ts)
+{
+	if (ts->suspended) {
+		I("%s: Already suspended. Skipped.\n", __func__);
+		goto END;
+	} else {
+		ts->suspended = true;
+		I("%s: enter\n", __func__);
+	}
+
+
+#if (HX_SMART_WAKEUP == 0x01)
+	if (gpio_is_valid(ts->pdata->PON) != 0) {
+		if (gpio_direction_output(ts->pdata->PON, 0) != 0) {
+			E("unable to set PON direction\n");
+		}
+	}
+
+	if (ts->SMWP_enable) {
+		atomic_set(&ts->suspend_mode, 1);
+		ts->pre_finger_mask = 0;
+		I("%s: SMART_WAKEUP enable, reject suspend\n",
+		  __func__);
+		goto END;
+	}
+#endif
+	himax_int_enable(0);
+
+	if (!ts->use_irq) {
+		if (cancel_work_sync(&ts->work) != 0) {
+			himax_int_enable(1);
+		}
+	}
+
+	/*ts->first_pressed = 0;*/
+	atomic_set(&ts->suspend_mode, 1);
+	ts->pre_finger_mask = 0;
+
+END:
+	if (ts->in_self_test == 1) {
+		ts->suspend_resume_done = 1;
+	}
+
+	I("%s: END\n", __func__);
+}
+
+void himax_chip_common_resume(struct himax_ts_data *ts)
+{
+	I("%s: enter\n", __func__);
+
+	if (ts->suspended == false) {
+		I("%s: It had entered resume, skip this step\n", __func__);
+		goto END;
+	} else {
+		ts->suspended = false;
+	}
+
+#if (HX_EXCP_RECOVERY == 0x01)
+	/* continuous N times record, not total N times. */
+	g_zero_event_count = 0;
+#endif
+
+	atomic_set(&ts->suspend_mode, 0);
+	ts->diag_cmd = 0;
+
+	himax_mcu_tp_reset();
+
+#if (HX_SMART_WAKEUP == 0x01)
+	if (gpio_is_valid(ts->pdata->PON) != 0) {
+		if (gpio_direction_output(ts->pdata->PON, 1) != 0) {
+			E("unable to set PON direction\n");
+		}
+	}
+#endif
+	himax_report_all_leave_event(ts);
+
+	himax_int_enable(1);
+
+END:
+	if (ts->in_self_test == 1) {
+		ts->suspend_resume_done = 1;
+	}
+
+	I("%s: END\n", __func__);
+}
+
+#if defined(FW_update_history_record)
+void himax_FW_update_record(void)
+{
+	struct time_var time_now;
+	struct time_clock tm_time;
+	const u8 history_string[] = "History";
+	uint8_t record_log[16] = { 0 };
+	uint8_t tmp_addr[DATA_LEN_4] = { 0 };
+	uint8_t log_count = 0;
+	uint8_t index = 0;
+	uint32_t addr_fw_update_log = 0x3F000U;
+	uint32_t CRC_value = 0;
+	bool update_header = true;
+	u8 *flash_buf = NULL;
+
+
+	flash_buf = kzalloc(sizeof(uint8_t) * HX4K, GFP_KERNEL);
+	if (flash_buf == NULL) {
+		E("%s: Memory allocation falied!\n", __func__);
+		return;
+	}
+
+	if (ic_data->HX_FW_SIZE == FW_SIZE_255k) {
+		addr_fw_update_log = 0x7F000U;
+	}
+
+	/* Get the current time in seconds and nanoseconds */
+	/* Convert the time to year, month, day, hour, minute, second */
+	time_func(&time_now);
+
+#if defined(KERNEL_VER_5_10)
+	time64_to_tm(time_now.tv_sec, 0, &tm_time);
+#else
+	rtc_time_to_tm(time_now.tv_sec, &tm_time);
+#endif
+
+	/* Print the date and time */
+	I("%s: The current date and time: %04d-%02d-%02d %02d:%02d:%02d\n",
+	 __func__, tm_time.tm_year + 1900, tm_time.tm_mon + 1, tm_time.tm_mday,
+	 tm_time.tm_hour, tm_time.tm_min, tm_time.tm_sec);
+
+	/* Year */
+	record_log[0] = ((tm_time.tm_year + 1900) >> 8) & 0xFFU;
+	record_log[1] = (tm_time.tm_year + 1900) & 0xFFU;
+	/* Month */
+	record_log[2] = (tm_time.tm_mon + 1);
+	/* Day */
+	record_log[3] = tm_time.tm_mday;
+	/* Hour */
+	record_log[4] = tm_time.tm_hour;
+	/* Minute */
+	record_log[5] = tm_time.tm_min;
+
+	/* Display config version */
+	record_log[6] = 0x0DU;
+	record_log[7] = ic_data->vendor_display_cfg_ver;
+	/* Touch config version */
+	record_log[8] = 0x0CU;
+	record_log[9] = ic_data->vendor_touch_cfg_ver;
+	/* Fail result
+	 * 0x01 force update
+	 * 0x02 CRC fail
+	 * 0x03 Test FW, Update
+	 * 0x04 Big FW version, Update
+	 * 0x05 Same FW but different last 4 bytes, Update
+	 * 0x06 Debug node FW update
+	 */
+	record_log[10] = ic_data->FW_update_flag;
+	/* Separate Byte */
+	record_log[11] = 0xFFU;
+
+	g_core_fp.fp_flash_dump_func(addr_fw_update_log, HX4K, flash_buf);
+
+	himax_mcu_sector_erase(addr_fw_update_log, HX4K);
+
+	if ((flash_buf[0] == 0xFFU)
+		&& (flash_buf[1] == 0xFFU)
+		&& (flash_buf[HX4K - 1U] == 0xFFU)
+		&& (flash_buf[HX4K - 2U] == 0xFFU)) {
+		I("empty flash zone\n");
+		for (index = 0; index < 8U; index++) {
+			flash_buf[index] = history_string[index];
+		}
+
+	} else if (strncmp(flash_buf, history_string, 8U) == 0) {
+		flash_buf[8] += 1U;
+		log_count = (uint8_t)(flash_buf[8] % 0x100U);/*update log count*/
+	} else {
+		W("Undefined behavior, flash zone: 0x%08X may be occupied\n",
+			addr_fw_update_log);
+		update_header = false;
+	}
+
+	if (update_header) {
+		if (log_count == 0U) { /*first line log*/
+			log_count++;
+			flash_buf[8] = log_count;
+		}
+
+		for (index = 0; index < 16U; index++) {
+			flash_buf[(log_count * 16U) + index] = record_log[index];
+		}
+		CRC_value =
+			himax_mcu_calculate_CRC32_by_AP(flash_buf, HX4K - 4U);
+
+		flash_buf[HX4K - 4U] = (uint8_t)((CRC_value) % 0x100U);
+		flash_buf[HX4K - 3U] = (uint8_t)((CRC_value >> 8U) % 0x100U);
+		flash_buf[HX4K - 2U] = (uint8_t)((CRC_value >> 16U) % 0x100U);
+		flash_buf[HX4K - 1U] = (uint8_t)((CRC_value >> 24U) % 0x100U);
+
+		g_core_fp.fp_sense_off();
+		himax_disable_flash_protected_mode();
+		(void)g_core_fp.fp_flash_programming((const u8 *)flash_buf, addr_fw_update_log,
+			HX4K);
+
+		himax_parse_assign_cmd(addr_fw_update_log, tmp_addr,
+			sizeof(tmp_addr));
+		if (g_core_fp.fp_check_CRC(tmp_addr, HX4K) == 0x00000000U) {
+			I("%s Success!\n", __func__);
+		} else {
+			E("%s Fail!\n", __func__);
+		}
+
+		himax_mcu_tp_reset();
+	}
+	kfree(flash_buf);
+	flash_buf = NULL;
+
+}
+#endif
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_common.h linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_common.h
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_common.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_common.h	2024-06-14 10:44:49.148852720 +0200
@@ -0,0 +1,522 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*  Himax Android Driver Sample Code for common functions
+ *
+ *  Copyright (C) 2024 Himax Corporation.
+ *
+ *  This software is licensed under the terms of the GNU General Public
+ *  License version 2,  as published by the Free Software Foundation,  and
+ *  may be copied,  distributed,  and modified under those terms.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef HIMAX_COMMON_H
+#define HIMAX_COMMON_H
+
+#include <linux/uaccess.h>
+#include <linux/atomic.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/async.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/gpio.h>
+#include <linux/input/mt.h>
+#include <linux/firmware.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/buffer_head.h>
+#include <linux/pm_wakeup.h>
+#include <linux/seq_file.h>
+#include <linux/proc_fs.h>
+#include <linux/kallsyms.h>
+#include <linux/of_gpio.h>
+#include <linux/version.h>
+#include <linux/ctype.h>
+#include <linux/rtc.h>
+#include "himax_platform.h"
+
+#define HIMAX_DRIVER_VER "Sample_code_A09.20_#5671_01"
+/*#define Tp_inspect_mode_patch*/
+#define FLASH_DUMP_FILE "/sdcard/HX_Flash_Dump.bin"
+
+/*===========Himax Option function=============*/
+#define HX_BOOT_UPGRADE					(0x01)
+#define HX_EXCP_RECOVERY				(0x00)
+#define HX_PROTOCOL_A					(0x00)
+#define HX_PROTOCOL_B_3PA				(0x01)
+#define HX_RST_PIN_FUNC					(0x00)
+#define HX_TP_INSPECT_MODE				(0x01)
+#define HX_FIX_TOUCH_INFO				(0x00)
+#define HX_WPBP_ENABLE					(0x00)
+#define HX_SMART_WAKEUP					(0x00)
+#define HX_GESTURE_TRACK				(0x00)
+#define HX_TP_GTS_MODE					(0x00)
+/*=============================================*/
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83192)
+	#define HIMAX_LTDI_CONFIG			(0x00)
+	extern bool hx83192_init(void);
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83193)
+	#define HIMAX_LTDI_CONFIG			(0x00)
+	extern bool hx83193_init(void);
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83194)
+	#define HIMAX_LTDI_CONFIG			(0x01)
+	extern bool hx83194_init(void);
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83195)
+	#define PANEL_SELECT				(0x01)
+	#define HIMAX_LTDI_CONFIG		(PANEL_SELECT)
+	extern bool hx83195_init(void);
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83180)
+	#define HIMAX_LTDI_CONFIG			(0x01)
+	extern bool hx83180_init(void);
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83181)
+	#define HIMAX_LTDI_CONFIG			(0x01)
+	extern bool hx83181_init(void);
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+	#define HIMAX_LTDI_CONFIG			(0x00)
+	#define	HX8530_ALG_2_SECTION 	0x10000900U
+	#define	HX8530_CFG_1_SECTION  	0x10000901U
+	extern bool hx8530_init(void);
+	static 	uint32_t HX8530_ALG_2_SECTION_ADDR;
+	static 	uint32_t HX8530_ALG_2_SECTION_SIZE;
+	static 	uint32_t HX8530_CFG_1_SECTION_ADDR;
+	static 	uint32_t HX8530_CFG_1_SECTION_SIZE;
+#else
+	#define HIMAX_LTDI_CONFIG			(0x00)
+#endif
+
+struct himax_ic_data {
+	uint16_t vendor_arch_ver;
+	uint16_t vendor_config_ver;
+	uint8_t vendor_touch_cfg_ver;
+	uint8_t vendor_display_cfg_ver;
+	uint8_t vendor_cid_maj_ver;
+	uint8_t vendor_cid_min_ver;
+	uint8_t vendor_panel_ver;
+	uint8_t vendor_remark1[12];
+	uint8_t vendor_remark2[12];
+	uint8_t vendor_ticket[12];
+	uint8_t vendor_config_date[12];
+	uint8_t vendor_cus_info[12];
+	uint8_t vendor_proj_info[12];
+	uint8_t HX_RX_NUM;
+	uint8_t HX_TX_NUM;
+	uint16_t HX_X_RES;
+	uint16_t HX_Y_RES;
+	uint32_t HX_FW_SIZE;
+	uint8_t HX_MAX_PT;
+	bool HX_INT_IS_EDGE;
+	bool HX_IS_ID_EN;
+	bool HX_ID_PALM_EN;
+	bool STOP_FW_BY_HOST_EN;
+	uint8_t HX_RX_IC_NUM;
+	uint8_t HX_TX_IC_NUM;
+	uint8_t HX_CHIP_RX_MAX;
+	uint8_t HX_CHIP_TX_MAX;
+	uint8_t FW_update_flag;
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+	uint8_t HX8530_upgrade_section;
+#endif
+};
+
+struct himax_target_report_data {
+	uint32_t *x;
+	uint32_t *y;
+	uint32_t *w;
+	int *finger_id;
+	uint8_t finger_on;
+	uint8_t finger_num;
+	int *fpt_cnt;
+#if (HX_SMART_WAKEUP == 0x01)
+	int SMWP_event_chk;
+#endif
+};
+
+struct himax_report_data {
+	uint8_t touch_all_size;
+	uint8_t raw_cnt_max;
+	uint8_t raw_cnt_rmd;
+	uint8_t touch_info_size;
+	uint8_t	finger_on;
+	uint8_t *hx_coord_buf;
+	uint8_t hx_state_info[2];
+#if (HX_SMART_WAKEUP == 0x01)
+	uint8_t event_size;
+	uint8_t *hx_event_buf;
+#endif
+	uint32_t rawdata_size;
+	uint8_t diag_cmd;
+	uint8_t *hx_rawdata_buf;
+	uint8_t rawdata_frame_size;
+};
+
+struct himax_ts_data {
+	bool initialized;
+	bool suspended;
+	bool chip_test_mpap_flag;
+	atomic_t suspend_mode;
+	uint8_t useScreenRes;
+	uint8_t diag_cmd;
+	char chip_name[30];
+	uint8_t protocol_type;
+	uint8_t first_pressed;
+	uint8_t nFinger_support;
+	bool irq_enabled;
+	uint8_t panel_id;
+	uint16_t last_slot;
+	uint16_t pre_finger_mask;
+	uint16_t old_finger;
+	uint8_t hx_point_num;
+
+	uint32_t debug_log_level;
+	uint32_t widthFactor;
+	uint32_t heightFactor;
+
+	int lcm_gpio;
+	int rst_gpio;
+	int pon_gpio;
+	bool use_irq;
+	int (*power)(int on);
+	uint32_t pre_finger_data[20][2];
+
+	struct device *dev;
+	struct workqueue_struct *himax_wq;
+	struct work_struct work;
+	struct input_dev *input_dev;
+
+	struct hrtimer timer;
+	struct i2c_client *client;
+	struct himax_i2c_platform_data *pdata;
+	struct mutex rw_lock;
+	atomic_t irq_state;
+	spinlock_t irq_lock;
+
+	atomic_t fail_det_state;
+	spinlock_t fail_det_lock;
+
+/******* SPI-start *******/
+	struct spi_device	*spi;
+	int hx_irq;
+	uint8_t *xfer_buff;
+/******* SPI-end *******/
+
+	int hx_fail_det;
+
+	int in_self_test;
+	int suspend_resume_done;
+	int bus_speed;
+
+#if defined(HX_CONFIG_FB) || defined(HX_CONFIG_DRM)
+	struct notifier_block fb_notif;
+	struct workqueue_struct *himax_att_wq;
+	struct delayed_work work_att;
+#endif
+
+	struct workqueue_struct *flash_wq;
+	struct work_struct flash_work;
+
+#if (HX_BOOT_UPGRADE == 0x01)
+	struct workqueue_struct *himax_boot_upgrade_wq;
+	struct delayed_work work_boot_upgrade;
+#endif
+
+	struct workqueue_struct *himax_diag_wq;
+	struct delayed_work himax_diag_delay_wrok;
+#if (HX_SMART_WAKEUP == 0x01)
+	bool SMWP_enable;
+	uint8_t gesture_cust_en[26];
+	struct wakeup_source *ts_SMWP_wake_lock;
+#endif
+
+
+#if (HX_TP_GTS_MODE == 0x01)
+	uint8_t GTS_range;
+#endif
+
+	char self_test_file_ch[30];
+	uint8_t slave_ic_num;
+};
+
+struct himax_debug {
+	void (*fp_ts_dbg_func)(struct himax_ts_data *ts, int start);
+	int (*fp_set_diag_cmd)(struct himax_ic_data *ic_data_tmp,
+				struct himax_report_data *hx_touch_data_tmp);
+};
+
+/*------------------------- define block -------------------------------------*/
+
+#define	IC_MASTER		0U
+#define	IC_SLAVE_1		1U
+#define	IC_SLAVE_2		2U
+
+#define	HX_REPORT_COORD			1
+#define	HX_REPORT_SMWP_EVENT	2
+#define	HX_REPORT_COORD_RAWDATA	3
+
+
+#define	HX_TS_GET_DATA_FAIL		-4
+#define	HX_EXCP_EVENT			-3
+#define	HX_CHKSUM_FAIL			-2
+#define	HX_PATH_FAIL			-1
+#define	HX_TS_NORMAL_END		0
+#define	HX_EXCP_REC_OK			1
+#define	HX_READY_SERVE			2
+#define	HX_REPORT_DATA			3
+#define	HX_EXCP_WARNING			4
+#define	HX_IC_RUNNING			5
+#define	HX_ZERO_EVENT_COUNT		6
+#define	HX_RST_OK				7
+
+#define	PROTOCOL_TYPE_A			0x00
+#define	PROTOCOL_TYPE_B			0x01
+
+/* Enable it if driver go into suspend/resume twice */
+/*#define HX_CONFIG_FB				(0x00)*/
+/* Enable it if driver go into suspend/resume twice */
+/*#define HX_CONFIG_DRM				(0x00)*/
+
+#if defined(HX_CONFIG_FB)
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#elif defined(HX_CONFIG_DRM)
+/*#include <linux/msm_drm_notify.h>*/
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0))
+#define KERNEL_VER_ABOVE_4_14
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 10, 0))
+#define KERNEL_VER_5_10
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0))
+#define KERNEL_VER_5_18
+#endif
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(6, 1, 0))
+#define KERNEL_VER_6_01
+#endif
+
+/* WP GPIO setting, decided by which pin direct to OS side, WP need pin */
+/* high either GPIO0 or GPIO4 */
+/* #define WP_GPIO0 */
+#define WP_GPIO4
+/* #define PANEL_ID_CHECK */
+#define FW_baseline_status_ready
+/* #define FW_update_history_record */
+
+#if (HX_BOOT_UPGRADE == 0x01)
+/* FW Auto upgrade case, you need to setup the fix_touch_info of module
+ */
+#define BOOT_UPGRADE_FWNAME "Himax_firmware.bin"
+#define BOOT_FORCE_UPGRADE_FWNAME "Himax_Force_Update_FW.bin"
+#endif
+
+#if defined(KERNEL_VER_5_10)
+#define proc_op(name) proc_##name
+#define proc_opl(name) proc_##name
+#define proc_ops_name proc_ops
+#define time_var timespec64
+#define time_clock tm
+#define time_func ktime_get_real_ts64
+#define owner_line
+#else
+#define proc_op(name) name
+#define proc_opl(name) l##name
+#define proc_ops_name file_operations
+#define time_var timespec
+#define time_clock rtc_time
+#define time_func getnstimeofday
+#define owner_line .owner\
+		=\
+		THIS_MODULE,
+#endif
+
+#define addr_Tp_inspect_mode_cmd_current	0x10005B74U
+
+#define HX_MAX_WRITE_SZ    ((64U * 1024U) + 4U)
+
+#define	HX_83192D_PWON		"HX83192D"
+#define	HX_83192A_PWON		"HX83192A"
+#define	HX_83193A_PWON		"HX83193A"
+#define	HX_83194A_PWON		"HX83194A"
+#define	HX_83195A_PWON		"HX83195A"
+#define	HX_83180A_PWON		"HX83180A"
+#define	HX_83181A_PWON		"HX83181A"
+#define	HX_8530_PWON		"HX8530"
+#define	HIMAX_PROC_TOUCH_FOLDER		"android_touch"
+#define	HIMAX_PROC_WP_BP_LOCK_FILE	"WPBPlock_node"
+#define	HIMAX_PROC_FAIL_DET_FILE	"Fail_det_state"
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_SELF_TEST)
+	#define HIMAX_PROC_SELF_TEST_FILE "self_test"
+#endif
+
+#if (HX_TP_GTS_MODE == 0x01)
+	#define HIMAX_PROC_GTS_FILE "Ghost_touch_solution"
+#endif
+
+#if (HX_TP_INSPECT_MODE == 0x01)
+	#define HIMAX_PROC_INSPECT_MODE_FILE "Inspect_mode"
+#endif
+
+
+#define SHIFTBITS			5
+#define NO_ERR					0
+#define HX_FAIL					-1
+#define I2C_FAIL				-1
+#define MEM_ALLOC_FAIL			-2
+#define INPUT_REGISTER_FAIL		-3
+#define FW_NOT_READY			4
+#define LENGTH_FAIL				-5
+#define OPEN_FILE_FAIL			-6
+#define PROBE_FAIL				-7
+#define ERR_TEST_FAIL			-9
+#define HW_CRC_FAIL				1
+
+#define HX_FINGER_ON			1
+#define HX_FINGER_LEAVE			2
+
+#define HX_LOCK					6
+#define HX_UNLOCK				7
+
+#if (HX_SMART_WAKEUP == 0x01)
+	#define HIMAX_PROC_GESTURE_FILE	"GESTURE"
+	#define GEST_PTLG_ID_LEN	(4U)
+	#define GEST_PTLG_HDR_LEN	(4U)
+	#define GEST_PTLG_HDR_ID1	(0xCCU)
+	#define GEST_PTLG_HDR_ID2	(0x44U)
+	#define GEST_PT_MAX_NUM		(128U)
+	#define GEST_SUP_NUM		(2U)
+	/* Setting cust key define (DF = double finger) */
+	/* {Double Tap, Tap}
+	 */
+#endif
+
+#define TS_WAKE_LOCK_TIMEOUT (5000)
+
+#define TEMP_LOG "%s:%s data[0]=0x%02X, data[1]=0x%02X, data[2]=0x%02X, data[3]=0x%02X\n"
+
+#if (HX_SMART_WAKEUP == 0x01)
+#define HX_KEY_DOUBLE_CLICK                KEY_POWER
+#define HX_KEY_SINGLE_CLICK                KEY_POWER
+#endif
+
+#define UNUSED(x) (void)(x)
+
+
+
+/*------------------------- define block -------------------------------------*/
+/*------------------------- parameter block ----------------------------------*/
+
+extern bool g_hx_chip_inited;
+extern uint8_t g_mmi_refcnt;
+extern int g_ts_dbg;
+
+#if (HX_SMART_WAKEUP == 0x01)
+	extern uint8_t *wake_event_buffer;
+#endif
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_SELF_TEST)
+	extern char *g_rslt_data;
+#endif
+
+#if (HX_TP_INSPECT_MODE == 0x01)
+	extern uint8_t inspect_mode_flag;
+#endif
+
+/*------------------------- parameter block ----------------------------------*/
+/*------------------------- structure block ----------------------------------*/
+
+extern struct himax_core_fp g_core_fp;
+extern struct himax_ic_data *ic_data;
+extern struct proc_dir_entry *himax_touch_proc_dir;
+extern struct himax_target_report_data *g_target_report_data;
+extern struct himax_report_data *hx_touch_data;
+extern struct proc_dir_entry *himax_proc_INSPECT_MODE_file;
+extern struct himax_debug *debug_data;
+extern struct himax_ts_data *private_ts;
+
+#if defined(KERNEL_VER_5_10)
+	extern struct timespec64 time_diff(struct timespec64 start, struct timespec64 end);
+#else
+	extern struct timespec time_diff(struct timespec start, struct timespec end);
+#endif
+
+/*------------------------- structure block ----------------------------------*/
+/*------------------------- function block -----------------------------------*/
+
+#if defined(HX_CONFIG_FB)
+int fb_notifier_callback(struct notifier_block *self,
+		unsigned long event, void *data);
+#elif defined(HX_CONFIG_DRM)
+int drm_notifier_callback(struct notifier_block *self,
+			unsigned long event, void *data);
+#endif
+
+void himax_chip_common_suspend(struct himax_ts_data *ts);
+void himax_chip_common_resume(struct himax_ts_data *ts);
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_DEBUG)
+	int himax_debug_init(void);
+	void himax_debug_remove(void);
+#endif
+
+int himax_parse_dt(struct himax_ts_data *ts,
+			struct himax_i2c_platform_data *pdata);
+
+int himax_dev_set(struct himax_ts_data *ts);
+int himax_input_register_device(struct input_dev *input_dev);
+void himax_chip_self_test(struct seq_file *s, void *v);
+void himax_mcu_clear_event_stack(void);
+
+void himax_report_data_deinit(void);
+int himax_input_register(struct himax_ts_data *ts);
+void himax_fail_det_work(void);
+void himax_ts_work(struct himax_ts_data *ts);
+enum hrtimer_restart himax_ts_timer_func(struct hrtimer *timer);
+int himax_chip_common_init(void);
+void himax_chip_common_deinit(void);
+#if defined(FW_update_history_record)
+	void himax_FW_update_record(void);
+#endif
+
+#if defined(__HIMAX_MOD__)
+	extern int (*hx_msm_drm_register_client)(struct notifier_block *nb);
+	extern int (*hx_msm_drm_unregister_client)(struct notifier_block *nb);
+#endif
+
+/*------------------------- function block -----------------------------------*/
+
+#if (HX_FIX_TOUCH_INFO == 0x01)
+enum fix_touch_info {
+	FIX_HX_RX_NUM = 64,
+	FIX_HX_TX_NUM = 36,
+	FIX_HX_MAX_PT = 10,
+	FIX_HX_INT_IS_EDGE = 0,
+	FIX_HX_IS_ID_EN = 1,
+	FIX_HX_ID_PALM_EN = 0,
+#if (HIMAX_LTDI_CONFIG == 0x01)
+	FIX_HX_RX_IC_NUM = 0,
+	FIX_HX_TX_IC_NUM = 0,
+	FIX_HX_CHIP_RX_MAX = 0,
+	FIX_HX_CHIP_TX_MAX = 0,
+#endif
+};
+#endif
+
+#if defined(PANEL_ID_CHECK)
+#define	PANEL_TIANMA		0
+#define	PANEL_BOE			1
+#endif
+#define BROADCAST_TIMEOUT	100U
+
+#endif
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_debug.c linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_debug.c
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_debug.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_debug.c	2024-06-14 10:43:31.782186054 +0200
@@ -0,0 +1,2721 @@
+// SPDX-License-Identifier: GPL-2.0
+/*  Himax Android Driver Sample Code for debug nodes
+ *
+ *  Copyright (C) 2024 Himax Corporation.
+ *
+ *  This software is licensed under the terms of the GNU General Public
+ *  License version 2,  as published by the Free Software Foundation,  and
+ *  may be copied,  distributed,  and modified under those terms.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#include "himax_debug.h"
+#include "himax_ic_core.h"
+
+
+/*------------------------- define block -------------------------------------*/
+/*------------------------- define block -------------------------------------*/
+/*------------------------- parameter block ----------------------------------*/
+
+static uint8_t process_type;
+static uint8_t pre_diag_cmd;
+static bool h_overflow;
+static unsigned int dbg_cmd_flag;
+char *dbg_cmd_par;
+static int (*dbg_func_ptr_r[CMD_NUM])(struct seq_file *m);
+static ssize_t (*dbg_func_ptr_w[CMD_NUM])(char *buf, size_t len);
+int g_max_mutual;
+int g_min_mutual = 0xFFFF;
+int g_max_self;
+int g_min_self = 0xFFFF;
+uint8_t reg_cmd[4];
+uint8_t *reg_read_data;
+uint8_t g_flash_progress;
+uint32_t g_page_prog_start;
+bool fw_update_going;
+bool diag_wq_alive;
+uint8_t g_diag_arr_num;
+static u8 *g_gma_buf;
+
+static char *dbg_cmd_str[] = {
+	"crc_test",
+	"fw_debug",
+	"attn",
+	"layout",
+	"senseonoff",
+	"debug_level",
+	"int_en",
+	"register",
+	"reset",
+	"diag_arr",
+	"diag",
+	"GMA",
+	NULL
+};
+
+uint8_t diag_max_cnt;
+
+/*------------------------- parameter block ----------------------------------*/
+/*------------------------- structure block ----------------------------------*/
+
+struct time_var g_timeStart;
+struct time_var g_timeEnd;
+struct time_var g_timeDelta;
+
+struct proc_dir_entry *himax_proc_diag_dir;
+struct proc_dir_entry *himax_proc_vendor_file;
+struct proc_dir_entry *himax_proc_stack_file;
+struct proc_dir_entry *himax_proc_delta_file;
+struct proc_dir_entry *himax_proc_dc_file;
+struct proc_dir_entry *himax_proc_baseline_file;
+struct proc_dir_entry *himax_proc_debug_file;
+struct proc_dir_entry *himax_proc_flash_dump_file;
+struct proc_dir_entry *himax_proc_pintest_file;
+
+/*------------------------- structure block ----------------------------------*/
+
+
+/*
+ *	Segment : Himax Sub Function for calling
+ */
+
+static void himax_burn_GMA_to_flash(const u8 *gma_buf, char type)
+{
+	uint32_t start_addr;
+	uint8_t tmp_addr[DATA_LEN_4] = { 0 };
+
+	if (type == 'V') { /*Start to flash VCOM*/
+		start_addr = 0x28000U;
+		D("%s : VCOM\n", __func__);
+	} else if (type == 'A') { /*Start to flash Analog GMA*/
+		start_addr = 0x29000U;
+		D("%s : AGMA\n", __func__);
+	} else if (type == 'D') { /*Start to flash Analog GMA*/
+		start_addr = 0x2A000U;
+		D("%s : DGMA\n", __func__);
+	} else {
+		E("Input cmd is incorrect.\n");
+		return;
+	}
+
+	g_core_fp.fp_sense_off();
+	himax_disable_flash_protected_mode();
+	himax_mcu_sector_erase(start_addr, HX4K);
+	g_core_fp.fp_flash_programming(gma_buf, start_addr, HX4K);
+
+	himax_parse_assign_cmd(start_addr, tmp_addr,
+		sizeof(tmp_addr));
+	if (g_core_fp.fp_check_CRC(tmp_addr, HX4K) == 0x00000000U) {
+		D("Burn GMA Success!\n");
+	} else {
+		E("Burn GMA FAIL!\n");
+	}
+
+	himax_mcu_tp_reset();
+
+#if (HX_WPBP_ENABLE == 0x01)
+	himax_enable_flash_protected_mode();
+#endif
+}
+
+static int himax_convert_GMA_data(const u8 *data, size_t data_size, char type)
+{
+	unsigned long value = 0;
+	uint32_t GMA_length = 0;
+	uint32_t CRC_value = 0;
+	int	ret = NO_ERR;
+	size_t loop_i = 0;
+	char GMA_content[DATA_LEN_4] = { 0 };
+	char value_buff[5] = { 0 };
+
+	g_gma_buf = kcalloc(HX4K, sizeof(uint8_t), GFP_KERNEL);
+
+	if (g_gma_buf == NULL) {
+		ret = OPEN_FILE_FAIL;
+		E("%s: Memory allocation falied!\n", __func__);
+	} else {
+		(void)memset(g_gma_buf, 0x00U, HX4K * sizeof(uint8_t));
+		(void)memset(GMA_content, 0xFFU, sizeof(GMA_content));
+		(void)memset(value_buff, '\0', sizeof(value_buff));
+		while (loop_i < data_size) {
+			if ((data[loop_i] == 'x') && (GMA_content[1] != 'x')) {
+				GMA_content[1] = 'x';
+			} else if ((data[loop_i] == '0') && (GMA_content[0] != '0')) {
+				GMA_content[0] = '0';
+			} else if (isxdigit(data[loop_i]) != 0) {
+				if ((GMA_content[1] == 'x') && (GMA_content[0] == '0')) {
+					if (isxdigit(GMA_content[2]) == 0) {
+						GMA_content[2] = data[loop_i];
+					} else {
+						GMA_content[3] = data[loop_i];
+					}
+				}
+			} else if (data[loop_i] == ',') {
+			(void)memcpy(&value_buff[0], &GMA_content[0], sizeof(GMA_content));
+				if (!kstrtoul(value_buff, 0, &value)) {
+					g_gma_buf[8U + GMA_length] = (uint8_t)value;
+					++GMA_length;
+					(void)memset(GMA_content, 0xFFU, sizeof(GMA_content));
+				} else {
+					E("Undefined behavior,i %d, %s\n", loop_i, GMA_content);
+					ret = OPEN_FILE_FAIL;
+					break;
+				}
+			} else {
+				/*do nothing*/
+			}
+			loop_i++;
+		}
+
+		himax_parse_assign_cmd(GMA_length, g_gma_buf,
+			DATA_LEN_4);
+		if (type == 'V') {
+			g_gma_buf[4] = 0x01U;
+			g_gma_buf[5] = 0x01U;
+			D("%s : Data Title ID = VCOM\n", __func__);
+		} else if (type == 'A') {
+			g_gma_buf[6] = 0x02U;
+			D("%s : Data Title ID = AGMA\n", __func__);
+		} else if (type == 'D') {
+			g_gma_buf[5] = 0x02U;
+			D("%s : Data Title ID = DGMA\n", __func__);
+		} else {
+			ret = INPUT_REGISTER_FAIL;
+			E("Unknown input cmd\n");
+		}
+		g_gma_buf[7] = 0x01U; /*I("Data Type = ASCII\n");*/
+
+		CRC_value =
+			himax_mcu_calculate_CRC32_by_AP(g_gma_buf, HX4K - 4U);
+
+		g_gma_buf[HX4K - 4U] = (uint8_t)((CRC_value) % 0x100U);
+		g_gma_buf[HX4K - 3U] = (uint8_t)((CRC_value >> 8U) % 0x100U);
+		g_gma_buf[HX4K - 2U] = (uint8_t)((CRC_value >> 16U) % 0x100U);
+		g_gma_buf[HX4K - 1U] = (uint8_t)((CRC_value >> 24U) % 0x100U);
+
+	}
+
+	return ret;
+}
+
+int16_t *getMutualBuffer(void)
+{
+	return diag_mutual;
+}
+int16_t *getMutualNewBuffer(void)
+{
+	return diag_mutual_new;
+}
+int16_t *getMutualOldBuffer(void)
+{
+	return diag_mutual_old;
+}
+int16_t *getSelfBuffer(void)
+{
+	return diag_self;
+}
+int16_t *getSelfNewBuffer(void)
+{
+	return diag_self_new;
+}
+int16_t *getSelfOldBuffer(void)
+{
+	return diag_self_old;
+}
+static void setMutualBuffer(uint8_t x_num, uint8_t y_num)
+{
+	diag_mutual = kzalloc(x_num * y_num * sizeof(int16_t), GFP_KERNEL);
+}
+static void setMutualNewBuffer(uint8_t x_num, uint8_t y_num)
+{
+	diag_mutual_new = kzalloc(x_num * y_num * sizeof(int16_t), GFP_KERNEL);
+}
+static void setMutualOldBuffer(uint8_t x_num, uint8_t y_num)
+{
+	diag_mutual_old = kzalloc(x_num * y_num * sizeof(int16_t), GFP_KERNEL);
+}
+static void setSelfBuffer(uint8_t x_num, uint8_t y_num)
+{
+	diag_self = kzalloc((x_num + y_num) * sizeof(int16_t), GFP_KERNEL);
+}
+static void setSelfNewBuffer(uint8_t x_num, uint8_t y_num)
+{
+	diag_self_new = kzalloc((x_num + y_num) * sizeof(int16_t), GFP_KERNEL);
+}
+static void setSelfOldBuffer(uint8_t x_num, uint8_t y_num)
+{
+	diag_self_old = kzalloc((x_num + y_num) * sizeof(int16_t), GFP_KERNEL);
+}
+
+/*
+ *	Segment : Himax PROC Debug Function
+ */
+
+static int himax_crc_test_read(struct seq_file *m)
+{
+	int ret = 0;
+	bool result = false;
+
+	g_core_fp.fp_sense_off();
+	msleep(20);
+
+	result = g_core_fp.fp_calculateChecksum(ic_data->HX_FW_SIZE);
+	g_core_fp.fp_sense_on();
+
+	if (result) {
+		seq_printf(m,
+				"CRC test is Pass!\n");
+	} else {
+		seq_printf(m,
+				"CRC test is Fail!\n");
+	}
+
+	return ret;
+}
+
+int himax_proc_FW_debug_read(struct seq_file *m)
+{
+	int ret = 0;
+	uint8_t i = 0;
+	uint8_t data[4] = { 0 };
+	uint32_t len = 0;
+
+	len = (uint32_t)(sizeof(dbg_reg_ary) / sizeof(uint32_t));
+
+	for (i = 0; i < len; i++) {
+		himax_mcu_register_read(dbg_reg_ary[i], DATA_LEN_4, data);
+
+		seq_printf(m,
+		"reg[0-3] : 0x%08X = 0x%02X, 0x%02X, 0x%02X, 0x%02X\n",
+		dbg_reg_ary[i], data[0], data[1], data[2], data[3]);
+		D("reg[0-3] : 0x%08X = 0x%02X, 0x%02X, 0x%02X, 0x%02X\n",
+		dbg_reg_ary[i], data[0], data[1], data[2], data[3]);
+	}
+
+	return ret;
+}
+
+int himax_attn_read(struct seq_file *m)
+{
+	int ret = 0;
+	struct himax_ts_data *ts_data;
+
+	ts_data = private_ts;
+
+	seq_printf(m, "attn = %x\n",
+			himax_int_gpio_read(ts_data->pdata->TSIX));
+
+	return ret;
+}
+
+int himax_layout_read(struct seq_file *m)
+{
+	struct himax_ts_data *ts = private_ts;
+	int ret = 0;
+
+	seq_printf(m, "%d ",
+			ts->pdata->abs_x_min);
+	seq_printf(m, "%d ",
+			ts->pdata->abs_x_max);
+	seq_printf(m, "%d ",
+			ts->pdata->abs_y_min);
+	seq_printf(m, "%d ",
+			ts->pdata->abs_y_max);
+	seq_puts(m, "\n");
+
+	return ret;
+}
+
+ssize_t himax_layout_write(char *buf, size_t len)
+{
+	struct himax_ts_data *ts = private_ts;
+	char *token = NULL;
+	uint8_t arg_cnt = 0;
+	uint32_t layout[DATA_LEN_4] = { 0 };
+	int value = 0;
+
+	if (len >= 80U) {
+		D("%s: no command exceeds 80 chars.\n", __func__);
+		return -EFAULT;
+	}
+	token = strsep(&buf, ",");
+	while (token != NULL) {
+		if (!kstrtoint(token, 0, &value)) {
+			layout[arg_cnt] = (uint32_t)value;
+			arg_cnt++;
+		} else {
+			W("[FAIL]kstrtoul\n");
+		}
+		token = strsep(&buf, ",");
+	}
+
+	if (arg_cnt == DATA_LEN_4) {
+		ts->pdata->abs_x_min = layout[0];
+		ts->pdata->abs_x_max = layout[1];
+		ts->pdata->abs_y_min = layout[2];
+		ts->pdata->abs_y_max = layout[3];
+		D("layout:%d, %d, %d, %d\n", ts->pdata->abs_x_min,
+		  ts->pdata->abs_x_max, ts->pdata->abs_y_min,
+		  ts->pdata->abs_y_max);
+		if (ts->input_dev != NULL) {
+			input_unregister_device(ts->input_dev);
+		} else {
+			input_free_device(ts->input_dev);
+		}
+
+		(void)himax_input_register(ts);
+	} else {
+		D("ERR@%d, %d, %d, %d\n", ts->pdata->abs_x_min,
+		  ts->pdata->abs_x_max, ts->pdata->abs_y_min,
+		  ts->pdata->abs_y_max);
+	}
+
+	return len;
+}
+
+ssize_t himax_sense_on_off_write(char *buf, size_t len)
+{
+	if (len >= 80U) {
+		D("%s: no command exceeds 80 chars.\n", __func__);
+		return -EFAULT;
+	}
+
+	if (buf[0] == '0') {
+		g_core_fp.fp_sense_off();
+		D("Sense off\n");
+	}
+	if (buf[0] == '1') {
+		if (buf[1] == 's') {
+			himax_mcu_tp_reset();
+			D("Sense on, system reset\n");
+		} else {
+			g_core_fp.fp_sense_on();
+			D("Sense on, command reset\n");
+		}
+	}
+
+	return len;
+}
+
+int himax_debug_level_read(struct seq_file *m)
+{
+	struct himax_ts_data *ts_data;
+	int ret = 0;
+
+	ts_data = private_ts;
+	seq_printf(m, "tsdbg: %d\n",
+			g_ts_dbg);
+	seq_printf(m, "level: %X\n",
+			ts_data->debug_log_level);
+
+	return ret;
+}
+
+ssize_t himax_debug_level_write(char *buf, size_t len)
+{
+	struct himax_ts_data *ts;
+	int value = 0;
+
+	ts = private_ts;
+
+	if (len >= 12U) {
+		D("%s: no command exceeds 12 chars.\n", __func__);
+		return -EFAULT;
+	}
+
+	ts->debug_log_level = 0;
+
+	if (!kstrtoint(buf, 0, &value)) {
+		ts->debug_log_level = (uint8_t)value;
+	} else {
+		W("[FAIL]kstrtoint\n");
+	}
+
+	D("debug level set to %d\n", ts->debug_log_level);
+
+	if ((ts->debug_log_level & BIT(4)) != 0U) {
+		D("Turn on/Enable Debug Mode for himax_self_test!\n");
+		goto END_FUNC;
+	}
+
+	if ((ts->debug_log_level & BIT(3)) != 0U) {
+		if ((ts->pdata->screenWidth > 0U) && (ts->pdata->screenHeight > 0U) &&
+		    ((ts->pdata->abs_x_max - ts->pdata->abs_x_min) > 0U) &&
+		    ((ts->pdata->abs_y_max - ts->pdata->abs_y_min) > 0U)) {
+			ts->widthFactor =
+				((uint32_t)ts->pdata->screenWidth << SHIFTBITS) /
+				(ts->pdata->abs_x_max - ts->pdata->abs_x_min);
+			ts->heightFactor =
+				((uint32_t)ts->pdata->screenHeight << SHIFTBITS) /
+				(ts->pdata->abs_y_max - ts->pdata->abs_y_min);
+
+			if ((ts->widthFactor > 0U) && (ts->heightFactor > 0U)) {
+				ts->useScreenRes = 1;
+			} else {
+				ts->heightFactor = 0;
+				ts->widthFactor = 0;
+				ts->useScreenRes = 0;
+			}
+		} else {
+			D("Enable finger debug with raw position mode!\n");
+		}
+	} else {
+		ts->useScreenRes = 0;
+		ts->widthFactor = 0;
+		ts->heightFactor = 0;
+	}
+END_FUNC:
+	return len;
+}
+
+int himax_int_en_read(struct seq_file *m)
+{
+	struct himax_ts_data *ts = private_ts;
+	int ret = 0;
+
+	seq_printf(m, "%d\n", ts->irq_enabled);
+
+	return ret;
+}
+
+ssize_t himax_int_en_write(char *buf, size_t len)
+{
+	struct himax_ts_data *ts = private_ts;
+	int ret = 0;
+
+	if (len >= 12U) {
+		D("%s: no command exceeds 12 chars.\n", __func__);
+		return -EFAULT;
+	}
+
+	if (buf[0] == '0') {
+		himax_int_enable(0);
+	} else if (buf[0] == '1') {
+		himax_int_enable(1);
+	} else if (buf[0] == '2') {
+		himax_int_enable(0);
+		free_irq(ts->hx_irq, ts);
+		ts->irq_enabled = false;
+	} else if (buf[0] == '3') {
+		ret = himax_int_en_set();
+
+		if (ret == 0) {
+			ts->irq_enabled = true;
+			atomic_set(&ts->irq_state, 1);
+		}
+	} else if (buf[0] == '4') {
+		ic_data->HX_INT_IS_EDGE = true;
+		ret = himax_int_en_set();
+
+		if (ret == 0) {
+			ts->irq_enabled = true;
+			atomic_set(&ts->irq_state, 1);
+		}
+	} else if (buf[0] == '5') {
+		ic_data->HX_INT_IS_EDGE = false;
+		ret = himax_int_en_set();
+
+		if (ret == 0) {
+			ts->irq_enabled = true;
+			atomic_set(&ts->irq_state, 1);
+		}
+	} else {
+		return -EINVAL;
+	}
+
+	return len;
+}
+
+int himax_proc_register_read(struct seq_file *m)
+{
+	int ret = 0;
+	uint16_t loop_i;
+	uint32_t tmp_data;
+	uint8_t wrapper_data[DATA_LEN_4] = { 0 };
+	uint8_t dd_addr = 0;
+	uint8_t bank = 0;
+	uint8_t pa_num = 0;
+
+	if (((char)cfg_flag == 'h') || ((char)cfg_flag == 'H')) {
+		seq_puts(m, "*Read from Master:\n");
+		seq_puts(m, " #echo register,r:x10007F10 > debug\n");
+		seq_puts(m, "*Write to Master:\n");
+		seq_puts(m, " #echo register,w:x10007F10:x00000000> debug\n");
+		seq_puts(m, "*Read from Slave_2:\n");
+		seq_puts(m, " #echo register,r:x02:x900000A8 > debug\n");
+		seq_puts(m, "*Write to Slave_3:\n");
+		seq_puts(m, " #echo register,w:x03:x10007F10:x03030303 > debug\n");
+		seq_puts(m, "*Write to Slave_12:\n");
+		seq_puts(m, " #echo register,w:x0C:x10007F10:x12121212 > debug\n");
+		seq_puts(m, "*Broadcast write to all slaves:\n");
+		seq_puts(m, " #echo register,w:x7E:x10007F10:x7E7E7E7E > debug\n");
+		seq_puts(m, "*Read 1 byte from Master:\n");
+		seq_puts(m, " #echo register,r:xFE0D > debug\n");
+		seq_puts(m, "*Write 1 byte to Master:\n");
+		seq_puts(m, " #echo register,w:xFE0D:x00 > debug\n");
+		return NO_ERR;
+	}
+
+	tmp_data = ((uint32_t) reg_cmd[3] << 24);
+	tmp_data += ((uint32_t) reg_cmd[2] << 16);
+	tmp_data += ((uint32_t) reg_cmd[1] << 8);
+	tmp_data += reg_cmd[0];
+	(void)memset(reg_read_data, 0x00, 128U * sizeof(uint8_t));
+
+	if (reg_cmd[3] == 0x00U) {
+		/* Disable retry wrapper to avoid I2C CLK low issue */
+		wrapper_data[0] = 0xA5;
+		himax_mcu_register_write(addr_retry_wrapper_clr_pw, 4, wrapper_data);
+		D("%s: Disable retry wrapper for flash read.\n", __func__);
+	}
+
+	D("himax_register_show: %02X,%02X,%02X,%02X\n", reg_cmd[3], reg_cmd[2],
+	  reg_cmd[1], reg_cmd[0]);
+
+	if (cfg_flag == 0xFEU) {
+		ret = himax_bus_read(reg_cmd[0], reg_read_data, 128,
+				     HIMAX_I2C_RETRY_TIMES);
+		seq_printf(m, "command:  %02X\n", reg_cmd[0]);
+	} else if (cfg_flag == 0xEEU) {
+		seq_puts(m, "*The input value has exceeded total number of ICs\n");
+	} else if (cfg_flag == (uint8_t)(IC_MASTER)) {
+		seq_printf(m, "command:  %02X,%02X,%02X,%02X\n", reg_cmd[3],
+			reg_cmd[2], reg_cmd[1], reg_cmd[0]);
+		if (reg_cmd[3] != 0x30U) {
+			himax_mcu_register_read(tmp_data, 128, reg_read_data);
+		} else {
+			himax_mcu_write_dd_reg_password(cfg_flag);
+			dd_addr = (reg_cmd[2] << 0x04) | (reg_cmd[1] >> 0x04);
+			bank = reg_cmd[1] & 0x0FU;
+			pa_num = reg_cmd[0];
+			D("dd_addr:%02X,bank:%02X,pa_num:%02X\n", dd_addr, bank, pa_num);
+			himax_mcu_dd_reg_read(dd_addr, pa_num, 16, reg_read_data, bank, IC_MASTER);
+
+			himax_mcu_clear_dd_reg_password(cfg_flag);
+		}
+	} else {
+		seq_printf(m, "*Access Slave %d\n", cfg_flag);
+		seq_printf(m, "command:  %02X,%02X,%02X,%02X\n", reg_cmd[3],
+			reg_cmd[2], reg_cmd[1], reg_cmd[0]);
+		if (reg_cmd[3] != 0x30U) {
+			himax_mcu_register_read_slave(cfg_flag, tmp_data, 128, reg_read_data);
+		} else {
+			himax_mcu_write_dd_reg_password(cfg_flag);
+			dd_addr = (reg_cmd[2] << 0x04) | (reg_cmd[1] >> 0x04);
+			bank = reg_cmd[1] & 0x0FU;
+			pa_num = reg_cmd[0];
+			D("dd_addr:%02X,bank:%02X,pa_num:%02X\n", dd_addr, bank, pa_num);
+			himax_mcu_dd_reg_read(dd_addr, pa_num, 16, reg_read_data, bank, cfg_flag);
+
+			himax_mcu_clear_dd_reg_password(cfg_flag);
+		}
+	}
+	if (cfg_flag != 0xEEU) {
+		for (loop_i = 0; loop_i < 128U; loop_i++) {
+			seq_printf(m, "0x%2.2X ", reg_read_data[loop_i]);
+			if ((loop_i % 16U) == 15U) {
+				seq_puts(m, "\n");
+			}
+		}
+	} else {
+		seq_puts(m, "*Please try again!\n");
+	}
+
+	seq_puts(m, "\n");
+
+	return ret;
+}
+
+ssize_t himax_proc_register_write(char *buf, size_t len)
+{
+	unsigned long result = 0;
+	char data_str[128] = { 0 };
+	char addr_str[9] = { 0 };
+	char ic_str[3] = { 0 };
+	int ret = 0;
+	uint8_t w_data[20] = { 0 };
+	uint32_t tmp_addr_32 = 0;
+	uint32_t loop_i = 0;
+	uint8_t dd_addr = 0;
+	uint8_t bank = 0;
+	uint8_t pa_num = 0;
+	char *token = NULL;
+	size_t str_len = 0;
+	char action = 0;
+	char *buf_backup;
+
+	buf_backup = kzalloc(sizeof(char) * (len), GFP_KERNEL);
+	(void)memcpy(&buf_backup[0], &buf[0], len);
+	(void)memset(reg_cmd, 0x0, sizeof(reg_cmd));
+
+	if (len >= 80U) {
+		W("%s: no command exceeds 80 chars.\n", __func__);
+		ret = -EFAULT;
+	} else if ((buf[0] == 'h') || (buf[0] == 'H')) {
+		D("%s: Call Help!\n", __func__);
+		cfg_flag = (uint8_t)buf[0];
+		ret = NO_ERR;
+	} else if (((buf[0] != 'r') && (buf[0] != 'w')) || (buf[1] != ':') ||
+		(buf[2] != 'x')) {
+		W("%s: Wrong input format=> %s\n", __func__, buf);
+		D("Try [#echo register,help > debug] to call help!\n");
+		ret = -EFAULT;
+	} else {
+		token = strsep(&buf_backup, "x");
+		while (token  != NULL) {
+			if (token[0] == 'w') {
+				action = 'w';
+			} else if (token[0] == 'r') {
+				action = 'r';
+			} else {
+				str_len = 0;
+				while (isxdigit(token[str_len]) != 0) {
+					str_len++;
+				}
+				if (str_len < sizeof(ic_str) && (uint8_t)addr_str[0] == 0U) {
+					(void)memcpy(&ic_str[0], &token[0], str_len);
+				} else if (action == 'w') {
+					if ((uint8_t)addr_str[0] == 0U) {
+						(void)memcpy(&addr_str[0], &token[0], str_len);
+					} else {
+						(void)memcpy(&data_str[0], &token[0], str_len);
+					}
+				} else if (action == 'r') {
+					if ((uint8_t)addr_str[0] == 0U) {
+						(void)memcpy(&addr_str[0], &token[0], str_len);
+					} else {
+						W("Undefined behavior\n");
+					}
+				} else {
+					/*Undefined behavior*/
+					W("Undefined behavior\n");
+				}
+			}
+			token = strsep(&buf_backup, "x");
+		}
+
+		if ((addr_str[0] == 'F') && (addr_str[1] == 'E')) {
+			cfg_flag = (uint8_t) 0xFE;
+			byte_length = 1;
+		} else if ((uint8_t)ic_str[0] != 0U) {
+			if (!kstrtoul(ic_str, 0, &result)) {
+				cfg_flag = (uint8_t)result;
+			} else {
+				W("kstrtoul for ic_str\n");
+			}
+			byte_length = DATA_LEN_4;
+		} else {
+			cfg_flag = (uint8_t)IC_MASTER;
+			byte_length = DATA_LEN_4;
+		}
+
+		D("action:%c,ic:%s,addr:%s,data:%s, cfg_flag:%d\n",
+			action, ic_str, addr_str, data_str, cfg_flag);
+
+
+		if ((cfg_flag > private_ts->slave_ic_num) && (cfg_flag != 0xFEU)
+			&& (cfg_flag != 0x7EU)) {
+
+			W("The input value %d has exceeded total number of ICs\n",
+				cfg_flag);
+			cfg_flag = 0xEEU;
+			ret = HX_FAIL;
+		}
+
+		if (action == 'r') {
+			if (!kstrtoul(addr_str, 16, &result)) {
+				for (loop_i = 0; loop_i < byte_length; loop_i++) {
+					reg_cmd[loop_i] = (uint8_t)(result >> (loop_i * 8U));
+				}
+			}
+		} else if (action == 'w') {
+			if (!kstrtoul(addr_str, 16, &result)) {
+				/* addr */
+				for (loop_i = 0; loop_i < byte_length; loop_i++) {
+					reg_cmd[loop_i] = (uint8_t)(result >> (loop_i * 8U));
+				}
+			}
+			if (!kstrtoul(data_str, 16, &result)) {
+				/* data */
+				for (loop_i = 0; loop_i < byte_length; loop_i++) {
+					w_data[loop_i] = (uint8_t)(result >> (loop_i * 8U));
+				}
+			}
+			if (cfg_flag == 0xFEU) {
+				ret = himax_bus_write(
+					reg_cmd[0], w_data, byte_length,
+					HIMAX_I2C_RETRY_TIMES);
+			} else if (cfg_flag == (uint8_t)(IC_MASTER)) {
+
+				if (reg_cmd[3] != 0x30U) {
+					tmp_addr_32 = ((uint32_t) reg_cmd[3] << 24);
+					tmp_addr_32 += ((uint32_t) reg_cmd[2] << 16);
+					tmp_addr_32 += ((uint32_t) reg_cmd[1] << 8);
+					tmp_addr_32 += reg_cmd[0];
+					himax_mcu_register_write(tmp_addr_32,
+						byte_length, w_data);
+				} else {
+					himax_mcu_write_dd_reg_password(cfg_flag);
+					dd_addr = (reg_cmd[2] << 0x04) | (reg_cmd[1] >> 0x04);
+					bank = reg_cmd[1] & 0x0FU;
+					pa_num = reg_cmd[0];
+					D("dd_addr:%02X,bank:%02X,pa_num:%02X\n", dd_addr, bank, pa_num);
+					himax_mcu_dd_reg_write(dd_addr,
+							pa_num, byte_length, w_data, bank, IC_MASTER);
+					himax_mcu_clear_dd_reg_password(cfg_flag);
+				}
+			} else {
+				if (reg_cmd[3] != 0x30U) {
+					tmp_addr_32 = ((uint32_t) reg_cmd[3] << 24);
+					tmp_addr_32 += ((uint32_t) reg_cmd[2] << 16);
+					tmp_addr_32 += ((uint32_t) reg_cmd[1] << 8);
+					tmp_addr_32 += reg_cmd[0];
+					himax_mcu_register_write_slave(cfg_flag,
+						tmp_addr_32, byte_length, w_data);
+				} else {
+					himax_mcu_write_dd_reg_password(cfg_flag);
+					dd_addr = (reg_cmd[2] << 0x04) | (reg_cmd[1] >> 0x04);
+					bank = reg_cmd[1] & 0x0FU;
+					pa_num = reg_cmd[0];
+					D("dd_addr:%02X,bank:%02X,pa_num:%02X\n", dd_addr, bank, pa_num);
+					himax_mcu_dd_reg_write(dd_addr,
+							pa_num, byte_length, w_data, bank, cfg_flag);
+					himax_mcu_clear_dd_reg_password(cfg_flag);
+				}
+			}
+		} else {
+			W("Undefined behavior\n");
+			ret = HX_FAIL;
+		}
+		ret = (int)len;
+		kfree(buf_backup);
+	}
+	return ret;
+}
+
+ssize_t himax_reset_write(char *buf, size_t len)
+{
+	uint8_t tmp_data[4] = { 0 };
+
+	if (len >= 12U) {
+		D("%s: no command exceeds 12 chars.\n", __func__);
+		return -EFAULT;
+	}
+	switch (buf[0]) {
+#if (HX_RST_PIN_FUNC == 0x01)
+	case '1':
+		himax_mcu_hw_reset(false);
+		break;
+	case '2':
+		himax_mcu_hw_reset(true);
+		break;
+#endif
+	case '5':
+		himax_mcu_system_reset();
+		himax_mcu_register_read(addr_flag_reset_event, DATA_LEN_4,
+					tmp_data);
+		D("%s: Read 0x900000E4 with value 0x%02X.\n", __func__,
+		  tmp_data[0]);
+		break;
+	case '6':
+		himax_mcu_command_reset();
+		himax_mcu_register_read(addr_flag_reset_event, DATA_LEN_4,
+					tmp_data);
+		D("%s: Read 0x900000E4 with value 0x%02X.\n", __func__,
+		  tmp_data[0]);
+		break;
+	default:
+		W("%s: Undefined behavior\n", __func__);
+		break;
+	}
+
+	return len;
+}
+
+ssize_t himax_diag_arrange_write(char *buf, size_t len)
+{
+	int value = 0;
+
+	if (len >= 80U) {
+		D("%s: no command exceeds 80 chars.\n", __func__);
+		return -EFAULT;
+	}
+	if (!kstrtoint(buf, 0, &value)) {
+		g_diag_arr_num = (uint8_t)value;
+	} else {
+		W("[FAIL]kstrtoul\n");
+	}
+	D("%s: g_diag_arr_num = %d\n", __func__, g_diag_arr_num);
+	return len;
+}
+
+ssize_t himax_diag_cmd_write(char *buf, size_t len)
+{
+	struct himax_ts_data *ts = private_ts;
+	int input_cmd = 0;
+	uint8_t timeout_cnt = 0;
+
+	/*Old version*/
+	if (len <= 2U) {
+		if (!kstrtoint(buf, 16, &input_cmd)) {
+			ts->diag_cmd = (uint8_t)input_cmd;
+			if (ts->diag_cmd <= 0x03U) {
+				process_type = (uint8_t)Tch_mot_flag;
+			} else if ((ts->diag_cmd >= 0x11U) && (ts->diag_cmd <= 0x1FU)) {
+				process_type = (uint8_t)Dsram_delivery;
+				ts->diag_cmd &= 0x0FU;
+				if (ts->diag_cmd <= 0x03U) {
+					ts->diag_cmd += 0x08U;
+				}
+			} else {
+				W("%s: Wrong diag cmd!\n", __func__);
+				return -EFAULT;
+			}
+			D("%s: Set process_type = 0x%02X\n", __func__, process_type);
+		}
+	}
+	/*New version*/
+	if (len == 3U) {
+		if ((buf[0] == 'x') || (buf[0] == 'X')) {
+			if (!kstrtoint(&buf[1], 16, &input_cmd)) {
+				ts->diag_cmd = (uint8_t)input_cmd;
+				if (ts->diag_cmd <= 0x03U) {
+					process_type = (uint8_t)Tch_mot_flag;
+				} else if ((ts->diag_cmd >= 0x08U) && (ts->diag_cmd <= 0x11U)) {
+					process_type = (uint8_t)Dsram_delivery;
+				} else {
+					/* do nothing*/
+				}
+				D("%s: Set process_type = 0x%02X\n", __func__, process_type);
+			}
+		} else {
+			W("%s: Wrong diag cmd!\n", __func__);
+			return -EFAULT;
+		}
+	}
+	if ((pre_diag_cmd != ts->diag_cmd) && (diag_wq_alive)) {
+		while (diag_wq_alive == true) {
+			usleep_range(10000, 11000);
+			timeout_cnt++;
+			if (timeout_cnt > 20U) {
+				break;
+			}
+		}
+
+		cancel_delayed_work_sync(&ts->himax_diag_delay_wrok);
+		diag_wq_alive = false;
+		himax_mcu_stop_DSRAM_output();
+	}
+	if (process_type == (uint8_t)Tch_mot_flag) {
+		himax_int_enable(1);
+		himax_mcu_diag_register_set(ts->diag_cmd, IC_MASTER);
+		D("%s: Raw Data Delivery (Touch Monitor)\n", __func__);
+	} else if (process_type == (uint8_t)Dsram_delivery) {
+		himax_mcu_diag_register_set(
+			ts->diag_cmd, IC_MASTER);
+		if (!diag_wq_alive) {
+			/*Start wrok queue*/
+			himax_int_enable(0);
+			queue_delayed_work(ts->himax_diag_wq,
+					   &ts->himax_diag_delay_wrok,
+					   2 * HZ / 100);
+			diag_wq_alive = true;
+			D("%s: Raw Data Delivery (DSRAM)\n", __func__);
+		}
+	} else {
+		/* do nothing*/
+	}
+	D("%s: Set raw out select 0x%02X.\n", __func__, ts->diag_cmd);
+	pre_diag_cmd = ts->diag_cmd;
+	return len;
+}
+
+ssize_t himax_GMA_cmd_write(char *buf, size_t len)
+{
+	const struct firmware *fw = NULL;
+	int ret = 0;
+	D("%s : %s\n", __func__, buf);
+
+	if (len >= 80U) {
+		D("%s: no command exceeds 80 chars.\n", __func__);
+		ret = -EFAULT;
+	} else {
+		if (strcmp(buf, "AGMA") == 0) {
+			ret = request_firmware(&fw, "AGMA.txt", private_ts->dev);
+		} else if (strcmp(buf, "DGMA") == 0) {
+			ret = request_firmware(&fw, "DGMA.txt", private_ts->dev);
+		} else if (strcmp(buf, "VCOM") == 0) {
+			ret = request_firmware(&fw, "VCOM.txt", private_ts->dev);
+		} else {
+			E("Input string is incorrect.\n");
+			ret = -EFAULT;
+		}
+
+		if (ret < 0) {
+			E("%s: Open GMA file failed\n", __func__);
+		} else {
+			D("%s: fw->size: %d\n", __func__, fw->size);
+			ret = himax_convert_GMA_data(fw->data,
+										(size_t)fw->size, buf[0]);
+			if (ret < 0) {
+				E("%s: himax_convert_GMA_data failed!\n", __func__);
+			} else {
+				himax_burn_GMA_to_flash((const u8 *)g_gma_buf, buf[0]);
+				ret = (int)len;
+			}
+			release_firmware(fw);
+			kfree(g_gma_buf);
+			g_gma_buf = NULL;
+		}
+	}
+
+	return ret;
+}
+
+int himax_vendor_show(struct seq_file *s, void *v)
+{
+	ssize_t ret = 0;
+	uint16_t cid = 0;
+
+	UNUSED(v);
+
+	himax_mcu_config_reload_enable();
+	himax_mcu_power_on_init();
+	himax_mcu_read_FW_ver();
+	g_core_fp.fp_touch_information();
+
+	seq_printf(s, "IC = %s\n", private_ts->chip_name);
+
+	seq_printf(s, "FW Architecture Version = 0x%2.2X\n",
+		ic_data->vendor_arch_ver);
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+	seq_printf(s, "FW Algorithm Version = A%02X\n",
+		ic_data->vendor_display_cfg_ver);
+#else
+	seq_printf(s, "FW Display Config Version = D%02X\n",
+		ic_data->vendor_display_cfg_ver);
+#endif
+	seq_printf(s, "FW Touch Config Version = C%02X\n",
+		ic_data->vendor_touch_cfg_ver);
+
+	cid = ((uint16_t)ic_data->vendor_cid_maj_ver << 8);
+	cid += ic_data->vendor_cid_min_ver;
+	seq_printf(s, "CID = 0x%2.2X\n", cid);
+
+
+	seq_printf(s, "Panel Version = 0x%2.2X\n",
+		ic_data->vendor_panel_ver);
+
+
+	if (ic_data->vendor_arch_ver >= 0x8098U) {
+		seq_printf(s, "Remark 1 : %s\n", ic_data->vendor_remark1);
+		seq_printf(s, "Remark 2 : %s\n", ic_data->vendor_remark2);
+		seq_printf(s, "Himax Ticket : %s\n", ic_data->vendor_ticket);
+	}
+
+	seq_printf(s, "Customer = %s\n", ic_data->vendor_cus_info);
+	seq_printf(s, "Project = %s\n", ic_data->vendor_proj_info);
+	seq_printf(s, "FW Config Date  = %s\n", ic_data->vendor_config_date);
+
+	seq_puts(s, "\n");
+	seq_puts(s, "Himax Touch Driver Version:\n");
+	seq_printf(s, "%s\n", HIMAX_DRIVER_VER);
+
+	return ret;
+}
+int himax_vendor_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_vendor_show, NULL);
+}
+const struct proc_ops_name himax_vendor_ops = {
+	.proc_op(open) = himax_vendor_open,
+	.proc_op(read) = seq_read,
+};
+
+
+int himax_pintest_show(struct seq_file *s, void *v)
+{
+	ssize_t ret = 0;
+	bool flag = true;
+
+	UNUSED(v);
+
+#if (HX_RST_PIN_FUNC == 0x01)
+	himax_gpio_set(private_ts->rst_gpio, 0);
+	usleep_range(1000, 1100);
+	if (gpio_get_value(private_ts->rst_gpio) == 1) {
+		flag = false;
+		seq_puts(s, "TP_EXT_RSTN pin Low: Fail!\n");
+	} else {
+		seq_puts(s, "TP_EXT_RSTN pin Low: Pass!\n");
+	}
+
+#endif
+
+	himax_gpio_set(private_ts->lcm_gpio, 0);
+
+	if (gpio_get_value(private_ts->lcm_gpio) == 1) {
+		flag = false;
+		seq_puts(s, "RESX pin Low: Fail!\n");
+	} else {
+		seq_puts(s, "RESX pin Low: Pass!\n");
+	}
+
+	himax_gpio_set(private_ts->pon_gpio, 0);
+
+	if (gpio_get_value(private_ts->pon_gpio) == 1) {
+		flag = false;
+		seq_puts(s, "PON pin Low: Fail!\n");
+	} else {
+		seq_puts(s, "PON pin Low: Pass!\n");
+	}
+
+	usleep_range(6000, 6100);
+
+	himax_gpio_set(private_ts->lcm_gpio, 1);
+
+	if (gpio_get_value(private_ts->lcm_gpio) == 0) {
+		flag = false;
+		seq_puts(s, "RESX pin High: Fail!\n");
+	} else {
+		seq_puts(s, "RESX pin High: Pass!\n");
+	}
+
+	usleep_range(1000, 1100);
+
+#if (HX_RST_PIN_FUNC == 0x01)
+	himax_gpio_set(private_ts->rst_gpio, 1);
+	usleep_range(1000, 1100);
+	if (gpio_get_value(private_ts->rst_gpio) == 0) {
+		flag = false;
+		seq_puts(s, "TP_EXT_RSTN pin High: Fail!\n");
+	} else {
+		seq_puts(s, "TP_EXT_RSTN pin High: Pass!\n");
+	}
+#endif
+
+	msleep(95);
+
+	himax_gpio_set(private_ts->pon_gpio, 1);
+
+	if (gpio_get_value(private_ts->pon_gpio) == 0) {
+		flag = false;
+		seq_puts(s, "PON pin High: Fail!\n");
+	} else {
+		seq_puts(s, "PON pin High: Pass!\n");
+	}
+
+	seq_puts(s, "\n");
+	if (flag) {
+		seq_puts(s, "Himax pintest function pass!\n");
+	} else {
+		seq_puts(s, "Himax pintest function fail!\n");
+	}
+
+	return ret;
+}
+int himax_pintest_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_pintest_show, NULL);
+}
+const struct proc_ops_name himax_pintest_ops = {
+	.proc_op(open) = himax_pintest_open,
+	.proc_op(read) = seq_read,
+};
+
+int himax_set_diag_cmd(struct himax_ic_data *ic_data_tmp,
+		       struct himax_report_data *hx_touch_data_tmp)
+{
+	struct himax_ts_data *ts = private_ts;
+	int16_t *mutual_data;
+	int16_t *self_data;
+	uint16_t mul_num;
+	uint16_t self_num;
+	/* int RawDataLen = 0; */
+	hx_touch_data_tmp->diag_cmd = ts->diag_cmd;
+
+	if ((hx_touch_data_tmp->diag_cmd >= 1U) && (hx_touch_data_tmp->diag_cmd <= 3U)) {
+		/* Check event stack CRC */
+		if (!himax_mcu_diag_check_sum(hx_touch_data_tmp)) {
+			goto bypass_checksum_failed_packet;
+		}
+
+		mutual_data = getMutualBuffer();
+		self_data = getSelfBuffer();
+		/* initiallize the block number of mutual and self */
+		mul_num = (uint16_t)ic_data_tmp->HX_RX_NUM * (uint16_t)ic_data_tmp->HX_TX_NUM;
+
+		self_num = (uint16_t)ic_data_tmp->HX_RX_NUM + (uint16_t)ic_data_tmp->HX_TX_NUM;
+
+		himax_mcu_diag_parse_raw_data(hx_touch_data_tmp, mul_num, self_num,
+					      hx_touch_data_tmp->diag_cmd,
+					      mutual_data, self_data);
+	/*} else if (hx_touch_data_tmp->diag_cmd == 8) {
+	 *	memset(diag_coor, 0x00, sizeof(diag_coor));
+	 *	memcpy(&(diag_coor[0]), &hx_touch_data_tmp->hx_coord_buf[0],
+	 *	       hx_touch_data_tmp->touch_info_size);
+	 */
+	}
+
+	/* assign state info data */
+	(void)memcpy(&(g_hx_state_info[0]), &hx_touch_data_tmp->hx_state_info[0], 2);
+	return NO_ERR;
+bypass_checksum_failed_packet:
+	return 1;
+}
+
+/* #if defined(HX_DEBUG_LEVEL) */
+static void himax_log_touch_data(int start)
+{
+	unsigned int loop_i = 0;
+	unsigned int print_size = 0;
+	uint8_t *buf = NULL;
+
+	if (start == 1) {
+		return; /* report data when end of ts_work*/
+	}
+
+	if (hx_touch_data->diag_cmd > 0U) {
+		print_size = hx_touch_data->touch_all_size;
+		buf = kcalloc(print_size, sizeof(uint8_t), GFP_KERNEL);
+		if (buf == NULL) {
+			E("%s, Failed to allocate memory\n", __func__);
+			return;
+		}
+
+		(void)memcpy(buf, hx_touch_data->hx_coord_buf,
+		       hx_touch_data->touch_info_size);
+		(void)memcpy(&buf[hx_touch_data->touch_info_size],
+		       hx_touch_data->hx_rawdata_buf,
+		       print_size - hx_touch_data->touch_info_size);
+	} else if (hx_touch_data->diag_cmd == 0U) {
+		print_size = hx_touch_data->touch_info_size;
+		buf = kcalloc(print_size, sizeof(uint8_t), GFP_KERNEL);
+		if (buf == NULL) {
+			E("%s, Failed to allocate memory\n", __func__);
+			return;
+		}
+
+		(void)memcpy(buf, hx_touch_data->hx_coord_buf, print_size);
+	} else {
+		E("%s:cmd fault\n", __func__);
+		return;
+	}
+
+	for (loop_i = 0U; loop_i < print_size; loop_i += 8U) {
+		if ((loop_i + 7U) >= print_size) {
+			D("P %2d = 0x%2.2X P %2d = 0x%2.2X ", loop_i,
+			  buf[loop_i], loop_i + 1U, buf[loop_i + 1U]);
+			D("P %2d = 0x%2.2X P %2d = 0x%2.2X\n", loop_i + 2U,
+			  buf[loop_i + 2U], loop_i + 3U, buf[loop_i + 3U]);
+			break;
+		}
+
+		D("P %2d = 0x%2.2X P %2d = 0x%2.2X ", loop_i, buf[loop_i],
+		  loop_i + 1U, buf[loop_i + 1U]);
+		D("P %2d = 0x%2.2X P %2d = 0x%2.2X ", loop_i + 2U,
+		  buf[loop_i + 2U], loop_i + 3U, buf[loop_i + 3U]);
+		D("P %2d = 0x%2.2X P %2d = 0x%2.2X ", loop_i + 4U,
+		  buf[loop_i + 4U], loop_i + 5U, buf[loop_i + 5U]);
+		D("P %2d = 0x%2.2X P %2d = 0x%2.2X ", loop_i + 6U,
+		  buf[loop_i + 6U], loop_i + 7U, buf[loop_i + 7U]);
+		D("\n");
+	}
+	kfree(buf);
+	buf = NULL;
+}
+
+#define PRT_LOG "Finger %d=> X:%d, Y:%d W:%d, Z:%d\n"
+static void himax_log_touch_event(struct himax_ts_data *ts, int start)
+{
+	unsigned int loop_i = 0;
+
+	if (start == 1) {
+		return; /*report data when end of ts_work*/
+	}
+
+	if ((g_target_report_data->finger_on > 0U) &&
+	    (g_target_report_data->finger_num > 0U)) {
+		for (loop_i = 0U; loop_i < ts->nFinger_support; loop_i++) {
+			if ((g_target_report_data->x[loop_i] <
+				    ts->pdata->abs_x_max) &&
+			    (g_target_report_data->y[loop_i] <
+				    ts->pdata->abs_y_max)) {
+				I(PRT_LOG, loop_i + 1U,
+				  g_target_report_data->x[loop_i],
+				  g_target_report_data->y[loop_i],
+				  g_target_report_data->w[loop_i],
+				  g_target_report_data->w[loop_i]);
+			}
+		}
+	}
+	if ((g_target_report_data->finger_on == 0U) &&
+		   (g_target_report_data->finger_num == 0U)) {
+		D("All Finger leave\n");
+	}
+}
+static void himax_log_touch_int_devation(int touched)
+{
+	if (touched == HX_FINGER_ON) {
+		time_func(&g_timeStart);
+		/* D(" Irq start time = %ld.%06ld s\n",
+		 * g_timeStart.tv_sec, g_timeStart.tv_nsec/1000);
+		 */
+	} else if (touched == HX_FINGER_LEAVE) {
+		time_func(&g_timeEnd);
+		g_timeDelta = time_diff(g_timeStart, g_timeEnd);
+		/*  D("Irq finish time = %ld.%06ld s\n",
+		 *	g_timeEnd.tv_sec, g_timeEnd.tv_nsec/1000);
+		 */
+		D("Touch latency = %ld us\n", g_timeDelta.tv_nsec / 1000);
+		D("bus_speed = %d kHz\n", private_ts->bus_speed);
+		if ((g_target_report_data->finger_on == 0U) &&
+		    (g_target_report_data->finger_num == 0U)) {
+			 D("All Finger leave\n");
+		}
+	} else {
+		/* Undefined behavior*/
+		D("%s : wrong input!\n", __func__);
+	}
+}
+
+#define RAW_DOWN_STATUS "status: Raw:F:%02d Down, X:%d, Y:%d, W:%d\n"
+#define RAW_UP_STATUS "status: Raw:F:%02d Up, X:%d, Y:%d\n"
+
+static void himax_log_touch_event_detail(struct himax_ts_data *ts, int start)
+{
+	uint32_t loop_i = 0;
+
+	if (start == HX_FINGER_LEAVE) {
+		for (loop_i = 0; loop_i < ts->nFinger_support; loop_i++) {
+			if ((((ts->old_finger >> loop_i) & 1U) == 0U) &&
+			    (((ts->pre_finger_mask >> loop_i) & 1U) == 1U)) {
+				if ((g_target_report_data->x[loop_i] <
+					    ts->pdata->abs_x_max) &&
+				    (g_target_report_data->y[loop_i] <
+					    ts->pdata->abs_y_max)) {
+					I(RAW_DOWN_STATUS, loop_i + 1U,
+					  g_target_report_data->x[loop_i],
+					  g_target_report_data->y[loop_i],
+					  g_target_report_data->w[loop_i]);
+				}
+			} else if (((((ts->old_finger >> loop_i) & 1U) == 1U) &&
+				    (((ts->pre_finger_mask >> loop_i) & 1U) ==
+				     0U))) {
+				I(RAW_UP_STATUS, loop_i + 1U,
+				  ts->pre_finger_data[loop_i][0],
+				  ts->pre_finger_data[loop_i][1]);
+			} else {
+				/* D("dbg hx_point_num=%d, old_finger=0x%02X,"
+				 * " pre_finger_mask=0x%02X\n",
+				 * ts->hx_point_num, ts->old_finger,
+				 * ts->pre_finger_mask);
+				 */
+			}
+		}
+	}
+}
+
+void himax_ts_dbg_func(struct himax_ts_data *ts, int start)
+{
+	if ((ts->debug_log_level & BIT(0)) != 0U) {
+		/* D("debug level 1\n"); */
+		himax_log_touch_data(start);
+	}
+	if ((ts->debug_log_level & BIT(1)) != 0U) {
+		/* D("debug level 2\n"); */
+		himax_log_touch_event(ts, start);
+	}
+	if ((ts->debug_log_level & BIT(2)) != 0U) {
+		/* D("debug level 4\n"); */
+		himax_log_touch_int_devation(start);
+	}
+	if ((ts->debug_log_level & BIT(3)) != 0U) {
+		/* D("debug level 8\n"); */
+		himax_log_touch_event_detail(ts, start);
+	}
+}
+
+static void himax_himax_data_init(void)
+{
+	debug_data->fp_ts_dbg_func = himax_ts_dbg_func;
+	debug_data->fp_set_diag_cmd = himax_set_diag_cmd;
+}
+
+static void himax_get_mutual_edge(void)
+{
+	uint32_t i = 0;
+	uint32_t mutual_val = (uint32_t)ic_data->HX_RX_NUM
+							* (uint32_t)ic_data->HX_TX_NUM;
+
+	for (i = 0; i < mutual_val; i++) {
+		if (diag_mutual[i] > g_max_mutual) {
+			g_max_mutual = diag_mutual[i];
+		}
+
+		if (diag_mutual[i] < g_min_mutual) {
+			g_min_mutual = diag_mutual[i];
+		}
+	}
+}
+
+static void himax_get_self_edge(void)
+{
+	uint16_t i = 0;
+	uint16_t self_val = (uint16_t)ic_data->HX_RX_NUM
+						+ (uint16_t)ic_data->HX_TX_NUM;
+
+	for (i = 0; i < self_val; i++) {
+		if (diag_self[i] > g_max_self) {
+			g_max_self = diag_self[i];
+		}
+
+		if (diag_self[i] < g_min_self) {
+			g_min_self = diag_self[i];
+		}
+	}
+}
+
+static void print_state_info(struct seq_file *s)
+{
+	/* seq_printf(s, "State_info_2bytes:%3d, %3d\n",
+	 * _state_info[0],hx_state_info[1]);
+	 */
+	seq_printf(s, "ReCal = %d\t", g_hx_state_info[0] & 0x01U);
+	seq_printf(s, "Palm = %d\t", (g_hx_state_info[0] >> 1U) & 0x01U);
+	seq_printf(s, "AC mode = %d\t", (g_hx_state_info[0] >> 2U) & 0x01U);
+	seq_printf(s, "Water = %d\n", (g_hx_state_info[0] >> 3U) & 0x01U);
+	seq_printf(s, "Glove = %d\t", (g_hx_state_info[0] >> 4U) & 0x01U);
+	seq_printf(s, "TX Hop = %d\t", (g_hx_state_info[0] >> 5U) & 0x01U);
+	seq_printf(s, "Base Line = %d\t", (g_hx_state_info[0] >> 6U) & 0x01U);
+	seq_printf(s, "OSR Hop = %d\t", (g_hx_state_info[1] >> 3U) & 0x01U);
+	seq_printf(s, "KEY = %d\n", (g_hx_state_info[1] >> 4U) & 0x0FU);
+}
+#if (HIMAX_LTDI_CONFIG == 0x00)
+static void himax_diag_arrange_print(struct seq_file *s, int i, int j,
+				     bool transpose)
+{
+	if (transpose) {
+		seq_printf(s, "%6d", diag_mutual[j + (i * (int)ic_data->HX_RX_NUM)]);
+	} else {
+		seq_printf(s, "%6d", diag_mutual[i + (j * (int)ic_data->HX_RX_NUM)]);
+	}
+}
+
+/* ready to print second step which is column*/
+static void himax_diag_arrange_inloop(struct seq_file *s, int in_init,
+				      int out_init, bool transpose, int j)
+{
+	int x_channel = (int) ic_data->HX_RX_NUM;
+	int y_channel = (int) ic_data->HX_TX_NUM;
+	int i;
+	int in_max = 0;
+
+	if (transpose) {
+		in_max = y_channel;
+	} else {
+		in_max = x_channel;
+	}
+
+	if (in_init > 0) { /* bit0 = 1 */
+		for (i = in_init - 1; i >= 0; i--) {
+			himax_diag_arrange_print(s, i, j, transpose);
+		}
+
+		if (transpose) {
+			if (out_init > 0) {
+				seq_printf(s, " %5d\n", diag_self[j]);
+			} else {
+				seq_printf(s, " %5d\n",
+					   diag_self[x_channel - j - 1]);
+			}
+		}
+	} else { /* bit0 = 0 */
+		for (i = 0; i < in_max; i++) {
+			himax_diag_arrange_print(s, i, j, transpose);
+		}
+
+		if (transpose) {
+			if (out_init > 0) {
+				seq_printf(s, " %5d\n",
+					   diag_self[x_channel - j - 1]);
+			} else {
+				seq_printf(s, " %5d\n", diag_self[j]);
+			}
+		}
+	}
+}
+
+/* print first step which is row */
+static void himax_diag_arrange_outloop(struct seq_file *s, bool transpose,
+				       int out_init, int in_init)
+{
+	int j;
+	int x_channel = (int)ic_data->HX_RX_NUM;
+	int y_channel = (int)ic_data->HX_TX_NUM;
+	int out_max = 0;
+	int self_cnt = 0;
+	int base = out_init - 1;
+
+	if (transpose) {
+		out_max = x_channel;
+	} else {
+		out_max = y_channel;
+	}
+
+	if (out_init > 0) { /* bit1 = 1 */
+		self_cnt = 1;
+
+		for (j = base; j >= 0; j--) {
+			seq_printf(s, "%3c%02d%c", '[', j + 1, ']');
+			himax_diag_arrange_inloop(s, in_init, out_init,
+						  transpose, j);
+
+			if (!transpose) {
+				seq_printf(s, " %5d\n",
+					   diag_self[y_channel + x_channel -
+						     self_cnt]);
+				self_cnt++;
+			}
+		}
+	} else { /* bit1 = 0 */
+		/* self_cnt = x_channel; */
+		for (j = 0; j < out_max; j++) {
+			seq_printf(s, "%3c%02d%c", '[', j + 1, ']');
+			himax_diag_arrange_inloop(s, in_init, out_init,
+						  transpose, j);
+
+			if (!transpose) {
+				seq_printf(s, " %5d\n",
+					   diag_self[j + x_channel]);
+			}
+		}
+	}
+}
+#endif
+/* determin the output format of diag */
+static void himax_diag_arrange(struct seq_file *s)
+{
+
+#if (HIMAX_LTDI_CONFIG == 0x00)
+	bool bit2 = false;
+	int bit1 = 0;
+	int bit0 = 0;
+#endif
+	int x_channel = (int)ic_data->HX_RX_NUM;
+	int y_channel = (int)ic_data->HX_TX_NUM;
+	int i;
+#if (HIMAX_LTDI_CONFIG == 0x01)
+	int j;
+	int data_frame_size = 0;
+	int chip_id_sel = 0;
+
+	x_channel = (int)ic_data->HX_CHIP_RX_MAX;
+	y_channel = (int)ic_data->HX_CHIP_TX_MAX;
+	data_frame_size = x_channel * y_channel;
+
+	seq_printf(s, "%6c", ' ');
+	for (j = 0; j < (int)ic_data->HX_RX_NUM; j++) {
+		seq_printf(s, "%3c%02d%c", '[', ((j % x_channel) + 1), ']');
+	}
+
+	seq_puts(s, "\n");
+	for (i = 0; i < (int)ic_data->HX_TX_NUM; i++) {
+		seq_printf(s, "%3c%02d%c", '[', ((i % y_channel) + 1), ']');
+		for (j = 0; j < (int)ic_data->HX_RX_NUM; j++) {
+			chip_id_sel = j / x_channel;
+			seq_printf(s, "%6d", diag_mutual[(j % x_channel) + (i * x_channel) + (chip_id_sel * data_frame_size)]);
+			/*seq_printf(s, "%6d", diag_mutual[i + (j * ic_data->HX_TX_NUM)]);*/
+		}
+		seq_puts(s, "\n");
+	}
+#else
+	/* rotate bit */
+	if ((g_diag_arr_num & 0x04U) == 0x04U) {
+		bit2 = true;
+	}
+	/* reverse Y */
+	if ((g_diag_arr_num & 0x02U) == 0x02U) {
+		bit1 = 1;
+	}
+	/* reverse X */
+	if ((g_diag_arr_num & 0x01U) == 0x01U) {
+		bit0 = 1;
+	}
+
+	if (g_diag_arr_num < 4U) {
+		for (i = 0; i <= x_channel; i++) {
+			seq_printf(s, "%3c%02d%c", '[', i, ']');
+		}
+
+		seq_puts(s, "\n");
+		himax_diag_arrange_outloop(s, bit2, bit1 * y_channel,
+					   bit0 * x_channel);
+		seq_printf(s, "%6c", ' ');
+
+		if (bit0 == 1) {
+			for (i = x_channel - 1; i >= 0; i--) {
+				seq_printf(s, "%6d", diag_self[i]);
+			}
+		} else {
+			for (i = 0; i < x_channel; i++) {
+				seq_printf(s, "%6d", diag_self[i]);
+			}
+		}
+	} else {
+		for (i = 0; i <= y_channel; i++) {
+			seq_printf(s, "%3c%02d%c", '[', i, ']');
+		}
+
+		seq_puts(s, "\n");
+		himax_diag_arrange_outloop(s, bit2, bit1 * x_channel,
+					   bit0 * y_channel);
+		seq_printf(s, "%6c", ' ');
+
+		if (bit1 == 1) {
+			for (i = y_channel; i > 0; i--) {
+				seq_printf(s, "%6d", diag_self[i + x_channel - 1]);
+			}
+		} else {
+			for (i = x_channel; i < (x_channel + y_channel); i++) {
+				seq_printf(s, "%6d", diag_self[i]);
+			}
+		}
+	}
+#endif
+}
+
+/* DSRAM thread */
+bool himax_ts_diag_func(void)
+{
+	unsigned int i = 0;
+	unsigned int j = 0;
+	unsigned int index = 0;
+	unsigned int x_channel = ic_data->HX_RX_NUM;
+	unsigned int y_channel = ic_data->HX_TX_NUM;
+	unsigned int total_size = ((y_channel * x_channel) + y_channel + x_channel) * 2U;
+	uint8_t *tmp_rawdata = NULL;
+	int16_t *mutual_data = NULL;
+	int16_t *mutual_data_new = NULL;
+	int16_t *mutual_data_old = NULL;
+	int16_t *self_data = NULL;
+	int16_t *self_data_new = NULL;
+	int16_t *self_data_old = NULL;
+	int16_t raw_data;
+	uint16_t raw_data_tmp16;
+	/* 1:common dsram,2:100 frame Max,3:N-(N-1)frame */
+	struct himax_ts_data *ts = private_ts;
+
+	tmp_rawdata = kcalloc(total_size, sizeof(uint8_t), GFP_KERNEL);
+	if (tmp_rawdata == NULL) {
+		E("%s: Failed to allocate memory\n", __func__);
+		return false;
+	}
+	(void)memset(tmp_rawdata, 0U, total_size * sizeof(uint8_t));
+
+	D("%s: process type=%d,  pre_diag_cmd : %d\n", __func__, process_type, pre_diag_cmd);
+	if (process_type <= 2U) {
+		mutual_data = getMutualBuffer();
+		self_data = getSelfBuffer();
+	} else {
+		/* do nothing*/
+	}
+
+	if (g_core_fp.fp_get_DSRAM_data(tmp_rawdata) != true) {
+		E("%s: Get DSRAM data failed\n", __func__);
+		kfree(tmp_rawdata);
+		tmp_rawdata = NULL;
+		goto END_FUNC;
+	}
+
+	index = 0;
+	for (i = 0; i < y_channel; i++) { /*mutual data*/
+		for (j = 0; j < x_channel; j++) {
+			raw_data_tmp16 = (uint16_t) tmp_rawdata[index + 1U] * 256U;
+			raw_data_tmp16 += (uint16_t) tmp_rawdata[index];
+			raw_data = (int16_t) raw_data_tmp16;
+			if (process_type <= (uint8_t)Dsram_delivery) {
+				mutual_data[(i * x_channel) + j] = raw_data;
+			} else if (process_type == 2U) { /* Keep max data */
+				if (mutual_data[(i * x_channel) + j] < raw_data) {
+					mutual_data[(i * x_channel) + j] =
+						raw_data;
+				}
+			} else {
+				/* do nothing*/
+			}
+			index += 2U;
+		}
+	}
+
+	for (i = 0; i < (x_channel + y_channel); i++) { /*self data*/
+	raw_data_tmp16 = (uint16_t) tmp_rawdata[index + 1U] << 8U;
+			raw_data_tmp16 += (uint16_t) tmp_rawdata[index];
+			raw_data = (int16_t) raw_data_tmp16;
+		if (process_type <= (uint8_t)Dsram_delivery) {
+			self_data[i] = raw_data;
+		} else if (process_type == 2U) { /* Keep max data */
+			if (self_data[i] < raw_data) {
+				self_data[i] = raw_data;
+			}
+		} else {
+			/* do nothing*/
+		}
+		index += 2U;
+	}
+
+	kfree(tmp_rawdata);
+	tmp_rawdata = NULL;
+
+END_FUNC:
+
+	diag_max_cnt++;
+	if ((process_type >= (uint8_t)Dsram_delivery) && (ts->diag_cmd > 0U)
+		&& (pre_diag_cmd == ts->diag_cmd)) {
+		queue_delayed_work(private_ts->himax_diag_wq,
+				   &private_ts->himax_diag_delay_wrok,
+				   1 / 10 * HZ);
+	} else {
+		diag_wq_alive = false;
+	}
+	return true;
+}
+
+static void himax_diag_print(struct seq_file *s, void *v)
+{
+	unsigned int x_num = ic_data->HX_RX_NUM;
+	unsigned int y_num = ic_data->HX_TX_NUM;
+
+	UNUSED(v);
+
+	seq_printf(s, "ChannelStart: %4d, %4d\n\n", x_num, y_num);
+
+	/*	start to show out the raw data in adb shell */
+	himax_diag_arrange(s);
+	seq_puts(s, "\n");
+	seq_puts(s, "ChannelEnd");
+	seq_puts(s, "\n");
+
+	/* print Mutual/Slef Maximum and Minimum */
+	himax_get_mutual_edge();
+	himax_get_self_edge();
+	seq_printf(s, "Mutual Max:%3d, Min:%3d\n", g_max_mutual, g_min_mutual);
+	seq_printf(s, "Self Max:%3d, Min:%3d\n", g_max_self, g_min_self);
+	/* recovery status after print*/
+	g_max_mutual = 0;
+	g_min_mutual = 0xFFFF;
+	g_max_self = 0;
+	g_min_self = 0xFFFF;
+
+	/*pring state info*/
+	print_state_info(s);
+
+	if (s->count >= s->size) {
+		h_overflow = true;
+	}
+}
+
+int himax_stack_show(struct seq_file *s, void *v)
+{
+	struct himax_ts_data *ts = private_ts;
+
+	if (ts->diag_cmd != 0U) {
+		himax_diag_print(s, v);
+	} else {
+		seq_puts(s,
+			 "Please set raw out select 'echo diag,X > debug'\n\n");
+	}
+
+	return 0;
+}
+int himax_stack_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_stack_show, NULL);
+}
+const struct proc_ops_name himax_stack_ops = {
+	.proc_op(open) = himax_stack_open,
+	.proc_op(read) = seq_read,
+};
+
+int himax_sram_read(struct seq_file *s, void *v, uint8_t raw_data_sel)
+{
+	struct himax_ts_data *ts = private_ts;
+	uint8_t datatype = 0;
+
+	if (!ts->diag_cmd) {
+		datatype = raw_data_sel;
+	} else {
+		datatype = ts->diag_cmd;
+	}
+
+	if (h_overflow == false) {
+		if (process_type == 0U) {
+			himax_int_enable(0);
+			himax_mcu_diag_register_set(datatype, (uint8_t) IC_MASTER);
+
+			if (!himax_ts_diag_func()) {
+				seq_puts(s, "Get sram data failed.");
+			} else {
+				himax_diag_print(s, v);
+			}
+
+			ts->diag_cmd = 0;
+			himax_mcu_diag_register_set(0, IC_MASTER);
+			himax_int_enable(1);
+		}
+	}
+
+	if (((process_type <= 3U) && (ts->diag_cmd != 0U) && diag_wq_alive)
+		|| h_overflow) {
+		himax_diag_print(s, v);
+		h_overflow = false;
+	}
+
+	return 0;
+}
+
+int himax_delta_show(struct seq_file *s, void *v)
+{
+	return himax_sram_read(s, v, 0x09);
+}
+int himax_delta_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_delta_show, NULL);
+}
+const struct proc_ops_name himax_delta_ops = {
+	.proc_op(open) = himax_delta_open,
+	.proc_op(read) = seq_read,
+};
+
+
+int himax_dc_show(struct seq_file *s, void *v)
+{
+	return himax_sram_read(s, v, 0x0A);
+}
+int himax_dc_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_dc_show, NULL);
+}
+const struct proc_ops_name himax_dc_ops = {
+	.proc_op(open) = himax_dc_open,
+	.proc_op(read) = seq_read,
+};
+
+
+int himax_baseline_show(struct seq_file *s, void *v)
+{
+	return himax_sram_read(s, v, 0x08);
+}
+int himax_baseline_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_baseline_show, NULL);
+}
+const struct proc_ops_name himax_baseline_ops = {
+	.proc_op(open) = himax_baseline_open,
+	.proc_op(read) = seq_read,
+};
+
+
+static void setFlashBuffer(void)
+{
+	g_flash_buffer = kcalloc(g_Flash_Size, sizeof(uint8_t), GFP_KERNEL);
+	if (g_flash_buffer == NULL) {
+		E("%s, Failed to allocate memory\n", __func__);
+		return;
+	}
+}
+
+int himax_flash_dump_show(struct seq_file *s, void *v)
+{
+	ssize_t ret = 0;
+	unsigned int i;
+
+	UNUSED(v);
+
+	if (!g_flash_dump_rst) {
+		seq_puts(s, "Flash Dump - Failed ever\n");
+		return ret;
+	}
+
+	if (g_flash_progress == (uint8_t)Dump_Ongoing) {
+		seq_puts(s, "Flash dump - On-going\n");
+	} else {
+		seq_puts(s, "Flash dump Service - Available\n");
+	}
+
+	/*print flash dump data*/
+	if ((g_flash_cmd == 1U) && (g_flash_progress == (uint8_t)(Dump_Finished))) {
+		seq_puts(s, "Print flash data\n");
+		for (i = 0; i < g_Flash_Size; i++) {
+			seq_printf(s, "0x%02X,", g_flash_buffer[i]);
+			if ((i % 16U) == 15U) {
+				seq_puts(s, "\n");
+			}
+		}
+	}
+
+	return ret;
+}
+
+ssize_t himax_flash_dump_store(struct file *filp,
+				      const char __user *buff, size_t len,
+				      loff_t *data)
+{
+	char buf[80] = { 0 };
+	char token[50] = { 0 };
+	uint32_t tmp_start_addr = 0;
+	uint32_t flash_size_limit = HX256K;
+	unsigned int tmp_size = 0;
+	unsigned int i = 0;
+	unsigned int idx = 0;
+	unsigned long value = 0;
+
+	UNUSED(filp);
+	UNUSED(data);
+
+	if (ic_data->HX_FW_SIZE == FW_SIZE_255k) {
+		flash_size_limit = HX512K;
+	}
+
+	if (len >= 80U) {
+		D("%s: no command exceeds 80 chars.\n", __func__);
+		return -EFAULT;
+	}
+
+	if (copy_from_user(buf, buff, len) != 0) {
+		return -EFAULT;
+	}
+
+	D("%s: buf = %s\n", __func__, buf);
+
+	if (g_flash_progress == (uint8_t)Dump_Ongoing) {
+		E("%s: Flash dump - ONGOING\n", __func__);
+		return len;
+	}
+
+	if ((buf[1] == '_') && (buf[2] == 'F')) {
+		if ((buf[3] == 'U') && (buf[4] == 'L') && (buf[5] == 'L')) {
+			g_page_prog_start = 0;
+			g_Flash_Size = flash_size_limit;
+		}
+	} else if ((buf[1] == '_') && (buf[2] == '2')) {
+		if (buf[3] == '8') {
+			g_page_prog_start = 0;
+			g_Flash_Size = FW_SIZE_128k;
+		}
+	} else {
+		/* do nothing*/
+	}
+	/*1 : print data on console, 2 : dump to sdcard*/
+	if (buf[0] == '1') {
+		g_flash_cmd = 1;
+	} else if (buf[0] == '2') {
+		g_flash_cmd = 2;
+	} else {
+		/* do nothing*/
+	}
+
+	if ((buf[1] == '_') && ((buf[2] == 's') || (buf[2] == 'S'))) {
+		for (i = 3U; i < (len - 1U); i++) {
+			if (buf[i] == ':') {
+				idx = i;
+				D("%s: idx = %d\n", __func__, idx);
+				break;
+			}
+		}
+		if ((idx > 3U) && (idx != (len - 1U))) {
+			for (i = 3U; i < idx; i++) {
+				token[i-3U] = buf[i];
+			}
+			if (!kstrtoul(token, 16, &value)) {
+				tmp_start_addr = (uint32_t) value;
+			} else {
+				E("[FAIL]hex token kstrtoul\n");
+				return len;
+			}
+			(void)memset(token, 0, sizeof(token));
+			idx += 1U;
+			for (i = idx; i < (len - 1U); i++) {
+				token[i-idx] = buf[i];
+			}
+			if (!kstrtoul(token, 10, &value)) {
+				tmp_size = (uint32_t) value;
+			} else {
+				E("[FAIL]decimal token kstrtoul\n");
+				return len;
+			}
+			if ((tmp_start_addr + (tmp_size * HX1K)) > flash_size_limit) {
+				E("%s: dump size(start_addr + dump size) more than flash size\n", __func__);
+				return len;
+			}
+			D("%s: start_addr = 0x%02X, dump_size = %dK\n", __func__, tmp_start_addr, tmp_size);
+			g_Flash_Size = tmp_size * HX1K;
+			g_page_prog_start = tmp_start_addr;
+		}
+	}
+	g_flash_progress = Dump_Ongoing;
+	queue_work(private_ts->flash_wq, &private_ts->flash_work);
+	g_flash_dump_rst = true;
+
+	return len;
+}
+int himax_flash_dump_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_flash_dump_show, NULL);
+}
+
+const struct proc_ops_name himax_flash_dump_ops = {
+	owner_line
+	.proc_op(open) = himax_flash_dump_open,
+	.proc_op(write) = himax_flash_dump_store,
+	.proc_op(read) = seq_read,
+	.proc_opl(lseek) = seq_lseek,
+	.proc_op(release) = single_release,
+};
+
+int himax_debug_show(struct seq_file *m, void *v)
+{
+	ssize_t ret = 0;
+	uint16_t cid = 0;
+#if (HX_FIX_TOUCH_INFO == 0x01)
+	uint8_t data[DATA_LEN_4] = { 0 };
+	bool FW_IS_ID_EN = 0;
+	bool FW_ID_PALM_EN = 0;
+#endif
+
+	UNUSED(v);
+
+	D("%s, Enter\n", __func__);
+
+	if (dbg_cmd_flag != 0U) {
+		if (dbg_func_ptr_r[dbg_cmd_flag] != NULL) {
+			dbg_func_ptr_r[dbg_cmd_flag](m);
+		}
+	}
+
+	if (debug_level_cmd == 't') {
+		if (!fw_update_going) {
+			if (fw_update_complete) {
+				seq_printf(m,
+					"FW Update-Complete\n");
+			} else {
+				seq_printf(m,
+					"FW Update-Fail\n");
+			}
+		} else {
+			seq_printf(m,
+					"FW Update-Ongoing...\n");
+		}
+
+	} else if (debug_level_cmd == 'v') {
+		seq_printf(m,
+				"FW Architecture Version = 0x%2.2X\n",
+				ic_data->vendor_arch_ver);
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+		seq_printf(m,
+				"FW Algorithm Version = A%2.2X\n",
+				ic_data->vendor_display_cfg_ver);
+#else
+		seq_printf(m,
+				"FW Display Config Version = D%2.2X\n",
+				ic_data->vendor_display_cfg_ver);
+#endif
+		seq_printf(m,
+				"FW Touch Config Version   = C%2.2X\n",
+				ic_data->vendor_touch_cfg_ver);
+
+		cid = ((uint16_t) ic_data->vendor_cid_maj_ver << 8U);
+		cid += ic_data->vendor_cid_min_ver;
+		seq_printf(m,
+			"CID = 0x%2.2X\n", cid);
+
+		seq_printf(m, "Panel Version = 0x%2.2X\n",
+			ic_data->vendor_panel_ver);
+
+
+		if (ic_data->vendor_arch_ver >= 0x8098U) {
+			seq_printf(m,
+				"Remark1 = %s\n",
+				ic_data->vendor_remark1);
+			seq_printf(m,
+				"Remark2 = %s\n",
+				ic_data->vendor_remark2);
+			seq_printf(m,
+				"Himax Ticket = %s\n",
+				ic_data->vendor_ticket);
+		}
+
+		seq_printf(m, "Customer = %s\n",
+				ic_data->vendor_cus_info);
+		seq_printf(m, "Project = %s\n",
+				ic_data->vendor_proj_info);
+		seq_printf(m, "FW Config Date = %s\n",
+				ic_data->vendor_config_date);
+		seq_puts(m, "\n");
+		seq_puts(m, "Himax Touch Driver Version:\n");
+		seq_printf(m, "%s\n", HIMAX_DRIVER_VER);
+
+	} else if (debug_level_cmd == 'd') {
+		seq_printf(m,
+				"Himax Touch IC Information :\n");
+		seq_printf(m,
+				"%s\n", private_ts->chip_name);
+
+		seq_printf(m,
+				"IC Checksum : CRC\n");
+
+		if (ic_data->HX_INT_IS_EDGE) {
+			seq_printf(m,
+				"Driver register Interrupt : EDGE TIRGGER\n");
+		} else {
+			seq_printf(m,
+				"Driver register Interrupt : LEVEL TRIGGER\n");
+		}
+
+		if (private_ts->protocol_type == (uint8_t)PROTOCOL_TYPE_A) {
+			seq_printf(m,
+				"Protocol : TYPE_A\n");
+		} else {
+			seq_printf(m,
+				"Protocol : TYPE_B\n");
+		}
+
+		seq_printf(m,
+				"RX Num : %d\n", ic_data->HX_RX_NUM);
+		seq_printf(m,
+				"TX Num : %d\n", ic_data->HX_TX_NUM);
+		seq_printf(m,
+				"X Resolution : %d\n",
+				ic_data->HX_X_RES);
+		seq_printf(m,
+				"Y Resolution : %d\n",
+				ic_data->HX_Y_RES);
+		seq_printf(m,
+				"Max Point : %d\n", ic_data->HX_MAX_PT);
+
+#if (HX_FIX_TOUCH_INFO == 0x00)
+		if (ic_data->HX_IS_ID_EN) {
+			if (ic_data->HX_ID_PALM_EN) {
+				seq_puts(m, "FW INFO Report point: Option 3\n");
+			} else {
+				seq_puts(m, "FW INFO Report point: Option 2\n");
+			}
+		} else {
+			seq_puts(m, "FW INFO Report point: Option 1\n");
+		}
+#else
+		if (ic_data->HX_IS_ID_EN) {
+			if (ic_data->HX_ID_PALM_EN) {
+				seq_puts(m, "FIX INFO Report point: Option 3\n");
+			} else {
+				seq_puts(m, "FIX INFO Report point: Option 2\n");
+			}
+		} else {
+			seq_puts(m, "FIX INFO Report point: Option 1\n");
+		}
+
+		himax_mcu_register_read(addr_fw_HX_ID_EN, DATA_LEN_4, data);
+		FW_IS_ID_EN = ((data[1] & 0x02U) == 0x02U);
+		FW_ID_PALM_EN = ((data[1] & 0x80U) == 0x80U);
+		if (FW_IS_ID_EN) {
+			if (FW_ID_PALM_EN) {
+				seq_puts(m, "FW INFO Report point: Option 3\n");
+			} else {
+				seq_puts(m, "FW INFO Report point: Option 2\n");
+			}
+		} else {
+			seq_puts(m, "FW INFO Report point: Option 1\n");
+		}
+#endif
+	} else {
+		/* do nothing*/
+	}
+
+	return ret;
+}
+
+ssize_t himax_debug_store(struct file *file, const char *buff,
+				 size_t len, loff_t *pos)
+{
+	char fileName[128];
+	char buf[80] = {0};
+	int result = 0;
+	const struct firmware *fw = NULL;
+	char *str_ptr = NULL;
+	unsigned int str_len = 0;
+	unsigned int i = 0;
+
+	UNUSED(file);
+	UNUSED(pos);
+
+	if (len >= 80U) {
+		D("%s: no command exceeds 80 chars.\n", __func__);
+		return -EFAULT;
+	}
+
+	if (copy_from_user(buf, buff, len) != 0) {
+		return -EFAULT;
+	}
+
+	str_len = (unsigned int) len;
+	buf[str_len - 1U] = 0; /*remove \n*/
+
+	while (dbg_cmd_str[i] != NULL) {
+		str_ptr = strnstr(buf, dbg_cmd_str[i], len);
+		if (str_ptr != NULL) {
+			str_len = strlen(dbg_cmd_str[i]);
+			dbg_cmd_flag = i + 1U;
+			debug_level_cmd = 0;
+			D("Cmd is correct :%s, dbg_cmd = %d\n", str_ptr,
+			  dbg_cmd_flag);
+			break;
+		}
+		i++;
+	}
+	if (str_ptr == NULL) {
+		dbg_cmd_flag = 0U;
+	}
+
+	if (buf[str_len] == ',') {
+		dbg_cmd_par = &buf[str_len + 1U];
+		if (dbg_func_ptr_w[dbg_cmd_flag] != NULL) {
+			/* 2 => '/n' + ','*/
+			dbg_func_ptr_w[dbg_cmd_flag](dbg_cmd_par,
+						     len - str_len - 2U);
+		}
+
+		D("string of paremeter is %s, dbg_cmd_par = %s\n",
+		  &buf[str_len + 1U], dbg_cmd_par);
+	}
+
+	if (dbg_cmd_flag != 0U) {
+		return len;
+	}
+
+	if ((buf[0] == 'v') ||
+	    (buf[0] == 'd')) { /* firmware version */ /* ic information */
+		himax_int_enable(0);
+		debug_level_cmd = buf[0];
+		himax_mcu_config_reload_enable();
+		himax_mcu_power_on_init();
+		himax_mcu_read_FW_ver();
+		g_core_fp.fp_touch_information();
+		himax_int_enable(1);
+		return len;
+	} else if (buf[0] == 't') {
+		if ((buf[1] == 's') && (buf[2] == 'd') && (buf[3] == 'b') &&
+		    (buf[4] == 'g')) {
+			if (buf[5] == '1') {
+				D("Open Ts Debug!\n");
+				g_ts_dbg = 1;
+			}
+			if (buf[5] == '0') {
+				D("Close Ts Debug!\n");
+				g_ts_dbg = 0;
+			}
+			goto ENDFUCTION;
+		}
+		himax_int_enable(0);
+		if (private_ts->hx_fail_det > 0) {
+			himax_fail_det_enable(0);
+		}
+		debug_level_cmd = buf[0];
+		fw_update_complete = false;
+		fw_update_going = true;
+		(void)memset(fileName, 0, sizeof(fileName));
+		/* parse the file name */
+		(void)snprintf(fileName, len - 2U, "%s", &buf[2]);
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+		if ((buf[1] == 'c') && (buf[2] == 'f')
+			 && (buf[3] == 'g')) {
+			ic_data->HX8530_upgrade_section |= 0xF0U;
+			(void)memset(fileName, 0, sizeof(fileName));
+			(void)snprintf(fileName, len - 5U, "%s", &buf[5]);
+		} else {
+			ic_data->HX8530_upgrade_section |= 0x0FU;
+		}
+#endif
+		D("%s: upgrade with file(%s) start!\n", __func__, fileName);
+		result = request_firmware(&fw, fileName, private_ts->dev);
+
+		if (result < 0) {
+			D("fail to request_firmware fwpath: %s (ret:%d)\n",
+			  fileName, result);
+		} else {
+			ic_data->FW_update_flag = 0x06U;
+
+			D("%s: FW image last 4 bytes: 0x%02X, 0x%02X, 0x%02X, 0x%02X\n",
+			  __func__, fw->data[fw->size - 4], fw->data[fw->size - 3],
+			  fw->data[fw->size - 2], fw->data[fw->size - 1]);
+			/*	start to upgrade */
+			D("Now FW file size is : %dk\n", ((fw->size) / 1024));
+ 
+			if (!g_core_fp.fp_fts_ctpm_fw_upgrade(
+				fw->data, (unsigned int)fw->size)) {
+				E("%s: TP upgrade error, line: %d\n", __func__,
+					  __LINE__);
+				fw_update_complete = false;
+			} else {
+				D("%s: TP upgrade OK, line: %d\n", __func__,
+				  __LINE__);
+				fw_update_complete = true;
+			}
+
+			release_firmware(fw);
+			goto firmware_upgrade_done;
+		}
+
+	} else if ((buf[0] == 'i') && (buf[1] == '2') && (buf[2] == 'c')) {
+		/* i2c communication */
+		debug_level_cmd = 'i';
+		return len;
+	} else {
+		/* do nothing*/
+	}
+	/* others,do nothing */
+	debug_level_cmd = 0;
+	return len;
+
+firmware_upgrade_done:
+	fw_update_going = false;
+	himax_mcu_config_reload_enable();
+	himax_mcu_power_on_init();
+
+#if (HX_WPBP_ENABLE == 0x01)
+	himax_enable_flash_protected_mode();
+#endif
+	himax_mcu_read_FW_ver();
+	g_core_fp.fp_touch_information();
+#if defined(FW_update_history_record)
+	himax_FW_update_record();
+#endif
+	himax_int_enable(1);
+	if (private_ts->hx_fail_det > 0) {
+		himax_fail_det_enable(1);
+	}
+	/* todo himax_chip->tp_firmware_upgrade_proceed = 0;
+	 * todo himax_chip->suspend_state = 0;
+	 * todo enable_irq(himax_chip->irq);
+	 */
+ENDFUCTION:
+	return len;
+}
+int himax_debug_open(struct inode *inode, struct file *file)
+{
+	UNUSED(inode);
+	return single_open(file, himax_debug_show, NULL);
+}
+
+const struct proc_ops_name himax_debug_ops = {
+	owner_line
+	.proc_op(open) = himax_debug_open,
+	.proc_op(write) = himax_debug_store,
+	.proc_op(read) = seq_read,
+	.proc_opl(lseek) = seq_lseek,
+	.proc_op(release) = single_release,
+};
+
+
+static void himax_ts_flash_func(void)
+{
+	himax_int_enable(0);
+	D("%s: flash_command = %d, g_Flash_Size 0x%X.\n", __func__, g_flash_cmd,
+	  g_Flash_Size);
+
+	if ((g_flash_cmd == 1U) || (g_flash_cmd == 2U)) {
+		g_core_fp.fp_flash_dump_func(g_page_prog_start, g_Flash_Size,
+					     g_flash_buffer);
+	}
+
+	if (g_flash_cmd == 2U) {
+		struct file *fn;
+
+		fn = filp_open(FLASH_DUMP_FILE, O_CREAT | O_WRONLY | O_TRUNC, 0);
+
+		if (!IS_ERR(fn)) {
+			D("%s Create file and write data\n", __func__);
+			fn->f_op->write(fn, g_flash_buffer,
+					g_Flash_Size * sizeof(uint8_t),
+					&fn->f_pos);
+			filp_close(fn, NULL);
+		} else {
+			E("%s Open file failed!\n", __func__);
+			g_flash_dump_rst = false;
+		}
+		D("%s file %s with dump size 0x%X\n", __func__, FLASH_DUMP_FILE,
+		  g_Flash_Size);
+	}
+
+	himax_int_enable(1);
+	g_flash_progress = Dump_Finished;
+}
+
+void himax_ts_flash_work_func(struct work_struct *work)
+{
+	UNUSED(work);
+
+	himax_ts_flash_func();
+}
+
+void himax_ts_diag_work_func(struct work_struct *work)
+{
+	UNUSED(work);
+
+	(void)himax_ts_diag_func();
+}
+
+static void dbg_func_ptr_init(void)
+{
+	/*debug function ptr init*/
+	dbg_func_ptr_r[1] = himax_crc_test_read;
+	dbg_func_ptr_r[2] = himax_proc_FW_debug_read;
+	dbg_func_ptr_r[3] = himax_attn_read;
+	dbg_func_ptr_r[4] = himax_layout_read;
+	dbg_func_ptr_w[4] = himax_layout_write;
+	dbg_func_ptr_w[5] = himax_sense_on_off_write;
+	dbg_func_ptr_r[6] = himax_debug_level_read;
+	dbg_func_ptr_w[6] = himax_debug_level_write;
+	dbg_func_ptr_r[7] = himax_int_en_read;
+	dbg_func_ptr_w[7] = himax_int_en_write;
+	dbg_func_ptr_r[8] = himax_proc_register_read;
+	dbg_func_ptr_w[8] = himax_proc_register_write;
+	dbg_func_ptr_w[9] = himax_reset_write;
+	dbg_func_ptr_w[10] = himax_diag_arrange_write;
+	dbg_func_ptr_w[11] = himax_diag_cmd_write;
+	dbg_func_ptr_w[12] = himax_GMA_cmd_write;
+}
+
+static bool himax_touch_proc_init(void)
+{
+	himax_proc_diag_dir =
+		proc_mkdir(HIMAX_PROC_DIAG_FOLDER, himax_touch_proc_dir);
+
+	if (himax_proc_diag_dir == NULL) {
+		E(" %s: himax_proc_diag_dir file create failed!\n", __func__);
+		return false;
+	}
+
+	himax_proc_vendor_file =
+		proc_create(HIMAX_PROC_VENDOR_FILE, S_IRUGO, himax_touch_proc_dir,
+			    &himax_vendor_ops);
+	if (himax_proc_vendor_file == NULL) {
+		E(" %s: proc vendor file create failed!\n", __func__);
+		goto fail_1;
+	}
+
+	himax_proc_stack_file =
+		proc_create(HIMAX_PROC_STACK_FILE, S_IRUGO, himax_proc_diag_dir,
+			    &himax_stack_ops);
+	if (himax_proc_stack_file == NULL) {
+		E(" %s: proc stack file create failed!\n", __func__);
+		goto fail_2_1;
+	}
+
+	himax_proc_delta_file =
+		proc_create(HIMAX_PROC_DELTA_FILE, S_IRUGO, himax_proc_diag_dir,
+			    &himax_delta_ops);
+	if (himax_proc_delta_file == NULL) {
+		E(" %s: proc delta file create failed!\n", __func__);
+		goto fail_2_2;
+	}
+
+	himax_proc_dc_file =
+		proc_create(HIMAX_PROC_DC_FILE, S_IRUGO, himax_proc_diag_dir,
+			    &himax_dc_ops);
+	if (himax_proc_dc_file == NULL) {
+		E(" %s: proc dc file create failed!\n", __func__);
+		goto fail_2_3;
+	}
+
+	himax_proc_baseline_file =
+		proc_create(HIMAX_PROC_BASELINE_FILE, S_IRUGO, himax_proc_diag_dir,
+			    &himax_baseline_ops);
+	if (himax_proc_baseline_file == NULL) {
+		E(" %s: proc baseline file create failed!\n", __func__);
+		goto fail_2_4;
+	}
+
+	himax_proc_debug_file =
+		proc_create(HIMAX_PROC_DEBUG_FILE, (S_IRUGO | S_IWUSR), himax_touch_proc_dir,
+			    &himax_debug_ops);
+	if (himax_proc_debug_file == NULL) {
+		E(" %s: proc debug file create failed!\n", __func__);
+		goto fail_3;
+	}
+	dbg_func_ptr_init();
+
+	himax_proc_flash_dump_file =
+		proc_create(HIMAX_PROC_FLASH_DUMP_FILE, (S_IRUGO | S_IWUSR),
+			    himax_touch_proc_dir, &himax_flash_dump_ops);
+	if (himax_proc_flash_dump_file == NULL) {
+		E(" %s: proc flash dump file create failed!\n", __func__);
+		goto fail_4;
+	}
+
+	himax_proc_pintest_file =
+		proc_create(HIMAX_PROC_PINTEST_FILE, (S_IRUGO | S_IWUSR), himax_touch_proc_dir,
+			    &himax_pintest_ops);
+	if (himax_proc_pintest_file == NULL) {
+		E(" %s: proc pintest file create failed!\n", __func__);
+		goto fail_5;
+	}
+
+	return true;
+
+fail_5:
+	remove_proc_entry(HIMAX_PROC_FLASH_DUMP_FILE, himax_touch_proc_dir);
+fail_4:
+	remove_proc_entry(HIMAX_PROC_DEBUG_FILE, himax_touch_proc_dir);
+fail_3:
+	remove_proc_entry(HIMAX_PROC_BASELINE_FILE, himax_proc_diag_dir);
+fail_2_4:
+	remove_proc_entry(HIMAX_PROC_DC_FILE, himax_proc_diag_dir);
+fail_2_3:
+	remove_proc_entry(HIMAX_PROC_DELTA_FILE, himax_proc_diag_dir);
+fail_2_2:
+	remove_proc_entry(HIMAX_PROC_STACK_FILE, himax_proc_diag_dir);
+fail_2_1:
+	remove_proc_entry(HIMAX_PROC_VENDOR_FILE, himax_touch_proc_dir);
+fail_1:
+	remove_proc_entry(HIMAX_PROC_DIAG_FOLDER, himax_touch_proc_dir);
+	return false;
+}
+
+static void himax_touch_proc_deinit(void)
+{
+	if (himax_proc_pintest_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_PINTEST_FILE, himax_touch_proc_dir);
+	}
+
+	if (himax_proc_flash_dump_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_FLASH_DUMP_FILE, himax_touch_proc_dir);
+	}
+
+	if (himax_proc_debug_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_DEBUG_FILE, himax_touch_proc_dir);
+	}
+
+	if (himax_proc_baseline_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_BASELINE_FILE, himax_proc_diag_dir);
+	}
+
+	if (himax_proc_dc_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_DC_FILE, himax_proc_diag_dir);
+	}
+
+	if (himax_proc_delta_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_DELTA_FILE, himax_proc_diag_dir);
+	}
+
+	if (himax_proc_stack_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_STACK_FILE, himax_proc_diag_dir);
+	}
+
+	if (himax_proc_vendor_file != NULL) {
+		remove_proc_entry(HIMAX_PROC_VENDOR_FILE, himax_touch_proc_dir);
+	}
+
+	if (himax_proc_diag_dir != NULL) {
+		remove_proc_entry(HIMAX_PROC_DIAG_FOLDER, himax_touch_proc_dir);
+	}
+}
+
+int himax_debug_init(void)
+{
+	struct himax_ts_data *ts = private_ts;
+
+	diag_max_cnt = 0;
+
+	D("%s:Enter\n", __func__);
+
+	if (ts == NULL) {
+		E("%s: ts struct is NULL\n", __func__);
+		return -EPROBE_DEFER;
+	}
+
+	reg_read_data = kzalloc(128U * sizeof(uint8_t), GFP_KERNEL);
+	if (reg_read_data == NULL) {
+		E("%s: reg_read_data allocate failed\n", __func__);
+		goto err_alloc_reg_read_data_fail;
+	}
+
+	debug_data = kzalloc(sizeof(struct himax_debug), GFP_KERNEL);
+	if (debug_data == NULL) { /*Allocate debug data space*/
+		E("%s: debug_data allocate failed\n", __func__);
+		goto err_alloc_debug_data_fail;
+	}
+
+	himax_himax_data_init();
+
+	ts->flash_wq = create_singlethread_workqueue("himax_flash_wq");
+
+	if (ts->flash_wq == NULL) {
+		E("%s: create flash workqueue failed\n", __func__);
+		goto err_create_flash_dump_wq_failed;
+	}
+
+	INIT_WORK(&ts->flash_work, himax_ts_flash_work_func);
+	setFlashBuffer();
+
+	if (g_flash_buffer == NULL) {
+		E("%s: flash buffer allocate fail failed\n", __func__);
+		goto err_flash_buf_alloc_failed;
+	}
+
+	ts->himax_diag_wq = create_singlethread_workqueue("himax_diag");
+
+	if (ts->himax_diag_wq == NULL) {
+		E("%s: create diag workqueue failed\n", __func__);
+		goto err_create_diag_wq_failed;
+	}
+
+	INIT_DELAYED_WORK(&ts->himax_diag_delay_wrok, himax_ts_diag_work_func);
+
+	setSelfBuffer(ic_data->HX_RX_NUM, ic_data->HX_TX_NUM);
+	if (getSelfBuffer() == NULL) {
+		E("%s: self buffer allocate failed\n", __func__);
+		goto err_self_buf_alloc_failed;
+	}
+
+	setSelfNewBuffer(ic_data->HX_RX_NUM, ic_data->HX_TX_NUM);
+	if (getSelfNewBuffer() == NULL) {
+		E("%s: self new buffer allocate failed\n", __func__);
+		goto err_self_new_alloc_failed;
+	}
+
+	setSelfOldBuffer(ic_data->HX_RX_NUM, ic_data->HX_TX_NUM);
+	if (getSelfOldBuffer() == NULL) {
+		E("%s: self old buffer allocate failed\n", __func__);
+		goto err_self_old_alloc_failed;
+	}
+
+	setMutualBuffer(ic_data->HX_RX_NUM, ic_data->HX_TX_NUM);
+	if (getMutualBuffer() == NULL) {
+		E("%s: mutual buffer allocate failed\n", __func__);
+		goto err_mut_buf_alloc_failed;
+	}
+
+	setMutualNewBuffer(ic_data->HX_RX_NUM, ic_data->HX_TX_NUM);
+	if (getMutualNewBuffer() == NULL) {
+		E("%s: mutual new buffer allocate failed\n", __func__);
+		goto err_mut_new_alloc_failed;
+	}
+
+	setMutualOldBuffer(ic_data->HX_RX_NUM, ic_data->HX_TX_NUM);
+	if (getMutualOldBuffer() == NULL) {
+		E("%s: mutual old buffer allocate failed\n", __func__);
+		goto err_mut_old_alloc_failed;
+	}
+
+	if (!himax_touch_proc_init()) {
+		goto err_proc_init_failed;
+	}
+
+	return 0;
+
+err_proc_init_failed:
+	kfree(diag_mutual_old);
+	diag_mutual_old = NULL;
+err_mut_old_alloc_failed:
+	kfree(diag_mutual_new);
+	diag_mutual_new = NULL;
+err_mut_new_alloc_failed:
+	kfree(diag_mutual);
+	diag_mutual = NULL;
+err_mut_buf_alloc_failed:
+	kfree(diag_self_old);
+	diag_self_old = NULL;
+err_self_old_alloc_failed:
+	kfree(diag_self_new);
+	diag_self_new = NULL;
+err_self_new_alloc_failed:
+	kfree(diag_self);
+	diag_self = NULL;
+err_self_buf_alloc_failed:
+	cancel_delayed_work_sync(&ts->himax_diag_delay_wrok);
+	destroy_workqueue(ts->himax_diag_wq);
+err_create_diag_wq_failed:
+
+	kfree(g_flash_buffer);
+	g_flash_buffer = NULL;
+err_flash_buf_alloc_failed:
+	destroy_workqueue(ts->flash_wq);
+err_create_flash_dump_wq_failed:
+	kfree(debug_data);
+	debug_data = NULL;
+err_alloc_debug_data_fail:
+	kfree(reg_read_data);
+	reg_read_data = NULL;
+err_alloc_reg_read_data_fail:
+
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(himax_debug_init);
+
+void himax_debug_remove(void)
+{
+	struct himax_ts_data *ts = private_ts;
+
+	himax_touch_proc_deinit();
+	
+	cancel_delayed_work_sync(&ts->himax_diag_delay_wrok);
+
+	destroy_workqueue(ts->himax_diag_wq);
+	destroy_workqueue(ts->flash_wq);
+
+	if (diag_mutual_old != NULL) {
+		kfree(diag_mutual_old);
+		diag_mutual_old = NULL;
+	}
+
+	if (diag_mutual_new != NULL) {
+		kfree(diag_mutual_new);
+		diag_mutual_new = NULL;
+	}
+
+	if (diag_mutual != NULL) {
+		kfree(diag_mutual);
+		diag_mutual = NULL;
+	}
+
+	if (diag_self_old != NULL) {
+		kfree(diag_self_old);
+		diag_self_old = NULL;
+	}
+
+	if (diag_self_new != NULL) {
+		kfree(diag_self_new);
+		diag_self_new = NULL;
+	}
+
+	if (diag_self != NULL) {
+		kfree(diag_self);
+		diag_self = NULL;
+	}
+
+	if (g_flash_buffer != NULL) {
+		kfree(g_flash_buffer);
+		g_flash_buffer = NULL;
+	}
+	if (debug_data != NULL) {
+		kfree(debug_data);
+		debug_data = NULL;
+	}
+	if (reg_read_data != NULL) {
+		kfree(reg_read_data);
+		reg_read_data = NULL;
+	}
+
+}
+EXPORT_SYMBOL(himax_debug_remove);
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_debug.h linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_debug.h
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_debug.h	2024-06-14 10:43:31.782186054 +0200
@@ -0,0 +1,127 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*  Himax Android Driver Sample Code for debug nodes
+ *
+ *  Copyright (C) 2024 Himax Corporation.
+ *
+ *  This software is licensed under the terms of the GNU General Public
+ *  License version 2,  as published by the Free Software Foundation,  and
+ *  may be copied,  distributed,  and modified under those terms.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef H_HIMAX_DEBUG
+#define H_HIMAX_DEBUG
+
+#include "himax_platform.h"
+#include "himax_common.h"
+
+/*------------------------- define block -------------------------------------*/
+
+/* enum rawdata_process_type */
+#define Tch_mot_flag 0U
+#define Dsram_delivery 1U
+
+/* enum flash_dump_prog */
+#define Dump_Finished 0U
+#define Dump_Ongoing 1U
+
+#define HIMAX_PROC_VENDOR_FILE "vendor"
+#define HIMAX_PROC_DIAG_FOLDER "diag"
+#define HIMAX_PROC_STACK_FILE "stack"
+#define HIMAX_PROC_DELTA_FILE "delta_s"
+#define HIMAX_PROC_DC_FILE "dc_s"
+#define HIMAX_PROC_BASELINE_FILE "baseline_s"
+#define HIMAX_PROC_DEBUG_FILE	"debug"
+#define HIMAX_PROC_FLASH_DUMP_FILE	"flash_dump"
+#define HIMAX_PROC_PINTEST_FILE	"pintest"
+#define CMD_NUM 16
+
+/*------------------------- define block -------------------------------------*/
+/*------------------------- parameter block ----------------------------------*/
+
+extern uint8_t byte_length;
+extern uint8_t register_command[4];
+extern uint8_t cfg_flag;
+extern uint8_t g_hx_state_info[2];
+/*extern uint8_t diag_coor[128];*/
+extern bool	fw_update_complete;
+extern char debug_level_cmd;
+extern uint8_t *g_flash_buffer;
+extern uint8_t g_flash_cmd;
+extern bool g_flash_dump_rst; /*Fail = false, Pass = true*/
+extern char *dbg_cmd_par;
+extern int g_max_mutual;
+extern int g_min_mutual;
+extern int g_max_self;
+extern int g_min_self;
+extern uint8_t reg_cmd[4];
+extern uint8_t g_diag_arr_num;
+extern bool diag_wq_alive;
+extern uint8_t diag_max_cnt;
+extern bool fw_update_going;
+extern uint32_t g_page_prog_start;
+extern uint8_t g_flash_progress;
+extern uint8_t *reg_read_data;
+
+uint8_t byte_length;
+uint8_t cfg_flag;
+int16_t *diag_mutual;
+int16_t *diag_mutual_new;
+int16_t *diag_mutual_old;
+uint8_t g_hx_state_info[2];
+/*uint8_t diag_coor[128];*/
+int16_t *diag_self;
+int16_t *diag_self_new;
+int16_t *diag_self_old;
+bool fw_update_complete;
+char debug_level_cmd;
+unsigned int g_Flash_Size = 0x80000U;
+uint8_t *g_flash_buffer;
+uint8_t g_flash_cmd;
+bool g_flash_dump_rst; /*Fail = false, Pass = true*/
+
+/*------------------------- parameter block ----------------------------------*/
+/*------------------------- structure block ----------------------------------*/
+
+extern struct time_var g_timeStart;
+extern struct time_var g_timeEnd;
+extern struct time_var g_timeDelta;
+
+//extern struct himax_debug *debug_data;
+extern struct proc_dir_entry *himax_proc_diag_dir;
+extern struct proc_dir_entry *himax_proc_vendor_file;
+extern struct proc_dir_entry *himax_proc_stack_file;
+extern struct proc_dir_entry *himax_proc_delta_file;
+extern struct proc_dir_entry *himax_proc_dc_file;
+extern struct proc_dir_entry *himax_proc_baseline_file;
+extern struct proc_dir_entry *himax_proc_debug_file;
+extern struct proc_dir_entry *himax_proc_flash_dump_file;
+extern struct proc_dir_entry *himax_proc_pintest_file;
+
+/*------------------------- structure block ----------------------------------*/
+/*------------------------- function block -----------------------------------*/
+
+extern int himax_int_en_set(void);
+extern int himax_input_register(struct himax_ts_data *ts);
+#if (HX_RST_PIN_FUNC == 0x01)
+extern void himax_ic_reset(uint8_t loadconfig, uint8_t int_off);
+#endif
+
+int16_t *getMutualBuffer(void);
+int16_t *getMutualNewBuffer(void);
+int16_t *getMutualOldBuffer(void);
+int16_t *getSelfBuffer(void);
+int16_t *getSelfNewBuffer(void);
+int16_t *getSelfOldBuffer(void);
+bool himax_ts_diag_func(void);
+int himax_debug_init(void);
+void himax_debug_remove(void);
+
+
+/*------------------------- function block -----------------------------------*/
+
+#endif
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_ic_HX83193.c linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_ic_HX83193.c
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_ic_HX83193.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_ic_HX83193.c	2024-06-14 10:43:31.782186054 +0200
@@ -0,0 +1,413 @@
+// SPDX-License-Identifier: GPL-2.0
+/*  Himax Android Driver Sample Code for HX83193 chipset
+ *
+ *  Copyright (C) 2024 Himax Corporation.
+ *
+ *  This software is licensed under the terms of the GNU General Public
+ *  License version 2,  as published by the Free Software Foundation,  and
+ *  may be copied,  distributed,  and modified under those terms.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#include "himax_platform.h"
+#include "himax_common.h"
+#include "himax_ic_core.h"
+
+bool hx83193_init(void);
+
+static void hx83193_double_safe_mode(void)
+{
+	uint8_t tmp_data[DATA_LEN_4];
+
+	I("%s Enter\n", __func__);
+
+	tmp_data[0] = para_sense_off_0;
+	tmp_data[1] = para_sense_off_1;
+
+	(void)himax_bus_write(addr_sense_on_off_0, tmp_data, 2,
+				HIMAX_I2C_RETRY_TIMES);
+
+	tmp_data[0] = 0x00U;
+	(void)himax_bus_write(addr_sense_on_off_0, tmp_data, 1,
+				  HIMAX_I2C_RETRY_TIMES);
+
+	usleep_range(100, 110);
+
+#if defined(HIMAX_I2C_PLATFORM)
+	himax_mcu_interface_on();
+#endif
+
+	tmp_data[0] = para_sense_off_0;
+	tmp_data[1] = para_sense_off_1;
+
+	(void)himax_bus_write(addr_sense_on_off_0, tmp_data, 2,
+				HIMAX_I2C_RETRY_TIMES);
+
+}
+
+static void hx83193_sense_on(void)
+{
+	uint8_t tmp_data[DATA_LEN_4];
+	uint8_t retry = 0;
+	int ret = 0;
+
+	I("%s Enter\n", __func__);
+
+	do {
+		himax_parse_assign_cmd(data_clear, tmp_data,
+					   sizeof(tmp_data));
+		himax_mcu_register_write(addr_ctrl_fw, DATA_LEN_4,
+					 tmp_data);
+
+		usleep_range(20000, 21000);
+
+		himax_mcu_register_read(addr_ctrl_fw, DATA_LEN_4,
+					tmp_data);
+
+		I("%s:Read status from IC = 0x%02X,0x%02X\n", __func__,
+		  tmp_data[0], tmp_data[1]);
+		if (tmp_data[0] == 0x00U) {
+			break;
+		}
+		retry += 1U;
+	} while (retry < 5U);
+
+	if (tmp_data[0] != 0x00U) {
+		E("%s: Fail:\n", __func__);
+		himax_mcu_tp_reset();
+	} else {
+		/* Initial Setting*/
+		tmp_data[0] = 0x00;
+		tmp_data[1] = 0x00;
+
+		ret = himax_bus_write(addr_sense_on_off_0, tmp_data, 2,
+					  HIMAX_I2C_RETRY_TIMES);
+		if (ret < 0) {
+			E("%s: i2c access fail!\n", __func__);
+		}
+	}
+	usleep_range(20000, 21000);
+
+#if defined(HIMAX_I2C_PLATFORM)
+	himax_mcu_interface_on();
+#endif
+
+}
+
+static void hx83193_sense_off(void)
+{
+	uint8_t cnt = 0;
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	uint8_t cMax = 14;
+	uint8_t check = (uint8_t) 0x87;
+	int ret = 0;
+
+	usleep_range(40000, 41000);
+
+	himax_mcu_register_read(addr_cs_central_state, DATA_LEN_4, tmp_data);
+
+	if (tmp_data[0] == 0x05U) {
+		do {
+			tmp_data[3] = 0x00;
+			tmp_data[2] = 0x00;
+			tmp_data[1] = 0x00;
+			tmp_data[0] = 0xA5;
+			himax_mcu_register_write(addr_ctrl_fw, DATA_LEN_4,
+						 tmp_data);
+
+			usleep_range(20000, 21000);
+			himax_mcu_register_read(addr_ctrl_fw, DATA_LEN_4,
+						tmp_data);
+			cnt += 1U;
+			if (cnt >= cMax) {
+				break;
+			}
+		} while (tmp_data[0] != check);
+		I("%s: 9000005C data[0]=0x%02X, Retry times = %d\n", __func__,
+		  tmp_data[0], cnt);
+	}
+	if (private_ts->slave_ic_num >= 1U) {
+		cnt = 0;
+		do {
+			tmp_data[0] = para_sense_off_0;
+			tmp_data[1] = para_sense_off_1;
+
+			ret = himax_bus_write_slave(IC_SLAVE_1, addr_sense_on_off_0, tmp_data, 2,
+						  HIMAX_I2C_RETRY_TIMES);
+			if (ret < 0) {
+				W("[IC_SLAVE_1] %s: i2c access fail!\n", __func__);
+			}
+			himax_mcu_register_read_slave(IC_SLAVE_1, addr_cs_central_state, DATA_LEN_4, tmp_data);
+			I("[IC_SLAVE_1] %s: Check enter_save_mode data[0]=0x%02X\n", __func__,
+			  tmp_data[0]);
+
+			if (tmp_data[0] == 0x0CU) {
+				break;
+			}
+			cnt += 1U;
+		} while (cnt < 15U);
+	}
+	if (private_ts->slave_ic_num == 2U) {
+		cnt = 0;
+		do {
+			tmp_data[0] = para_sense_off_0;
+			tmp_data[1] = para_sense_off_1;
+
+			ret = himax_bus_write_slave(IC_SLAVE_2, addr_sense_on_off_0, tmp_data, 2,
+						  HIMAX_I2C_RETRY_TIMES);
+			if (ret < 0) {
+				W("[IC_SLAVE_2] %s: i2c access fail!\n", __func__);
+			}
+			himax_mcu_register_read_slave(IC_SLAVE_2, addr_cs_central_state, DATA_LEN_4, tmp_data);
+			I("[IC_SLAVE_2] %s: Check enter_save_mode data[0]=0x%02X\n", __func__,
+			  tmp_data[0]);
+
+			if (tmp_data[0] == 0x0CU) {
+				break;
+			}
+			cnt += 1U;
+		} while (cnt < 15U);
+	}
+	cnt = 0;
+	do {
+		tmp_data[0] = para_sense_off_0;
+		tmp_data[1] = para_sense_off_1;
+
+		(void)himax_bus_write(addr_sense_on_off_0, tmp_data, 2,
+					HIMAX_I2C_RETRY_TIMES);
+
+		himax_mcu_register_read(addr_cs_central_state, DATA_LEN_4,
+					tmp_data);
+		I("%s: Check enter_save_mode data[0]=0x%02X\n", __func__,
+		  tmp_data[0]);
+
+		if (tmp_data[0] == 0x0CU) {
+			break;
+		} else if (cnt == 3U) {
+			usleep_range(10000, 11000);
+			hx83193_double_safe_mode();
+		}  else if (cnt == 6U) {
+			usleep_range(10000, 11000);
+			himax_mcu_tp_reset();
+		} else {
+			/* do nothing*/
+		}
+		cnt += 1U;
+	} while (cnt < 15U);
+
+}
+
+static void hx83193_mcu_flash_dump_func(uint32_t start_addr,
+					unsigned int Flash_Size, uint8_t *flash_buffer)
+{
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	uint32_t page_prog_start = 0;
+	unsigned int i = 0;
+
+	I("%s,start addr = 0x%02X, dump size = 0x%02X\n", __func__, start_addr, Flash_Size);
+
+	hx83193_sense_off();
+
+	/* Disable retry wrapper to avoid I2C CLK low issue */
+	tmp_data[0] = 0xA5;
+	himax_mcu_register_write(addr_retry_wrapper_clr_pw, 4, tmp_data);
+	I("%s: Disable retry wrapper for flash read.\n", __func__);
+
+	page_prog_start = start_addr;
+
+	for (i = 0; i < Flash_Size; i += 256U) {
+		himax_mcu_register_read(page_prog_start, 256,
+					&flash_buffer[i]);
+		page_prog_start += 256U;
+	}
+
+	hx83193_sense_on();
+}
+
+static bool hx83193_mcu_flash_programming(const u8 *FW_content, unsigned int start_addr,
+					  unsigned int length)
+{
+	unsigned int page_prog_start = 0;
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	uint8_t buring_data[FLASH_RW_MAX_LEN]; /* Read for flash data, 128K*/
+	uint8_t Original_speed[DATA_LEN_4] = { 0 };
+	bool ret_data = true;
+	uint16_t index = 0;
+
+	I("%s: programming flash, please wait...\n", __func__);
+	/* ===Get Flash Speed===*/
+	himax_mcu_register_read(addr_spi200_flash_speed, DATA_LEN_4,
+				Original_speed);
+
+	/* ===Set Flash Speed===*/
+	himax_parse_assign_cmd(data_set_flash_speed, tmp_data,
+			       sizeof(tmp_data));
+	himax_mcu_register_write(addr_spi200_flash_speed, DATA_LEN_4, tmp_data);
+
+	himax_mcu_burst_mode_disable();
+
+	/* ===SPI TX-FIFO Reset===*/
+	himax_parse_assign_cmd(data_spi200_txfifo_rst, tmp_data,
+			       sizeof(tmp_data));
+	himax_mcu_register_write(addr_spi200_fifo_rst, DATA_LEN_4, tmp_data);
+
+	/* ===SPI Format===*/
+	himax_parse_assign_cmd(data_spi200_trans_fmt, tmp_data,
+			       sizeof(tmp_data));
+	himax_mcu_register_write(addr_spi200_trans_fmt, DATA_LEN_4, tmp_data);
+
+	for (page_prog_start = start_addr;
+	     page_prog_start < (start_addr + length);
+	     page_prog_start += FLASH_RW_MAX_LEN) {
+		/* ===Flash Write Enable ===*/
+		himax_parse_assign_cmd(data_spi200_trans_ctrl_2, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_trans_ctrl, DATA_LEN_4,
+					 tmp_data);
+
+		himax_parse_assign_cmd(data_spi200_cmd_2, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_cmd, DATA_LEN_4, tmp_data);
+
+		/* ===WEL Write Control ===*/
+		himax_parse_assign_cmd(data_spi200_trans_ctrl_6, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_trans_ctrl, DATA_LEN_4,
+					 tmp_data);
+
+		himax_parse_assign_cmd(data_spi200_cmd_1, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_cmd, DATA_LEN_4, tmp_data);
+
+		himax_mcu_register_read(addr_spi200_data, DATA_LEN_4, tmp_data);
+		/* === Check WEL Fail ===*/
+		if (((tmp_data[0] & 0x02U) >> 1U) == 0U) {
+			I("%s:SPI 0x8000002c = %d, Check WEL Fail\n", __func__, tmp_data[0]);
+			ret_data = false;
+		}
+
+		/*Set 256 Bytes Page Write*/
+		himax_parse_assign_cmd(data_spi200_trans_ctrl_4, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_trans_ctrl, DATA_LEN_4,
+					 tmp_data);
+
+		(void)memset(tmp_data, 0x00, sizeof(tmp_data));
+		tmp_data[3] = (uint8_t)(page_prog_start >> 24U);
+		tmp_data[2] = (uint8_t)(page_prog_start >> 16U);
+		tmp_data[1] = (uint8_t)(page_prog_start >> 8U);
+		tmp_data[0] = (uint8_t)page_prog_start;
+		himax_mcu_register_write(addr_spi200_addr, DATA_LEN_4,
+					 tmp_data);
+
+		(void)memset(buring_data, 0x00, sizeof(buring_data));
+		himax_parse_assign_cmd(addr_spi200_data, buring_data,
+				       ADDR_LEN_4);
+
+		for (index = 0; index < 16U; index++) {
+			buring_data[ADDR_LEN_4 + index] =
+			FW_content[page_prog_start - start_addr + index];
+		}
+		if (himax_bus_write(addr_AHB_address_byte_0, buring_data,
+					(ADDR_LEN_4 + 16U),
+					HIMAX_I2C_RETRY_TIMES) < 0) {
+			E("%s: i2c access fail!\n", __func__);
+			ret_data = false;
+		}
+		/*Write Command: PP*/
+		himax_parse_assign_cmd(data_spi200_cmd_6, tmp_data,
+						sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_cmd, DATA_LEN_4, tmp_data);
+
+		for (index = 0; index < 240U; index++) {
+			buring_data[ADDR_LEN_4 + index] =
+			FW_content[page_prog_start - start_addr + 16U + index];
+		}
+
+		if (himax_bus_write(addr_AHB_address_byte_0, buring_data,
+				    (ADDR_LEN_4 + 240U),
+				    HIMAX_I2C_RETRY_TIMES) < 0) {
+			E("%s: i2c access fail!\n", __func__);
+			ret_data = false;
+		}
+
+		if (!himax_mcu_wait_wip(1)) {
+			E("%s:Flash_Programming Fail\n", __func__);
+			ret_data = false;
+		}
+		if (ret_data == false) {
+			break;
+		}
+	}
+	/* ===Set Flash Speed===*/
+	himax_mcu_register_write(addr_spi200_flash_speed, DATA_LEN_4,
+				 Original_speed);
+	return ret_data;
+}
+
+
+static void hx83193_func_re_init(void)
+{
+	g_core_fp.fp_sense_on = hx83193_sense_on;
+	g_core_fp.fp_sense_off = hx83193_sense_off;
+	g_core_fp.fp_flash_dump_func = hx83193_mcu_flash_dump_func;
+	g_core_fp.fp_flash_programming = hx83193_mcu_flash_programming;
+	g_core_fp.fp_check_CRC = himax_mcu_check_CRC;
+	g_core_fp.fp_calculateChecksum = himax_mcu_calculateChecksum;
+	g_core_fp.fp_touch_information = himax_mcu_touch_information;
+	g_core_fp.fp_get_DSRAM_data = himax_mcu_get_DSRAM_data;
+	g_core_fp.fp_burst_mode_enable = himax_mcu_burst_mode_enable;
+	g_core_fp.fp_fts_ctpm_fw_upgrade = himax_mcu_fts_ctpm_fw_upgrade;
+
+}
+
+static bool hx83193_chip_detect(void)
+{
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	bool ret_data = false;
+	int i = 0;
+
+	hx83193_func_re_init();
+
+	himax_mcu_check_cascade_ic_num();
+
+	hx83193_sense_off();
+
+	for (i = 0; i < 5; i++) {
+		himax_mcu_register_read(addr_icid_addr, DATA_LEN_4, tmp_data);
+		I("%s:Read driver IC ID = HX%X%X%X\n", __func__, tmp_data[3],
+		tmp_data[2], tmp_data[1]);
+
+		if ((tmp_data[3] == 0x83U) && (tmp_data[2] == 0x19U) &&
+			(tmp_data[1] == 0x3AU)) {
+
+			strlcpy(private_ts->chip_name, HX_83193A_PWON, 30);
+			ic_data->HX_FW_SIZE = FW_SIZE_128k;
+			ret_data = true;
+			break;
+		}
+	}
+
+	if (!ret_data) {
+		E("%s:Read driver ID register Fail:\n", __func__);
+		E("Could NOT find Himax Chipset\n");
+		E("Please check 1.VCCD,VCCA,VSP,VSN\n");
+		E("2.LCM_RST,TP_RST\n");
+		E("3.Power On Sequence\n");
+	}
+
+	return ret_data;
+}
+
+bool hx83193_init(void)
+{
+	bool ret = false;
+
+	I("%s\n", __func__);
+	ret = hx83193_chip_detect();
+	return ret;
+}
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_ic_core.h linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_ic_core.h
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_ic_core.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_ic_core.h	2024-06-14 10:43:31.782186054 +0200
@@ -0,0 +1,326 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*	Himax Android Driver Sample Code for ic core functions
+ *
+ *	Copyright (C) 2024 Himax Corporation.
+ *
+ *	This software is licensed under the terms of the GNU General Public
+ *	License version 2,	as published by the Free Software Foundation,  and
+ *	may be copied,	distributed,  and modified under those terms.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	 but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ */
+
+#ifndef HIMAX_IC_CORE_H__
+#define HIMAX_IC_CORE_H__
+
+#include "himax_platform.h"
+#include "himax_common.h"
+#include <linux/slab.h>
+
+/* CORE_INIT */
+
+struct himax_core_fp {
+	void (*fp_sense_on)(void);
+	void (*fp_sense_off)(void);
+	bool (*fp_flash_programming)(const u8 *FW_content, unsigned int start_addr, unsigned int FW_Size);
+	void (*fp_flash_dump_func)(uint32_t start_addr, unsigned int Flash_Size, uint8_t *flash_buffer);
+	uint32_t (*fp_check_CRC)(uint8_t *start_addr, unsigned int reload_length);
+	bool (*fp_calculateChecksum)(uint32_t size);
+	void (*fp_touch_information)(void);
+	bool (*fp_get_DSRAM_data)(uint8_t *tmp_rawdata);
+	void (*fp_burst_mode_enable)(void);
+	bool (*fp_fts_ctpm_fw_upgrade)(const u8 *fw_data, unsigned int bin_size);
+	void (*fp_slave_AHB_reg_broadcast_write)(uint8_t host_id, uint32_t waddr, uint8_t *wdata, uint8_t wlen);
+	void (*fp_slave_AHB_reg_broadcast_read)(uint8_t host_id, uint32_t raddr, uint8_t *rdata, uint8_t rlen);
+
+};
+
+
+/*AHB_Interface_Command_Table*/
+#define addr_AHB_address_byte_0			0x00U
+#define addr_AHB_rdata_byte_0			0x08U
+#define addr_AHB_access_direction		0x0CU
+#define addr_AHB_continous				0x13U
+#define addr_AHB_INC4					0x0DU
+#define addr_sense_on_off_0				0x31U
+#define addr_sense_on_off_1				0x32U
+#define addr_read_event_stack			0x30U
+#define para_AHB_access_direction_read	0x00U
+#define para_AHB_continous				0x31U
+#define para_AHB_INC4					0x10U
+#define para_sense_off_0				0x27U
+#define para_sense_off_1				0x95U
+#define addr_CONV_I2C_cmd				0x80U
+/*AHB_Interface_Command_Table*/
+
+/*bin_desc_map_table*/
+#define	TP_CONFIG_TABLE			0x0000000AU
+#define	FW_CID					0x10000000U
+#define	FW_VER					0x10000100U
+#define	CFG_VER					0x30000000U
+/*bin_desc_map_table*/
+
+#define DATA_LEN_8				8U
+#define DATA_LEN_4				4U
+#define ADDR_LEN_4				4U
+#define FLASH_RW_MAX_LEN		256U
+#define MAX_I2C_TRANS_SZ		128U
+#define HIMAX_TOUCH_DATA_SIZE	128U
+#define FW_PAGE_SZ				128U
+#define HX1K					0x400U
+#define HX4K					0x1000U
+#define HX8K					0x2000U
+#define HX64K					0x10000U
+#define HX247K					0x3DC00U
+#define HX256K					0x40000U
+#define HX512K					0x80000U
+#define FW_SIZE_128k			131072U
+#define FW_SIZE_255k			261120U
+#define HX_RW_REG_FAIL			(-1)
+#define INT16_MAX				(0x7FFFU)
+
+/* CORE_FW */
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+	#define addr_CFG_base						0X03000000U
+	#define addr_rawdata		         		0x13000100U
+#else
+	#define addr_CFG_base						0X00000000U
+	#define addr_rawdata						0x10000000U
+#endif
+	#define addr_fw_state						0x800204DCU
+	#define addr_fw_state2						0x80020048U
+	#define addr_scu_reload_control				0x90000080U
+	#define addr_psl							0x900000A0U
+	#define addr_cs_central_state				0x900000A8U
+	#define addr_flag_reset_event				0x900000E4U
+	#define addr_chk_dd_status					0x900000E8U
+	#define addr_chk_tp_status					0x900000ECU
+	#define addr_osc_en							0x9000009CU
+	#define addr_osc_pw							0x90000280U
+	#define addr_system_reset					0x90000018U
+	#define addr_ctrl_fw						0x9000005CU
+	#define addr_icid_addr						0x900000D0U
+	#define addr_product_id						0x900001D8U
+	#define addr_retry_wrapper_clr_pw			0x900002A0U
+	#define addr_program_reload_from			0x00000000U
+	#define addr_reload_status					0x80050000U
+	#define addr_reload_crc32_result			0x80050018U
+	#define addr_reload_addr_from				0x80050020U
+	#define addr_reload_addr_cmd_beat			0x80050028U
+	#define data_system_reset					0x00000055U
+	#define data_clear							0x00000000U
+	#define addr_FW_baseline_ready				0x800204DCU
+	#define data_fw_define_flash_reload_dis		0x0000a55aU
+	#define data_fw_define_flash_reload_en		0x00000000U
+	#define addr_LTDI_fw_state					(addr_CFG_base + 0x10007410U)
+	#define addr_raw_out_sel					(addr_CFG_base + 0x100072ECU)
+	#define addr_set_frame_addr					(addr_CFG_base + 0x10007294U)
+	#define addr_inspect_mode					(addr_CFG_base + 0x10007454U)
+	#define addr_sorting_mode_en				(addr_CFG_base + 0x10007F04U)
+	#define addr_fw_architecture_version		(addr_CFG_base + 0x10007004U)
+	#define addr_fw_config_date					(addr_CFG_base + 0x10007038U)
+	#define addr_fw_config_version				(addr_CFG_base + 0x10007084U)
+	#define addr_fw_CID							(addr_CFG_base + 0x10007000U)
+	#define addr_fw_customer					(addr_CFG_base + 0x10007008U)
+	#define addr_fw_project_name				(addr_CFG_base + 0x10007014U)
+	#define addr_fw_remark1						(addr_CFG_base + 0x10007020U)
+	#define addr_fw_remark2						(addr_CFG_base + 0x1000702CU)
+	#define addr_fw_ticket						(addr_CFG_base + 0x10007050U)
+	#define addr_fw_HX_ID_EN					(addr_CFG_base + 0x10007134U)
+	#define addr_fw_define_flash_reload			(addr_CFG_base + 0x10007F00U)
+	#define addr_fw_define_rawdata_normalize	(addr_CFG_base + 0x10007130U)
+	#define addr_fw_dbg_msg_addr				(addr_CFG_base + 0x10007F40U)
+	#define addr_chk_fw_reload2					(addr_CFG_base + 0x100072C0U)
+	#define addr_fw_setting_start				(addr_CFG_base + 0x10007084U)
+	#define addr_fw_define_int_is_edge			(addr_CFG_base + 0x10007088U)
+	#define addr_fw_define_chip_rx_tx_num		(addr_CFG_base + 0x100070F4U)
+	#define addr_fw_define_maxpt				(addr_CFG_base + 0x100070F8U)
+	#define addr_fw_define_total_rx_tx_rxic_num	(addr_CFG_base + 0x100071FCU)
+	#define addr_fw_define_total_txic_num		(addr_CFG_base + 0x10007200U)
+	#define addr_fw_define_xy_res				(addr_CFG_base + 0x100070FCU)
+	#define addr_fw_setting_end					(addr_CFG_base + 0x10007204U)
+	#define addr_fail_det_GPIO1_msg				(addr_CFG_base + 0x100074C0U)
+
+/* WP control */
+	#define addr_WP_pin_base					0x90028000U
+	#define addr_WP_gpio0_cmd_04				(addr_WP_pin_base + 0x04U)
+	#define addr_WP_gpio0_cmd_0C				(addr_WP_pin_base + 0x0CU)
+	#define data_WP_gpio0_cmd_00				0x00000000U
+	#define data_WP_gpio0_cmd_01				0x00000001U
+	#define addr_WP_gpio4_cmd_04				(addr_WP_pin_base + 0x04U)
+	#define addr_WP_gpio4_cmd_1C				(addr_WP_pin_base + 0x1CU)
+	#define data_WP_gpio4_cmd_00				0x00000000U
+	#define data_WP_gpio4_cmd_01				0x00000001U
+	#define data_WP_gpio4_cmd_10				0x00000010U
+	#define addr_WP_pin_HX83192D				0x90000230U
+	#define data_WP_disable_HX83192D			0x00000003U
+	#define data_WP_enable_HX83192D				0x00000002U
+	#define addr_WP_pin_HX83193					0x900880B8U
+	#define data_WP_disable_HX83193				0x00000001U
+	#define data_WP_enable_HX83193				0x00000000U
+	#define addr_WP_pin_HX83195					0x90000230U
+	#define data_WP_disable_HX83195				0x00000003U
+	#define data_WP_enable_HX83195				0x00000001U
+	#define addr_WP_pin_HX83180					0x80000014U
+
+/* MPAP test items usage */
+	#define addr_mpap_rst_test					0x900000F0U
+	#define addr_mpap_int_test_base				0x90028060U
+	#define addr_mpap_int_test_cmd_1			(addr_mpap_int_test_base + 0x04U)
+	#define addr_mpap_int_test_cmd_2			(addr_mpap_int_test_base + 0x08U)
+	#define addr_mpap_fail_det_test				0x13007234U
+	#define data_mpap_fail_det_test_L			0xA55A0000U
+	#define data_mpap_fail_det_test_H			0xA55A0001U
+
+/* BP control */
+	#define addr_BP_lock_base					0x80000000U
+	#define addr_BP_lock_cmd_10					(addr_BP_lock_base + 0x10U)
+	#define addr_BP_lock_cmd_20					(addr_BP_lock_base + 0x20U)
+	#define addr_BP_lock_cmd_24					(addr_BP_lock_base + 0x24U)
+	#define addr_BP_lock_cmd_2C					(addr_BP_lock_base + 0x2CU)
+	#define data_BP_lock_cmd_1					0x00020780U
+	#define data_BP_lock_cmd_2					0x47000000U
+	#define data_BP_lock_cmd_3					0x00000006U
+	#define data_BP_lock_cmd_4					0x41000000U
+	#define data_BP_lock_cmd_5					0x00000000U
+	#define data_BP_lock_cmd_6					0x00000001U
+	#define data_BP_lock_cmd_7					0x0000009CU
+	#define data_BP_lock_cmd_8C					0x0000008CU
+	#define data_BP_lock_cmd_9C					0x0000009CU
+	#define data_BP_lock_cmd_BC					0x000000BCU
+	#define data_BP_lock_cmd_FC					0x000000FCU
+	#define data_BP_check_cmd_1					0x42000000U
+	#define data_BP_check_cmd_2					0x00000005U
+	#define data_BP_check_cmd_3					0x42000002U
+	#define data_BP_check_cmd_4					0x0000009FU
+
+/* CORE_FLASH */
+	#define addr_ctrl_base						0x80000000U
+	#define addr_spi200_trans_fmt				(addr_ctrl_base + 0x10U)
+	#define addr_spi200_trans_ctrl				(addr_ctrl_base + 0x20U)
+	#define addr_spi200_cmd						(addr_ctrl_base + 0x24U)
+	#define addr_spi200_addr					(addr_ctrl_base + 0x28U)
+	#define addr_spi200_data					(addr_ctrl_base + 0x2CU)
+	#define addr_spi200_fifo_rst				(addr_ctrl_base + 0x30U)
+	#define addr_spi200_flash_speed				(addr_ctrl_base + 0x40U)
+	#define data_spi200_txfifo_rst				0x00000004U
+	#define data_spi200_trans_fmt				0x00020780U
+	#define data_spi200_trans_ctrl_1			0x42000003U
+	#define data_spi200_trans_ctrl_2			0x47000000U
+	#define data_spi200_trans_ctrl_3			0x67000000U
+	#define data_spi200_trans_ctrl_4			0x610ff000U
+	#define data_spi200_trans_ctrl_6			0x42000000U
+	#define data_spi200_cmd_1					0x00000005U
+	#define data_spi200_cmd_2					0x00000006U
+	#define data_spi200_cmd_4					0x000000D8U
+	#define data_spi200_cmd_6					0x00000002U
+	#define data_set_flash_speed				0x00000201U
+
+#define	Flash_list	{{0xEF, 0x30, 0x12}, {0xEF, 0x60, 0x12}, {0xEF, 0x70, 0x17},\
+					{0xC8, 0x40, 0x12}, {0xC8, 0x40, 0x13}, {0xC8, 0x40, 0x14},\
+					{0xC8, 0x60, 0x13}, {0xC8, 0x60, 0x12}, {0xC2, 0x20, 0x12},\
+					{0xC2, 0x23, 0x12}, {0xC2, 0x23, 0x13}, {0xC2, 0x25, 0x32},\
+					{0xC2, 0x28, 0x11}, {0xC2, 0x28, 0x12}, {0x85, 0x60, 0x13},\
+					{0x85, 0x60, 0x12}, {0x85, 0x40, 0x12}, {0x7F, 0x11, 0x52},\
+					{0x5E, 0x60, 0x13}, {0x1C, 0x38, 0x13}, {0x1C, 0x38, 0x12},\
+					{0x9D, 0x40, 0x12}, {0x9D, 0x40, 0x13}, {0x9D, 0x60, 0x15} }
+
+/*------------------------- define block -------------------------------------*/
+/*------------------------- parameter block ----------------------------------*/
+
+#if (HX_BOOT_UPGRADE == 0x01)
+	extern uint16_t g_i_FW_VER;
+	extern uint16_t g_i_CFG_VER;
+	extern uint8_t g_i_CID_MAJ;
+	extern uint8_t g_i_CID_MIN;
+#endif
+
+extern uint8_t flash_lock_type;
+extern uint32_t dbg_reg_ary[10];
+
+/*------------------------- parameter block ----------------------------------*/
+/*------------------------- structure block ----------------------------------*/
+
+#if (HX_BOOT_UPGRADE == 0x01)
+	extern const struct firmware *hxfw;
+#endif
+
+#if defined(KERNEL_VER_5_10)
+	struct timespec64 time_diff(struct timespec64 start, struct timespec64 end);
+#else
+	struct timespec time_diff(struct timespec start, struct timespec end);
+#endif
+
+/*------------------------- structure block ----------------------------------*/
+/*------------------------- function block -----------------------------------*/
+
+void himax_gpio_set(int pinnum, uint8_t value);
+
+/* CORE_INIT */
+
+void himax_parse_assign_cmd(uint32_t addr, uint8_t *cmd, uint32_t len);
+void himax_disable_flash_protected_mode(void);
+void himax_enable_flash_protected_mode(void);
+int himax_mcu_WP_BP_status(void);
+int himax_mcu_flash_id_check(void);
+void himax_mcu_register_write(uint32_t write_addr, uint32_t write_length, uint8_t *write_data);
+void himax_mcu_register_read(uint32_t read_addr, uint32_t read_length, uint8_t *read_data);
+void himax_mcu_register_write_slave(uint8_t device, uint32_t write_addr, uint32_t write_length, uint8_t *write_data);
+void himax_mcu_register_read_slave(uint8_t device, uint32_t read_addr, uint32_t read_length, uint8_t *read_data);
+bool himax_mcu_tp_lcm_pin_reset(void);
+void himax_mcu_burst_mode_enable(void);
+void himax_mcu_burst_mode_disable(void);
+void himax_mcu_interface_on(void);
+bool himax_mcu_wait_wip(int Timing);
+void himax_mcu_power_on_init(void);
+void himax_mcu_init_psl(void);
+void himax_mcu_write_dd_reg_password(uint8_t ic_device);
+void himax_mcu_clear_dd_reg_password(uint8_t ic_device);
+void himax_mcu_dd_reg_write(uint8_t addr, uint8_t pa_num, uint8_t len, uint8_t *data, uint8_t bank, uint8_t ic_device);
+void himax_mcu_dd_reg_read(uint8_t addr, uint8_t pa_num, uint8_t len, uint8_t *data, uint8_t bank, uint8_t ic_device);
+void himax_mcu_system_reset(void);
+void himax_mcu_command_reset(void);
+uint32_t himax_mcu_calculate_CRC32_by_AP(unsigned char *FW_content, uint32_t len);
+uint32_t himax_mcu_check_CRC(uint8_t *start_addr, unsigned int reload_length);
+void himax_mcu_diag_register_set(uint8_t diag_command, uint8_t chip_id_sel);
+int himax_write_read_reg(uint32_t addr_32, uint8_t *data, uint8_t hb, uint8_t lb);
+void himax_mcu_config_reload_disable(void);
+void himax_mcu_config_reload_enable(void);
+#if !defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83194)
+void himax_mcu_rawdata_normalize_disable(int disable);
+#endif
+void himax_set_BS_UDT_frame(uint8_t checktype);
+void himax_mcu_read_FW_ver(void);
+void himax_print_define_function(void);
+bool himax_mcu_read_event_stack(uint8_t *buf, uint8_t length);
+void himax_mcu_stop_DSRAM_output(void);
+bool himax_mcu_calculateChecksum(uint32_t size);
+void himax_mcu_assign_sorting_mode(uint8_t *tmp_data);
+void himax_mcu_sector_erase(uint32_t start_addr, uint32_t length);
+bool himax_mcu_fts_ctpm_fw_upgrade(const u8 *fw_data, unsigned int bin_size);
+bool himax_mcu_flash_lastdata_check_with_bin(uint32_t size);
+bool hx_mcu_bin_desc_get(unsigned char *fw, uint32_t max_sz);
+bool himax_mcu_get_DSRAM_data(uint8_t *tmp_rawdata);
+int himax_mcu_fw_ver_bin(void);
+void himax_mcu_hw_reset(bool int_off);
+void himax_mcu_toggle_rst_gpio(void);
+void himax_mcu_tp_reset(void);
+void himax_mcu_touch_information(void);
+void himax_mcu_check_cascade_ic_num(void);
+unsigned int himax_mcu_cal_data_len(unsigned int raw_cnt_rmd, uint8_t HX_MAX_PT, unsigned int raw_cnt_max);
+bool himax_mcu_diag_check_sum(struct himax_report_data *hx_touch_data_tmp);
+void himax_mcu_diag_parse_raw_data(struct himax_report_data *hx_touch_data_tmp,
+				   uint16_t mul_num, uint16_t self_num, uint8_t diag_cmd,
+				   int16_t *mutual_data, int16_t *self_data);
+void himax_mcu_read_FW_status(void);
+void himax_mcu_check_sorting_mode(uint8_t *tmp_data);
+void himax_mcu_check_N_frame(uint8_t *tmp_data);
+void himax_mcu_irq_switch(int switch_on);
+void himax_mcu_block_erase(uint32_t start_addr, uint32_t length);
+
+/*------------------------- function block -----------------------------------*/
+
+#endif
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_ic_incell_core.c linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_ic_incell_core.c
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_ic_incell_core.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_ic_incell_core.c	2024-06-14 10:43:31.782186054 +0200
@@ -0,0 +1,2520 @@
+// SPDX-License-Identifier: GPL-2.0
+/*  Himax Android Driver Sample Code for incell ic core functions
+ *
+ *  Copyright (C) 2024 Himax Corporation.
+ *
+ *  This software is licensed under the terms of the GNU General Public
+ *  License version 2,  as published by the Free Software Foundation,  and
+ *  may be copied,  distributed,  and modified under those terms.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#include "himax_ic_core.h"
+#include "himax_common.h"
+#include "himax_self_test.h"
+
+/*------------------------- define block -------------------------------------*/
+/*------------------------- define block -------------------------------------*/
+/*------------------------- parameter block ----------------------------------*/
+
+uint8_t flash_lock_type;
+uint32_t dbg_reg_ary[10] = { addr_LTDI_fw_state, addr_fw_dbg_msg_addr, addr_fw_state, addr_fw_state2, addr_scu_reload_control
+				 ,addr_psl, addr_cs_central_state, addr_flag_reset_event, addr_chk_dd_status, addr_chk_tp_status};
+#if (HX_BOOT_UPGRADE == 0x01)
+static uint32_t FW_VER_MAJ_FLASH_ADDR;
+static uint32_t CFG_VER_MAJ_FLASH_ADDR;
+static uint32_t FW_VER_MIN_FLASH_ADDR;
+static uint32_t CFG_VER_MIN_FLASH_ADDR;
+static uint32_t CID_VER_MAJ_FLASH_ADDR;
+static uint32_t CID_VER_MIN_FLASH_ADDR;
+static uint32_t CFG_TABLE_FLASH_ADDR;
+#endif
+#if defined(PANEL_ID_CHECK)
+#if defined(FW_baseline_status_ready)
+static bool FW_ready;
+#endif
+#endif
+
+/*------------------------- parameter block ----------------------------------*/
+
+
+void himax_mcu_burst_mode_enable(void)
+{
+	uint8_t tmp_data[DATA_LEN_4];
+	uint8_t auto_add_4_byte = 0x01U;
+	int ret;
+
+	tmp_data[0] = ((uint8_t)para_AHB_INC4 | auto_add_4_byte);
+
+	ret = himax_bus_write(addr_AHB_INC4, tmp_data, 1,
+			      HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+		return;
+	}
+}
+
+void himax_mcu_burst_mode_disable(void)
+{
+	uint8_t tmp_data[DATA_LEN_4];
+	int ret;
+
+	tmp_data[0] = (uint8_t)para_AHB_INC4;
+
+	ret = himax_bus_write(addr_AHB_INC4, tmp_data, 1,
+			      HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+		return;
+	}
+}
+
+void himax_mcu_register_read(uint32_t read_addr, uint32_t read_length,
+			    uint8_t *read_data)
+{
+	uint8_t tmp_data[DATA_LEN_4];
+	int ret = 0;
+
+	/*I("%s,Entering\n",__func__);*/
+
+	if (read_length > FLASH_RW_MAX_LEN) {
+		E("%s: read len over %d!\n", __func__, FLASH_RW_MAX_LEN);
+		return;
+	}
+
+	if (read_length > DATA_LEN_4) {
+		g_core_fp.fp_burst_mode_enable();
+	}
+
+	himax_parse_assign_cmd(read_addr, tmp_data, sizeof(tmp_data));
+
+	ret = himax_bus_write(addr_AHB_address_byte_0, tmp_data, DATA_LEN_4,
+			      HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+		return;
+	}
+
+	tmp_data[0] = (uint8_t)para_AHB_access_direction_read;
+
+	ret = himax_bus_write(addr_AHB_access_direction, tmp_data, 1,
+			      HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+		return;
+	}
+
+	ret = himax_bus_read(addr_AHB_rdata_byte_0, read_data, read_length,
+			     HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+		return;
+	}
+
+}
+
+void himax_mcu_register_read_slave(uint8_t device, uint32_t read_addr, uint32_t read_length,
+			    uint8_t *read_data)
+{
+#if (HIMAX_LTDI_CONFIG == 0x00)
+	uint8_t tmp_data[DATA_LEN_4];
+	int ret = 0;
+
+	if (read_length > FLASH_RW_MAX_LEN) {
+		E("%s: read len over %d!\n", __func__, FLASH_RW_MAX_LEN);
+		return;
+	}
+
+	himax_parse_assign_cmd(read_addr, tmp_data, sizeof(tmp_data));
+
+	ret = himax_bus_write_slave(device, addr_AHB_address_byte_0, tmp_data, DATA_LEN_4,
+			      HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+		return;
+	}
+
+	tmp_data[0] = (uint8_t)para_AHB_access_direction_read;
+
+	ret = himax_bus_write_slave(device, addr_AHB_access_direction, tmp_data, 1,
+			      HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+		return;
+	}
+
+	ret = himax_bus_read_slave(device, addr_AHB_rdata_byte_0, read_data, read_length,
+			     HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+		return;
+	}
+#else
+	g_core_fp.fp_slave_AHB_reg_broadcast_read(device,
+		read_addr, read_data, read_length);
+#endif
+}
+
+void himax_mcu_register_write_slave(uint8_t device, uint32_t write_addr, uint32_t write_length,
+			    uint8_t *write_data)
+{
+#if (HIMAX_LTDI_CONFIG == 0x00)
+	uint8_t tmp_addr[DATA_LEN_4];
+	int ret = 0;
+	uint8_t data_byte[FLASH_RW_MAX_LEN] = { 0 };
+
+	himax_parse_assign_cmd(write_addr, tmp_addr, sizeof(tmp_addr));
+
+	if (write_length > FLASH_RW_MAX_LEN) {
+		E("%s: write len over %d!\n", __func__, FLASH_RW_MAX_LEN);
+		return;
+	}
+
+	/* assign addr 4bytes */
+	(void)memcpy(data_byte, tmp_addr, ADDR_LEN_4);
+	/* assign data n bytes */
+	(void)memcpy(&data_byte[ADDR_LEN_4], write_data, write_length);
+
+	ret = himax_bus_write_slave(device, addr_AHB_address_byte_0, data_byte, write_length + ADDR_LEN_4,
+			      HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+	}
+#else
+	g_core_fp.fp_slave_AHB_reg_broadcast_write(device,
+		write_addr, write_data, write_length);
+#endif
+}
+
+static int himax_mcu_flash_write_burst_lenth(uint8_t *reg_byte,
+					     uint8_t *write_data,
+					     uint32_t length)
+{
+	uint8_t data_byte[FLASH_RW_MAX_LEN] = { 0 };
+	int ret = 0;
+
+	/* assign addr 4bytes */
+	(void)memcpy(data_byte, reg_byte, ADDR_LEN_4);
+	/* assign data n bytes */
+	(void)memcpy(&data_byte[ADDR_LEN_4], write_data, length);
+
+	ret = himax_bus_write(addr_AHB_address_byte_0, data_byte,
+			      length + ADDR_LEN_4, HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: xfer fail!\n", __func__);
+		return I2C_FAIL;
+	}
+
+	return NO_ERR;
+}
+
+void himax_mcu_register_write(uint32_t write_addr, uint32_t write_length,
+			     uint8_t *write_data)
+{
+	uint32_t address = 0;
+	uint8_t tmp_addr[4];
+	uint8_t *tmp_data;
+	uint8_t total_write_times = 0;
+	uint32_t max_bus_size = MAX_I2C_TRANS_SZ;
+	uint32_t total_size_temp = 0;
+	uint32_t i = 0;
+	int ret = 0;
+
+	total_size_temp = write_length;
+
+	himax_parse_assign_cmd(write_addr, tmp_addr, sizeof(tmp_addr));
+
+	if ((total_size_temp % max_bus_size) == 0U) {
+		total_write_times = (uint8_t) (total_size_temp / max_bus_size);
+	} else {
+		total_write_times = (uint8_t) (total_size_temp / max_bus_size) + 1U;
+	}
+
+	if (write_length > DATA_LEN_4) {
+		g_core_fp.fp_burst_mode_enable();
+	}
+
+	for (i = 0; i < (total_write_times); i++) {
+
+		if (total_size_temp >= max_bus_size) {
+			tmp_data = &write_data[i * max_bus_size];
+
+			ret = himax_mcu_flash_write_burst_lenth(
+				tmp_addr, tmp_data, max_bus_size);
+			if (ret < 0) {
+				I("%s: i2c access fail!\n", __func__);
+				return;
+			}
+			total_size_temp = total_size_temp - max_bus_size;
+		} else {
+			tmp_data = &write_data[i * max_bus_size];
+			/* I("last total_size_temp=%d\n",
+			 *	total_size_temp % max_bus_size);
+			 */
+			ret = himax_mcu_flash_write_burst_lenth(
+				tmp_addr, tmp_data, total_size_temp);
+			if (ret < 0) {
+				I("%s: i2c access fail!\n", __func__);
+				return;
+			}
+		}
+
+		address = ((i + 1U) * max_bus_size);
+		tmp_addr[0] = (uint8_t)(write_addr & 0xFFU)
+					+ (uint8_t)((address) & 0xFFU);
+		tmp_addr[1] = (uint8_t)((write_addr >> 8U) & 0xFFU)
+					+ (uint8_t)((address >> 8U) & 0xFFU);
+
+		if (tmp_addr[0] < (uint8_t)(write_addr & 0xFFU)) {
+			tmp_addr[1] += 1U;
+		}
+
+		udelay(100);
+	}
+
+}
+
+int himax_write_read_reg(uint32_t addr_32, uint8_t *data, uint8_t hb,
+				uint8_t lb)
+{
+	uint8_t cnt = 0;
+	uint8_t tmp_data[4] = { 0 };
+	uint8_t r_data[ADDR_LEN_4] = { 0 };
+
+	himax_mcu_register_read(addr_32, DATA_LEN_4, tmp_data);
+	tmp_data[1] = data[1];
+	tmp_data[0] = data[0];
+
+	do {
+		himax_mcu_register_write(addr_32, DATA_LEN_4, tmp_data);
+		usleep_range(10000, 11000);
+		himax_mcu_register_read(addr_32, DATA_LEN_4, r_data);
+
+		if ((r_data[1] == hb) && (r_data[0] == lb)) {
+			I("0x%08X : handshaking OK\n", addr_32);
+			return NO_ERR;
+		}
+		cnt += 1U;
+	} while (cnt < 100U);
+
+	E("%s: handshaking fail\n", __func__);
+	E("%s: addr = 0x%08X; data = %02X%02X%02X%02X",
+		__func__, addr_32, tmp_data[3], tmp_data[2], tmp_data[1], tmp_data[0]);
+	E("%s: target = %02X%02X; r_data = %02X%02X\n",
+		__func__, hb, lb, r_data[1], r_data[0]);
+
+	return HX_RW_REG_FAIL;
+}
+
+void himax_mcu_interface_on(void)
+{
+	uint8_t tmp_data[DATA_LEN_4];
+	int ret = 0;
+
+	/* Read a dummy register to wake up I2C.*/
+	ret = himax_bus_read(addr_CONV_I2C_cmd, tmp_data, DATA_LEN_4,
+			     HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) { /* to knock I2C*/
+		E("%s: i2c access fail!\n", __func__);
+		return;
+	}
+}
+
+#define WIP_PRT_LOG "%s: retry:%d, bf[0]=0x%02X, bf[1]=0x%02X,bf[2]=0x%02X, bf[3]=0x%02X\n"
+bool himax_mcu_wait_wip(int Timing)
+{
+	uint8_t tmp_data[DATA_LEN_4];
+	int retry_cnt = 0;
+
+	himax_parse_assign_cmd(data_spi200_trans_fmt, tmp_data,
+			       sizeof(tmp_data));
+	himax_mcu_register_write(addr_spi200_trans_fmt, DATA_LEN_4, tmp_data);
+	tmp_data[0] = 0x01;
+
+	do {
+		himax_parse_assign_cmd(data_spi200_trans_ctrl_1, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_trans_ctrl, DATA_LEN_4,
+					 tmp_data);
+
+		himax_parse_assign_cmd(data_spi200_cmd_1, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_cmd, DATA_LEN_4, tmp_data);
+
+		himax_mcu_register_read(addr_spi200_data, DATA_LEN_4, tmp_data);
+
+		if ((tmp_data[0] & 0x01U) == 0x00U) {
+			return true;
+		}
+
+		retry_cnt++;
+
+		if ((tmp_data[0] != 0x00U) || (tmp_data[1] != 0x00U) ||
+		    (tmp_data[2] != 0x00U) || (tmp_data[3] != 0x00U)) {
+			I(WIP_PRT_LOG, __func__, retry_cnt, tmp_data[0],
+			  tmp_data[1], tmp_data[2], tmp_data[3]);
+		}
+
+		if (retry_cnt > 100) {
+			E("%s: Wait wip error!\n", __func__);
+			return false;
+		}
+
+		msleep(Timing);
+	} while ((tmp_data[0] & 0x01U) == 0x01U);
+
+	return true;
+}
+
+/*power saving level*/
+void himax_mcu_init_psl(void)
+{
+	uint8_t data[DATA_LEN_4] = { 0 };
+
+	himax_parse_assign_cmd(data_clear, data, sizeof(data));
+	himax_mcu_register_write(addr_psl, DATA_LEN_4, data);
+	I("%s: power saving level reset OK!\n", __func__);
+}
+
+void himax_mcu_power_on_init(void)
+{
+	uint8_t data[DATA_LEN_4] = { 0 };
+
+	I("%s:entering\n", __func__);
+	himax_parse_assign_cmd(data_clear, data, sizeof(data));
+	/*RawOut select initial*/
+	himax_mcu_register_write(addr_raw_out_sel, DATA_LEN_4, data);
+	/*DSRAM func initial*/
+	himax_mcu_assign_sorting_mode(data);
+	/* N frame initial :reset N frame back to default value 1 for normal mode
+	 */
+	himax_mcu_register_write(addr_set_frame_addr, DATA_LEN_4, data);
+	/*FW reload done initial*/
+	himax_mcu_register_write(addr_chk_fw_reload2, DATA_LEN_4,
+				 data);
+
+	himax_mcu_tp_reset();
+}
+
+void himax_mcu_dd_reg_write(uint8_t addr, uint8_t pa_num, uint8_t len,
+			    uint8_t *data, uint8_t bank, uint8_t ic_device)
+{
+	/*Calculate total write length*/
+	uint8_t data_len = ((((len + pa_num - 1U) / 4U) - (pa_num / 4U)) + 1U) * 4U;
+	uint8_t w_data[64];
+	uint32_t tmp_addr_32 = 0;
+	uint8_t tmp_addr[4] = { 0 };
+	uint8_t tmp_data[4] = { 0 };
+	bool *chk_data;
+	uint8_t chk_idx = 0;
+	uint32_t i = 0;
+
+	chk_data = kcalloc(data_len, sizeof(bool), GFP_KERNEL);
+	if (chk_data == NULL) {
+		E("%s Allocate chk buf failed\n", __func__);
+		return;
+	}
+
+	(void)memset(w_data, 0, sizeof(w_data));
+
+	/*put input data*/
+	chk_idx = pa_num % 4U;
+	for (i = 0; i < len; i++) {
+		w_data[chk_idx] = data[i];
+		chk_data[chk_idx] = true;
+		chk_idx++;
+	}
+
+	/*get original data*/
+	chk_idx = (pa_num / 4U) * 4U;
+	for (i = 0; i < data_len; i++) {
+		if (!chk_data[i]) {
+			himax_mcu_dd_reg_read(addr, (uint8_t)(chk_idx + i), 1,
+					      tmp_data, bank, ic_device);
+
+			w_data[i] = tmp_data[0];
+			chk_data[i] = true;
+		}
+		D("%s w_data[%d] = %2X\n", __func__, i, w_data[i]);
+	}
+
+	tmp_addr[3] = 0x30;
+	tmp_addr[2] = addr >> 4;
+	tmp_addr[1] = (addr << 4) | bank;
+	tmp_addr[0] = chk_idx;
+	kfree(chk_data);
+	chk_data = NULL;
+
+	tmp_addr_32 = ((uint32_t)tmp_addr[3] << 24);
+	tmp_addr_32 += ((uint32_t)tmp_addr[2] << 16);
+	tmp_addr_32 += ((uint32_t)tmp_addr[1] << 8);
+	tmp_addr_32 += (uint32_t)tmp_addr[0];
+	D("%s Addr = 0x%08X.\n", __func__, tmp_addr_32);
+
+	if (ic_device != (uint8_t)IC_MASTER) {
+		himax_mcu_register_write_slave(ic_device, tmp_addr_32, data_len, w_data);
+	} else {
+		himax_mcu_register_write(tmp_addr_32, data_len, w_data);
+	}
+}
+
+void himax_mcu_dd_reg_read(uint8_t addr, uint8_t pa_num, uint8_t len, uint8_t *data,
+			   uint8_t bank, uint8_t ic_device)
+{
+	uint32_t tmp_addr_32 = 0;
+	uint8_t tmp_addr[4] = { 0 };
+	uint8_t tmp_data[4] = { 0 };
+	uint8_t i = 0;
+
+	if (len > 16U) {
+		I("%s length = %d is over limitation\n", __func__, len);
+		return;
+	}
+	if (ic_device == (uint8_t)IC_MASTER) {
+		for (i = 0; i < len; i++) {
+			tmp_addr[3] = 0x30;
+			tmp_addr[2] = addr >> 4;
+			tmp_addr[1] = (addr << 4) | bank;
+			tmp_addr[0] = pa_num + i;
+
+			tmp_addr_32 = ((uint32_t)tmp_addr[3] << 24);
+			tmp_addr_32 += ((uint32_t)tmp_addr[2] << 16);
+			tmp_addr_32 += ((uint32_t)tmp_addr[1] << 8);
+			tmp_addr_32 += (uint32_t)tmp_addr[0];
+			himax_mcu_register_read(tmp_addr_32, DATA_LEN_4, tmp_data);
+
+			data[i] = tmp_data[(i % 4U)];
+
+			D("%s Addr = 0x%08X .data = %2X\n", __func__,
+			  tmp_addr_32, data[i]);
+		}
+	} else {
+		for (i = 0; i < len; i++) {
+			tmp_addr[3] = 0x30;
+			tmp_addr[2] = addr >> 4;
+			tmp_addr[1] = (addr << 4) | bank;
+			tmp_addr[0] = pa_num + i;
+
+			tmp_addr_32 = ((uint32_t)tmp_addr[3] << 24);
+			tmp_addr_32 += ((uint32_t)tmp_addr[2] << 16);
+			tmp_addr_32 += ((uint32_t)tmp_addr[1] << 8);
+			tmp_addr_32 += (uint32_t)tmp_addr[0];
+			himax_mcu_register_read_slave(ic_device, tmp_addr_32, DATA_LEN_4, tmp_data);
+
+			data[i] = tmp_data[(i % 4U)];
+
+			D("%s Addr = 0x%08X .data = %2X\n", __func__,
+				tmp_addr_32, data[i]);
+		}
+	}
+}
+
+/* CORE_FW */
+/* FW side start*/
+static void diag_mcu_parse_raw_data(struct himax_report_data *hx_touch_data_tmp,
+				    uint32_t mul_num, uint32_t self_num, uint8_t diag_cmd,
+				    int16_t *mutual_data, int16_t *self_data)
+{
+	uint32_t RawDataLen_word;
+	uint32_t index = 0;
+	uint32_t temp1 = 0;
+	uint32_t temp2 = 0;
+	uint32_t i = 0;
+	uint16_t mutual_temp = 0;
+	uint16_t self_temp = 0;
+
+	if ((hx_touch_data_tmp->hx_rawdata_buf[0] == 0x3AU) &&
+	    (hx_touch_data_tmp->hx_rawdata_buf[1] == 0xA3U) &&
+	    (hx_touch_data_tmp->hx_rawdata_buf[2] > 0U) &&
+	    (hx_touch_data_tmp->hx_rawdata_buf[3] == diag_cmd)) {
+		RawDataLen_word = hx_touch_data_tmp->rawdata_size / 2U;
+		index = ((uint32_t)hx_touch_data_tmp->hx_rawdata_buf[2] - 1U) *
+			RawDataLen_word;
+
+		/*
+		 * I("RawDataLen=%d , RawDataLen_word=%d ,
+		 *	hx_touch_info_size=%d\n",
+		 *	RawDataLen, RawDataLen_word, hx_touch_info_size);
+		 */
+		for (i = 0; i < RawDataLen_word; i++) {
+			temp1 = index + i;
+
+			if (temp1 < mul_num) { /*mutual*/
+				mutual_temp = ((uint16_t) hx_touch_data_tmp->hx_rawdata_buf[(i * 2U) + 4U + 1U]) * 256U;
+				mutual_temp += (uint16_t) hx_touch_data_tmp->hx_rawdata_buf[(i * 2U) + 4U];
+				mutual_data[index + i] = (int16_t) mutual_temp;
+			} else { /*self*/
+				temp1 = i + index;
+				temp2 = self_num + mul_num;
+
+				if (temp1 >= temp2) {
+					break;
+				}
+				self_temp = ((uint16_t) hx_touch_data_tmp->hx_rawdata_buf[(i * 2U) + 4U + 1U]) * 256U;
+				self_temp += (uint16_t) hx_touch_data_tmp->hx_rawdata_buf[(i * 2U) + 4U];
+				self_data[i + index - mul_num] = (int16_t) self_temp;
+			}
+		}
+	}
+}
+
+/*-------------------------------------------------------------------------
+ *
+ *	Description:  Do software reset by setting addr 0x90000018 register with
+ *value 0x55. Parameters: void
+ *
+ *	Returns: void
+ *
+ */
+void himax_mcu_system_reset(void)
+{
+	uint8_t data[DATA_LEN_4] = { 0 };
+
+	I("%s: Entering!\n", __func__);
+
+	himax_parse_assign_cmd(data_system_reset, data, sizeof(data));
+	himax_mcu_register_write(addr_system_reset, DATA_LEN_4, data);
+
+	msleep(100);
+
+#if defined(HIMAX_I2C_PLATFORM)
+	himax_mcu_interface_on();
+#endif
+}
+
+void himax_mcu_command_reset(void)
+{
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	int ret = 0;
+
+	I("%s: Entering!\n", __func__);
+
+	/* reset code*/
+	tmp_data[0] = 0x00;
+	tmp_data[1] = 0x00;
+
+	ret = himax_bus_write(addr_sense_on_off_0, tmp_data, 1,
+			      HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+	}
+
+	ret = himax_bus_write(addr_sense_on_off_1, tmp_data, 1,
+			      HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+	}
+
+	msleep(20);
+
+#if defined(HIMAX_I2C_PLATFORM)
+	himax_mcu_interface_on();
+#endif
+}
+
+uint32_t himax_mcu_calculate_CRC32_by_AP(unsigned char *FW_content, uint32_t len)
+{
+	uint32_t i = 0;
+	uint32_t j = 0;
+	uint32_t length = 0;
+	uint32_t fw_data;
+	uint32_t fw_data_2;
+	uint32_t CRC = 0xFFFFFFFFU;
+	uint32_t PolyNomial = 0x82F63B78U;
+
+	length = len / 4U;
+
+	for (i = 0; i < length; i++) {
+		fw_data = FW_content[i * 4U];
+
+		for (j = 1U; j < 4U; j++) {
+			fw_data_2 = FW_content[(i * 4U) + j];
+			fw_data += (fw_data_2) << (8U * j);
+		}
+		CRC = fw_data ^ CRC;
+		for (j = 0; j < 32U; j++) {
+			if ((CRC % 2U) != 0U) {
+				CRC = ((CRC >> 1U) & 0x7FFFFFFFU) ^ PolyNomial;
+			} else {
+				CRC = (((CRC >> 1U) & 0x7FFFFFFFU));
+			}
+		}
+	}
+
+	return CRC;
+}
+
+uint32_t himax_mcu_check_CRC(uint8_t *start_addr, unsigned int reload_length)
+{
+	uint32_t result = 0;
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	uint8_t i_counter = 0;
+	unsigned int length = reload_length / DATA_LEN_4;
+
+	I("%s Enter\n", __func__);
+
+	tmp_data[0] = 0xA5;
+
+	/* Disable retry wrapper to avoid I2C CLK low issue */
+	himax_mcu_register_write(addr_retry_wrapper_clr_pw, 4, tmp_data);
+
+	himax_mcu_register_write(addr_reload_addr_from, DATA_LEN_4,
+					start_addr);
+
+	tmp_data[3] = 0x00;
+	tmp_data[2] = 0x99;
+	tmp_data[1] = (uint8_t)((length >> 8U) & 0xFFU);
+	tmp_data[0] = (uint8_t)(length & 0xFFU);
+
+	himax_mcu_register_write(addr_reload_addr_cmd_beat, DATA_LEN_4,
+					tmp_data);
+
+	himax_mcu_register_read(addr_reload_status, DATA_LEN_4,
+						tmp_data);
+
+	if (tmp_data[1] != 0x99U) {
+		E("%s: Reload status cmd fail and out of retry count!\n", __func__);
+		return HW_CRC_FAIL;
+	}
+	I("%s:8005_0000 read data[1]=0x%02X,data[0]=0x%02X\n",
+		__func__, tmp_data[1], tmp_data[0]);
+
+	i_counter = 0;
+
+	do {
+
+		himax_mcu_register_read(addr_reload_status, DATA_LEN_4,
+							tmp_data);
+
+		if ((tmp_data[0] & 0x01U) != 0x01U) {
+			himax_mcu_register_read(addr_reload_crc32_result,
+						      DATA_LEN_4, tmp_data);
+			result = ((uint32_t)tmp_data[3] << 24);
+			result += ((uint32_t)tmp_data[2] << 16);
+			result += ((uint32_t)tmp_data[1] << 8);
+			result += (uint32_t)tmp_data[0];
+			I("%s:Check CRC result=0x%08X\n",  __func__, result);
+			goto END;
+		} else {
+			usleep_range(1000, 1100);
+			if (i_counter >= 100U) {
+				I("%s:CRC Wait loop timeout\n", __func__);
+				himax_mcu_read_FW_status();
+				return HW_CRC_FAIL;
+			}
+		}
+		i_counter += 1U;
+	} while (i_counter < 100U);
+END:
+	return result;
+}
+
+#define PRT_DATA "%s:[3]=0x%02X, [2]=0x%02X, [1]=0x%02X, [0]=0x%02X\n"
+void himax_mcu_diag_register_set(uint8_t diag_command, uint8_t chip_id_sel)
+{
+	uint8_t tmp_data[DATA_LEN_4];
+	uint8_t back_data[DATA_LEN_4];
+	uint8_t cnt = 50;
+
+	I("diag_command = %d, chip_id_sel = 0x%02X\n", diag_command, chip_id_sel);
+	tmp_data[3] = 0x00;
+	tmp_data[2] = chip_id_sel;
+	tmp_data[1] = 0x00;
+	tmp_data[0] = diag_command;
+
+	do {
+		himax_mcu_register_write(addr_raw_out_sel, DATA_LEN_4,
+					 tmp_data);
+		himax_mcu_register_read(addr_raw_out_sel, DATA_LEN_4,
+					back_data);
+		I(PRT_DATA, __func__, back_data[3], back_data[2], back_data[1],
+		  back_data[0]);
+		cnt--;
+	} while ((tmp_data[0] != back_data[0]) && (cnt > 0U));
+}
+
+void himax_mcu_config_reload_disable(void)
+{
+	uint8_t data[DATA_LEN_4] = { 0 };
+
+	/*reload disable*/
+	himax_parse_assign_cmd(data_fw_define_flash_reload_dis, data,
+		sizeof(data));
+	himax_mcu_register_write(addr_fw_define_flash_reload,
+		DATA_LEN_4, data);
+
+	I("%s: setting OK!\n", __func__);
+}
+
+void himax_mcu_config_reload_enable(void)
+{
+	uint8_t data[DATA_LEN_4] = { 0 };
+
+	/*clear config reload done*/
+	himax_parse_assign_cmd(data_clear, data,
+		sizeof(data));
+	himax_mcu_register_write(addr_chk_fw_reload2,
+		DATA_LEN_4, data);
+
+	/*reload enable*/
+	himax_parse_assign_cmd(data_fw_define_flash_reload_en, data,
+		sizeof(data));
+	himax_mcu_register_write(addr_fw_define_flash_reload,
+		DATA_LEN_4, data);
+
+	I("%s: setting OK!\n", __func__);
+}
+#if !defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83194)
+void himax_mcu_rawdata_normalize_disable(int disable)
+{
+	uint8_t data[DATA_LEN_4] = { 0 };
+
+	I("%s:entering\n", __func__);
+	himax_mcu_register_read(addr_fw_define_rawdata_normalize, DATA_LEN_4,
+				data);
+
+	if (disable != 0) {/*normalize disable*/
+		data[3] &= 0x7FU;
+	} else {/*normalize enable*/
+		data[3] |= 0x80U;
+	}
+
+	himax_mcu_register_write(addr_fw_define_rawdata_normalize, DATA_LEN_4,
+				 data);
+}
+#endif
+void himax_set_BS_UDT_frame(uint8_t checktype)
+{
+	uint8_t tmp_data[4];
+
+	/*skip frame 0x100070F4*/
+	himax_mcu_register_read(addr_skip_frame, DATA_LEN_4, tmp_data);
+
+	switch (checktype) {
+	case (uint8_t)HX_RAWDATA:
+	case (uint8_t)HX_BPN_RAWDATA:
+	case (uint8_t)HX_SBP_RAWDATA:
+	case (uint8_t)HX_SC:
+		tmp_data[0] = BS_RAWDATA;
+		break;
+	case (uint8_t)HX_WT_NOISE:
+	case (uint8_t)HX_NOISE:
+		tmp_data[0] = BS_NOISE;
+		break;
+	default:
+		tmp_data[0] = BS_OPENSHORT;
+		break;
+	}
+	if (checktype == HX_INSPECT_MODE) {
+		tmp_data[0] = BS_INSPECT_MODE;
+	}
+
+	himax_mcu_register_write(addr_skip_frame, 4, tmp_data);
+}
+
+void himax_mcu_read_FW_ver(void)
+{
+	uint8_t data[12] = { 0 };
+	uint8_t pswd[DATA_LEN_4] = { 0 };
+	uint8_t retry = 0;
+	uint8_t reload_status = 0;
+
+	while (reload_status == 0U) {
+		himax_mcu_register_read(addr_chk_fw_reload2,
+					DATA_LEN_4, data);
+		pswd[1] = (uint8_t)((addr_chk_fw_reload2 & 0xFF00U) >> 8U);
+		pswd[0] = (uint8_t)(addr_chk_fw_reload2 & 0xFFU);
+		if ((data[1] == pswd[1]) && (data[0] == pswd[0])) {
+			I("%s: FW finish reload done %d times\n", __func__,
+			  retry);
+			reload_status = 1;
+			break;
+		} else {
+			retry++;
+			usleep_range(10000, 11000);
+		}
+		if (retry == 100U) {
+			E("%s: FW fail reload done !!!!!\n", __func__);
+			himax_mcu_read_FW_status();
+			ic_data->vendor_panel_ver = 0;
+			ic_data->vendor_arch_ver = 0;
+			ic_data->vendor_config_ver = 0;
+			ic_data->vendor_touch_cfg_ver = 0;
+			ic_data->vendor_display_cfg_ver = 0;
+			ic_data->vendor_cid_maj_ver = 0;
+			ic_data->vendor_cid_min_ver = 0;
+			goto END;
+		}
+	}
+	/*I("%s:pswd[0]=0x%2.2X,pswd[1]=0x%2.2X\n", __func__, pswd[0],
+	 * pswd[1]);
+	 */
+	/*
+	 * Read FW version
+	 */
+	himax_mcu_register_read(addr_fw_architecture_version, DATA_LEN_4, data);
+	ic_data->vendor_panel_ver = data[0];
+	ic_data->vendor_arch_ver = ((uint16_t)data[1] << 8);
+	ic_data->vendor_arch_ver += (uint16_t)data[2];
+
+	himax_mcu_register_read(addr_fw_config_version, DATA_LEN_4, data);
+	ic_data->vendor_config_ver = ((uint16_t)data[2] << 8);
+	ic_data->vendor_config_ver += (uint16_t)data[3];
+	ic_data->vendor_touch_cfg_ver = data[2];
+	ic_data->vendor_display_cfg_ver = data[3];
+
+	himax_mcu_register_read(addr_fw_CID, DATA_LEN_4, data);
+	ic_data->vendor_cid_maj_ver = data[2];
+	ic_data->vendor_cid_min_ver = data[3];
+
+	himax_mcu_register_read(addr_fw_customer, 12, data);
+	(void)memcpy(ic_data->vendor_cus_info, data, 12);
+
+	himax_mcu_register_read(addr_fw_project_name, 12, data);
+	(void)memcpy(ic_data->vendor_proj_info, data, 12);
+
+	himax_mcu_register_read(addr_fw_config_date, 12, data);
+	(void)memcpy(ic_data->vendor_config_date, data, 12);
+
+	if (ic_data->vendor_arch_ver >= 0x8098U) {
+		himax_mcu_register_read(addr_fw_remark1, 12, data);
+		(void)memcpy(ic_data->vendor_remark1, data, 12);
+
+		himax_mcu_register_read(addr_fw_remark2, 12, data);
+		(void)memcpy(ic_data->vendor_remark2, data, 12);
+
+		himax_mcu_register_read(addr_fw_ticket, 12, data);
+		(void)memcpy(ic_data->vendor_ticket, data, 12);
+	}
+
+	I("FW Architecture Version : %04X\n", ic_data->vendor_arch_ver);
+	I("CID : %04X\n",
+	  ((ic_data->vendor_cid_maj_ver << 8U) | ic_data->vendor_cid_min_ver));
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+	I("FW Algorithm Config  : A%02X\n", ic_data->vendor_display_cfg_ver);
+#else
+	I("FW Display Config Version : D%02X\n", ic_data->vendor_display_cfg_ver);
+#endif
+	I("FW Touch Config Version : C%02X\n", ic_data->vendor_touch_cfg_ver);
+	I("Panel Version : 0x%02X\n", ic_data->vendor_panel_ver);
+
+	if (ic_data->vendor_arch_ver >= 0x8098U) {
+		I("Remark 1 : %s\n", ic_data->vendor_remark1);
+		I("Remark 2 : %s\n", ic_data->vendor_remark2);
+		I("Himax Ticket : %s\n", ic_data->vendor_ticket);
+	}
+
+	I("FW Config Date = %s\n", ic_data->vendor_config_date);
+	I("Project = %s\n", ic_data->vendor_proj_info);
+	I("Customer = %s\n", ic_data->vendor_cus_info);
+END:
+	return;
+}
+
+void himax_print_define_function(void)
+{
+
+	I("HX_BOOT_UPGRADE : %d\n", HX_BOOT_UPGRADE);
+	I("HX_EXCP_RECOVERY : %d\n", HX_EXCP_RECOVERY);
+	I("HX_PROTOCOL_A : %d\n", HX_PROTOCOL_A);
+	I("HX_PROTOCOL_B_3PA : %d\n", HX_PROTOCOL_B_3PA);
+	I("HX_RST_PIN_FUNC : %d\n", HX_RST_PIN_FUNC);
+	I("HX_TP_INSPECT_MODE : %d\n", HX_TP_INSPECT_MODE);
+	I("HX_FIX_TOUCH_INFO : %d\n", HX_FIX_TOUCH_INFO);
+	I("HX_WPBP_ENABLE : %d\n", HX_WPBP_ENABLE);
+	I("HX_SMART_WAKEUP : %d\n", HX_SMART_WAKEUP);
+	I("HX_GESTURE_TRACK : %d\n", HX_GESTURE_TRACK);
+#if (HX_TP_GTS_MODE == 0x01)
+	I("GTS_range : %d\n", private_ts->GTS_range);
+#endif
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83195)
+	I("PANEL_SELECT : %d\n", PANEL_SELECT);
+#endif
+	I("HIMAX_LTDI_CONFIG : %d\n", HIMAX_LTDI_CONFIG);
+	I("Himax Touch Driver Version = %s\n", HIMAX_DRIVER_VER);
+
+
+}
+
+bool himax_mcu_read_event_stack(uint8_t *buf, uint8_t length)
+{
+	int len = (int)length;
+	int ret = 0;
+	int i2c_speed = 0;
+	struct time_var timeStart;
+	struct time_var timeEnd;
+	struct time_var timeDelta;
+
+	if ((private_ts->debug_log_level & BIT(2)) != 0U) {
+		time_func(&timeStart);
+	}
+
+	ret = himax_bus_read(addr_read_event_stack, buf, length,
+		       HIMAX_I2C_RETRY_TIMES);
+	if (ret < 0) {
+		E("%s: i2c access fail!\n", __func__);
+		return false;
+	}
+
+	if ((private_ts->debug_log_level & BIT(2)) != 0U) {
+		time_func(&timeEnd);
+		timeDelta = time_diff(timeStart, timeEnd);
+
+		i2c_speed =
+			(len * 9 * 1000000 / (int)timeDelta.tv_nsec) * 13 / 10;
+		private_ts->bus_speed = i2c_speed;
+	}
+
+	return true;
+}
+
+void himax_mcu_stop_DSRAM_output(void)
+{
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+
+	if (himax_write_read_reg(addr_rawdata, tmp_data, 0x00, 0x00) < 0) {
+		I("%s Data NOT ready => bypass\n", __func__);
+	}
+
+	I("%s: End of setting!\n", __func__);
+}
+
+bool himax_mcu_calculateChecksum(uint32_t size)
+{
+	uint32_t CRC_result = 0;
+	uint8_t tmp_addr[DATA_LEN_4] = { 0 };
+
+	I("%s:Now size= %dk\n", __func__, (size / HX1K));
+	himax_parse_assign_cmd(addr_program_reload_from, tmp_addr,
+			       sizeof(tmp_addr));
+
+
+	CRC_result = g_core_fp.fp_check_CRC(tmp_addr, size);
+	msleep(50);
+
+	if (CRC_result != 0U) {
+		I("%s: CRC Fail=%d\n", __func__, CRC_result);
+	}
+
+	return (CRC_result == 0U) ? true : false;
+}
+
+void himax_mcu_read_FW_status(void)
+{
+	uint8_t len = 0;
+	uint8_t i = 0;
+	uint8_t data[DATA_LEN_4] = { 0 };
+
+	len = (uint8_t)(sizeof(dbg_reg_ary) / sizeof(uint32_t));
+
+	for (i = 0; i < len; i++) {
+		himax_mcu_register_read(dbg_reg_ary[i], DATA_LEN_4, data);
+
+		I("reg[0-3] : 0x%08X = 0x%02X, 0x%02X, 0x%02X, 0x%02X\n",
+		  dbg_reg_ary[i], data[0], data[1], data[2], data[3]);
+	}
+}
+
+void himax_mcu_irq_switch(int switch_on)
+{
+	if (switch_on != 0) {
+		if (private_ts->use_irq) {
+			himax_int_enable(switch_on);
+		} else {
+			hrtimer_start(&private_ts->timer, ktime_set(1, 0),
+				      HRTIMER_MODE_REL);
+		}
+	} else {
+		if (private_ts->use_irq) {
+			himax_int_enable(switch_on);
+		} else {
+			hrtimer_cancel(&private_ts->timer);
+			cancel_work_sync(&private_ts->work);
+		}
+	}
+}
+
+void himax_mcu_assign_sorting_mode(uint8_t *tmp_data)
+{
+	I("%s:data[1]=0x%02X,data[0]=0x%02X\n", __func__, tmp_data[1],
+	  tmp_data[0]);
+	himax_mcu_register_write(addr_sorting_mode_en, DATA_LEN_4, tmp_data);
+}
+
+void himax_mcu_check_sorting_mode(uint8_t *tmp_data)
+{
+	himax_mcu_register_read(addr_sorting_mode_en, DATA_LEN_4, tmp_data);
+	I("%s: tmp_data[0]=0x%02X,tmp_data[1]=0x%02X\n", __func__, tmp_data[0],
+	  tmp_data[1]);
+}
+
+void himax_mcu_check_N_frame(uint8_t *tmp_data)
+{
+	himax_mcu_register_read(addr_set_frame_addr, DATA_LEN_4, tmp_data);
+	I("%s: tmp_data[0]=0x%02X\n", __func__, tmp_data[0]);
+}
+
+/* FW side end*/
+/* CORE_FW */
+
+/* CORE_FLASH */
+/* FLASH side start*/
+
+
+void himax_mcu_block_erase(uint32_t start_addr, uint32_t length)
+{
+	uint32_t page_prog_start = 0;
+	uint32_t block_size = 0x10000;//64KB
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+
+
+	himax_parse_assign_cmd(data_spi200_trans_fmt, tmp_data,
+			       sizeof(tmp_data));
+	himax_mcu_register_write(addr_spi200_trans_fmt, DATA_LEN_4, tmp_data);
+
+	for (page_prog_start = start_addr;
+	     page_prog_start < (start_addr + length);
+	     page_prog_start += block_size) {
+		himax_parse_assign_cmd(data_spi200_trans_ctrl_2, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_trans_ctrl, DATA_LEN_4,
+					 tmp_data);
+
+		himax_parse_assign_cmd(data_spi200_cmd_2, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_cmd, DATA_LEN_4, tmp_data);
+
+		tmp_data[3] = (uint8_t)((page_prog_start >> 24U) & 0xFFU);
+		tmp_data[2] = (uint8_t)((page_prog_start >> 16U) & 0xFFU);
+		tmp_data[1] = (uint8_t)((page_prog_start >> 8U) & 0xFFU);
+		tmp_data[0] = (uint8_t)(page_prog_start & 0xFFU);
+		himax_mcu_register_write(addr_spi200_addr, DATA_LEN_4,
+					 tmp_data);
+
+		himax_parse_assign_cmd(data_spi200_trans_ctrl_3, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_trans_ctrl, DATA_LEN_4,
+					 tmp_data);
+
+		himax_parse_assign_cmd(data_spi200_cmd_4, tmp_data,
+				       sizeof(tmp_data));
+		himax_mcu_register_write(addr_spi200_cmd, DATA_LEN_4, tmp_data);
+
+		msleep(100);
+
+		if (!himax_mcu_wait_wip(100)) {
+			E("%s:Erase Fail\n", __func__);
+			return;
+		}
+	}
+
+	I("%s:END\n", __func__);
+}
+
+void himax_mcu_sector_erase(uint32_t start_addr, uint32_t length)
+{
+	uint32_t tmp_addr_32 = 0;
+	uint8_t data[DATA_LEN_4] = { 0 };
+	uint32_t page_prog_start = 0;
+	uint32_t sector_size = 0x1000;
+
+	/*=====================================
+	 *SPI Transfer Format : 0x8000_0010 ==> 0x0002_0780
+	 *=====================================
+	 */
+	data[3] = 0x00;
+	data[2] = 0x02;
+	data[1] = 0x07;
+	data[0] = 0x80;
+
+	tmp_addr_32 = 0x80000010U;
+	himax_mcu_register_write(tmp_addr_32, DATA_LEN_4, data);
+
+	for (page_prog_start = start_addr;
+	     page_prog_start < (start_addr + length);
+	     page_prog_start += sector_size) {
+		/*=====================================
+		 *Write Enable : 1. 0x8000_0020 ==> 0x4700_0000 [control]
+		 *			 2. 0x8000_0024 ==> 0x0000_0006 [WREN]
+		 *=====================================
+		 */
+		data[3] = 0x47;
+		data[2] = 0x00;
+		data[1] = 0x00;
+		data[0] = 0x00;
+		tmp_addr_32 = 0x80000020U;
+		himax_mcu_register_write(tmp_addr_32, DATA_LEN_4, data);
+		data[3] = 0x00;
+		data[2] = 0x00;
+		data[1] = 0x00;
+		data[0] = 0x06;
+		tmp_addr_32 = 0x80000024U;
+		himax_mcu_register_write(tmp_addr_32, DATA_LEN_4, data);
+
+		/*=====================================
+		 *Sector Erase
+		 *Command : 0x8000_0028 ==> 0x0000_0000 [SPI addr]
+		 *				0x8000_0020 ==> 0x6700_0000 [control]
+		 *				0x8000_0024 ==> 0x0000_0020 [SE]
+		 *=====================================
+		 */
+
+		data[3] = (uint8_t)(page_prog_start >> 24);
+		data[2] = (uint8_t)(page_prog_start >> 16);
+		data[1] = (uint8_t)(page_prog_start >> 8);
+		data[0] = (uint8_t)page_prog_start;
+
+		tmp_addr_32 = 0x80000028U;
+		himax_mcu_register_write(tmp_addr_32, DATA_LEN_4, data);
+		data[3] = 0x67;
+		data[2] = 0x00;
+		data[1] = 0x00;
+		data[0] = 0x00;
+		tmp_addr_32 = 0x80000020U;
+		himax_mcu_register_write(tmp_addr_32, DATA_LEN_4, data);
+		data[3] = 0x00;
+		data[2] = 0x00;
+		data[1] = 0x00;
+		data[0] = 0x20;
+		tmp_addr_32 = 0x80000024U;
+		himax_mcu_register_write(tmp_addr_32, DATA_LEN_4, data);
+
+		if (!himax_mcu_wait_wip(100)) {
+			E("%s: Fail:\n", __func__);
+		}
+		I("%s:page_prog_start = 0x%8X,\n", __func__, page_prog_start);
+	}
+
+	I("%s:END\n", __func__);
+}
+
+bool himax_mcu_fts_ctpm_fw_upgrade(const u8 *fw_data, unsigned int bin_size)
+{
+	bool upgrade_success = false;
+	uint8_t counter = 0U;
+	uint8_t tmp_addr[4];
+	struct time_var timeStart;
+	struct time_var timeEnd;
+	struct time_var timeDelta;
+
+	if ((bin_size == FW_SIZE_255k) || (bin_size == FW_SIZE_128k)) {
+		if (bin_size != ic_data->HX_FW_SIZE) {
+			E("%s: file size does not match IC setting\n", __func__);
+		} else {
+			time_func(&timeStart);
+			for (counter = 0U; counter < 3U; counter++) {
+				g_core_fp.fp_sense_off();
+				himax_mcu_init_psl();
+
+				himax_disable_flash_protected_mode();
+
+				himax_mcu_block_erase(0x00U, bin_size);
+				if (g_core_fp.fp_flash_programming(fw_data, 0U, bin_size) == false) {
+					I("%s => flash_programming fail %d times\n", __func__, counter);
+					himax_mcu_tp_reset();
+					continue;
+				}
+
+				himax_parse_assign_cmd(addr_program_reload_from, tmp_addr,
+							   sizeof(tmp_addr));
+				if (g_core_fp.fp_check_CRC(tmp_addr, bin_size) == 0x00000000U) {
+					upgrade_success = true;
+					break;
+				}
+
+				I("%s => check_CRC fail %d times\n", __func__, counter);
+				himax_mcu_tp_reset();
+
+			}
+			time_func(&timeEnd);
+			timeDelta = time_diff(timeStart, timeEnd);
+#if defined(KERNEL_VER_5_10)
+			I("<<Timer>>%s => %lld.%ld s\n", __func__, timeDelta.tv_sec, timeDelta.tv_nsec);
+#else
+			I("<<Timer>>%s => %ld.%ld s\n", __func__, timeDelta.tv_sec, timeDelta.tv_nsec);
+#endif
+		}
+	}
+	return upgrade_success;
+}
+
+#if (HX_BOOT_UPGRADE == 0x01)
+bool himax_mcu_flash_lastdata_check_with_bin(uint32_t size)
+{
+	uint32_t start_addr = 0xFFFFFFFFU;
+	uint8_t flash_buffer[DATA_LEN_4];
+	uint8_t i = 0;
+
+	start_addr = size - DATA_LEN_4;
+	himax_mcu_register_read(start_addr, DATA_LEN_4, &flash_buffer[0]);
+
+	for (i = 1; i <= DATA_LEN_4; i++) {
+		if (flash_buffer[DATA_LEN_4 - i] != hxfw->data[size - i]) {
+			E("%s: Flash content is different from BIN file, Need Update\n",
+			  __func__);
+			I("FLASH[%08X] ~ FLASH[%08X] = %02X%02X%02X%02X\n",
+			  size - 4, size - 1, flash_buffer[DATA_LEN_4 - 4],
+			  flash_buffer[DATA_LEN_4 - 3],
+			  flash_buffer[DATA_LEN_4 - 2],
+			  flash_buffer[DATA_LEN_4 - 1]);
+			I("BIN[%08X] ~ BIN[%08X] = %02X%02X%02X%02X\n",
+			  size - 4, size - 1, hxfw->data[size - 4],
+			  hxfw->data[size - 3], hxfw->data[size - 2],
+			  hxfw->data[size - 1]);
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static bool hx_bin_desc_data_get(uint32_t addr, uint8_t *flash_buf)
+{
+	uint8_t data_sz = 0x10;
+	uint32_t i = 0;
+	uint32_t j = 0;
+	uint16_t chk_end = 0;
+	uint16_t chk_sum = 0;
+	uint32_t map_code = 0;
+	uint32_t flash_addr = 0;
+	uint32_t flash_size = 0;
+
+	for (i = 0; i < FW_PAGE_SZ; i = i + data_sz) {
+		for (j = i; j < (i + data_sz); j++) {
+			chk_end |= flash_buf[j];
+			chk_sum += flash_buf[j];
+		}
+		if (chk_end == 0U) { /*1. Check all zero*/
+			I("%s: End in [%08X]\n", __func__, i + addr);
+			return false;
+		} else if ((chk_sum % 0x100U) != 0U) { /*2. Check sum*/
+			I("%s: chk sum failed in %X\n", __func__, i + addr);
+		} else { /*3. get data*/
+			map_code = (uint32_t)flash_buf[i] +
+				((uint32_t)flash_buf[i + 1U] << 8U) +
+				((uint32_t)flash_buf[i + 2U] << 16U) +
+				((uint32_t)flash_buf[i + 3U] << 24U);
+			flash_addr = (uint32_t)flash_buf[i + 4U] +
+				((uint32_t)flash_buf[i + 5U] << 8U) +
+				((uint32_t)flash_buf[i + 6U] << 16U) +
+				((uint32_t)flash_buf[i + 7U] << 24U);
+			flash_size = (uint32_t)flash_buf[i + 8U] +
+				((uint32_t)flash_buf[i + 9U] << 8U) +
+				((uint32_t)flash_buf[i + 10U] << 16U) +
+				((uint32_t)flash_buf[i + 11U] << 24U);	
+			switch (map_code) {
+			case FW_CID:
+				CID_VER_MAJ_FLASH_ADDR = flash_addr;
+				CID_VER_MIN_FLASH_ADDR = flash_addr + 1U;
+				I("%s: CID in [%08X]\n", __func__,
+				CID_VER_MAJ_FLASH_ADDR);
+				break;
+			case FW_VER:
+				FW_VER_MAJ_FLASH_ADDR = flash_addr;
+				FW_VER_MIN_FLASH_ADDR = flash_addr + 1U;
+				I("%s: FW_VER in [%08X]\n", __func__,
+				FW_VER_MAJ_FLASH_ADDR);
+				break;
+			case CFG_VER:
+				CFG_VER_MAJ_FLASH_ADDR = flash_addr;
+				CFG_VER_MIN_FLASH_ADDR = flash_addr + 1U;
+				I("%s: CFG_VER in = [%08X]\n", __func__,
+				CFG_VER_MAJ_FLASH_ADDR);
+				break;
+			case TP_CONFIG_TABLE:
+				CFG_TABLE_FLASH_ADDR = (uint32_t)flash_addr;
+				I("%s: CONFIG_TABLE in [%08X]\n", __func__,
+				CFG_TABLE_FLASH_ADDR);
+				break;
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+			case HX8530_ALG_2_SECTION:
+				HX8530_ALG_2_SECTION_ADDR = (uint32_t)flash_addr;
+				HX8530_ALG_2_SECTION_SIZE =  (uint32_t)flash_size;
+				I("%s: HX8530_ALG_2_SECTION in [%08X]\n", __func__,
+				HX8530_ALG_2_SECTION_ADDR);
+				I("%s: HX8530_ALG_2_SECTION_SIZE= %08X\n", __func__,
+				HX8530_ALG_2_SECTION_SIZE);
+				break;
+			case HX8530_CFG_1_SECTION:
+				HX8530_CFG_1_SECTION_ADDR = (uint32_t)flash_addr;
+				HX8530_CFG_1_SECTION_SIZE =  (uint32_t)flash_size;
+				I("%s: HX8530_CFG_1_SECTION in [%08X]\n", __func__,
+				HX8530_CFG_1_SECTION_ADDR);				
+				I("%s: HX8530_CFG_1_SECTION_SIZE= %08X\n", __func__,
+				HX8530_CFG_1_SECTION_SIZE);
+				break;
+#endif
+			default:
+				/*do nothing*/
+				break;
+			}
+		}
+		chk_end = 0;
+		chk_sum = 0;
+	}
+
+	return true;
+}
+
+bool hx_mcu_bin_desc_get(unsigned char *fw, uint32_t max_sz)
+{
+	uint32_t addr_t = 0;
+	unsigned char *fw_buf = NULL;
+	bool keep_on_flag = false;
+	bool g_bin_desc_flag = false;
+
+	do {
+		fw_buf = &fw[addr_t];
+
+		/*Check bin is with description table or not*/
+		if (!g_bin_desc_flag) {
+			if ((fw_buf[0x00] == 0x00U) && (fw_buf[0x01] == 0x00U) &&
+			    (fw_buf[0x02] == 0x00U) && (fw_buf[0x03] == 0x00U) &&
+			    (fw_buf[0x04] == 0x00U) && (fw_buf[0x05] == 0x00U) &&
+			    (fw_buf[0x06] == 0x00U) && (fw_buf[0x07] == 0x00U) &&
+			    (fw_buf[0x0E] == 0x87U)) {
+				g_bin_desc_flag = true;
+			}
+		}
+		if (!g_bin_desc_flag) {
+			I("%s: fw_buf[0x00] = %2X, fw_buf[0x0E] = %2X\n",
+			  __func__, fw_buf[0x00], fw_buf[0x0E]);
+			I("%s: No description table\n", __func__);
+			break;
+		}
+
+		/*Get related data*/
+		keep_on_flag = hx_bin_desc_data_get(addr_t, fw_buf);
+
+		addr_t = addr_t + FW_PAGE_SZ;
+	} while ((max_sz > addr_t) &&keep_on_flag);
+
+	return g_bin_desc_flag;
+}
+#endif
+/* FLASH side end*/
+/* CORE_FLASH */
+
+/* CORE_SRAM */
+bool himax_mcu_get_DSRAM_data(uint8_t *tmp_rawdata)
+{
+	unsigned int i = 0;
+	unsigned char tmp_data[DATA_LEN_4];
+	uint8_t max_i2c_size = MAX_I2C_TRANS_SZ;
+
+	uint16_t x_num = ic_data->HX_RX_NUM;
+	uint16_t y_num = ic_data->HX_TX_NUM;
+	uint16_t total_data_size = ((x_num * y_num) + x_num + y_num) * 2U;
+
+	uint16_t total_size = (((x_num * y_num) + x_num + y_num) * 2U) + 4U;
+	uint8_t *rawdata_buffer = NULL;
+	uint16_t check_sum_cal = 0;
+
+	rawdata_buffer = kcalloc((total_size + 8U), sizeof(uint8_t), GFP_KERNEL);
+	if (rawdata_buffer == NULL) {
+		E("%s, Failed to allocate memory\n", __func__);
+		return false;
+	}
+
+
+	/* 1. Start DSRAM Rawdata and Wait Data Ready */
+	tmp_data[3] = 0x00;
+	tmp_data[2] = 0x00;
+	tmp_data[1] = 0x5A;
+	tmp_data[0] = 0xA5;
+
+	if (himax_write_read_reg(addr_rawdata, tmp_data, 0xA5, 0x5A) < 0) {
+		I("%s 1.Data NOT ready => bypass\n", __func__);
+		himax_mcu_read_FW_status();
+		goto FAIL_Lable;
+	}
+
+	/* 2. Read RawData */
+	for (i = 0; i < total_size; i = i + max_i2c_size) {
+		/*I("%s address = %08X\n", __func__, (addr_rawdata + i));*/
+		if ((total_size - i) >= max_i2c_size) {
+			himax_mcu_register_read(
+				(addr_rawdata + i), max_i2c_size,
+				&rawdata_buffer[i]);
+		} else {
+			himax_mcu_register_read(
+				(addr_rawdata + i), (total_size - i),
+				&rawdata_buffer[i]);
+		}
+	}
+
+	/* 3. FW stop outputing */
+	tmp_data[3] = rawdata_buffer[3];
+	tmp_data[2] = rawdata_buffer[2];
+	tmp_data[1] = 0x00;
+	tmp_data[0] = 0x00;
+
+	if (himax_write_read_reg(addr_rawdata, tmp_data, 0x00, 0x00) < 0) {
+		I("%s 2. Data NOT ready => bypass\n", __func__);
+		himax_mcu_read_FW_status();
+		goto FAIL_Lable;
+	}
+
+	/* 4. Data Checksum Check */
+	for (i = 2U; i < total_size; i += 2U) { /*PASSWORD NOT included */
+		check_sum_cal +=
+			((rawdata_buffer[i + 1U] * 256U) + rawdata_buffer[i]);
+	}
+
+	if ((check_sum_cal % 0x10000U) != 0U) {
+		I("%s check_sum_cal fail=%2X\n", __func__, check_sum_cal);
+		goto FAIL_Lable;
+	} else {
+
+		(void)memcpy(tmp_rawdata, &rawdata_buffer[4],
+			total_data_size * sizeof(uint8_t));
+
+		/*I("%s checksum PASS\n", __func__);*/
+	}
+	kfree(rawdata_buffer);
+	rawdata_buffer = NULL;
+	return true;
+FAIL_Lable:
+	kfree(rawdata_buffer);
+	rawdata_buffer = NULL;
+	return false;
+}
+/* CORE_SRAM */
+#if (HX_BOOT_UPGRADE == 0x01)
+/*-------------------------------------------------------------------------
+ *
+ *	Description:  Read FW_VER and CFG_VER value from FW file
+ *
+ *	Parameters: void
+ *
+ *	Returns: int (0 success/ 1 fail)
+ *
+ */
+int himax_mcu_fw_ver_bin(void)
+{
+	I("%s: use default incell address.\n", __func__);
+	if (hxfw != NULL) {
+		I("Catch fw version in bin file!\n");
+		g_i_FW_VER = ((uint16_t)hxfw->data[FW_VER_MAJ_FLASH_ADDR] << 8) |
+			    (uint16_t)hxfw->data[FW_VER_MIN_FLASH_ADDR];
+		g_i_CFG_VER = ((uint16_t)hxfw->data[CFG_VER_MAJ_FLASH_ADDR] << 8) |
+			    (uint16_t)hxfw->data[CFG_VER_MIN_FLASH_ADDR];
+		g_i_CID_MAJ = hxfw->data[CID_VER_MAJ_FLASH_ADDR];
+		g_i_CID_MIN = hxfw->data[CID_VER_MIN_FLASH_ADDR];
+	} else {
+		I("FW data is null!\n");
+		return 1;
+	}
+	return NO_ERR;
+}
+#endif
+
+#if (HX_RST_PIN_FUNC == 0x01)
+bool himax_mcu_tp_lcm_pin_reset(void)
+{
+	bool ret = false;
+
+	if (gpio_is_valid(private_ts->rst_gpio) && gpio_is_valid(private_ts->lcm_gpio)) {
+		I("%s: Now reset the Touch chip and LCM.\n", __func__);
+		himax_gpio_set(private_ts->rst_gpio, 0);
+		himax_gpio_set(private_ts->lcm_gpio, 0);
+		msleep(60);
+		himax_gpio_set(private_ts->lcm_gpio, 1);
+		msleep(110);
+		himax_gpio_set(private_ts->rst_gpio, 1);
+		msleep(20);
+	} else {
+		ret = true;
+		if (!gpio_is_valid(private_ts->rst_gpio)) {
+			E("%s: Please check tp rst pin, pin is invalid .\n", __func__);
+		}
+		if (!gpio_is_valid(private_ts->lcm_gpio)) {
+			E("%s: Please check LCM rst pin, pin is invalid .\n", __func__);
+		}
+	}
+	return ret;
+}
+
+void himax_mcu_toggle_rst_gpio(void)
+{
+	I("%s: Now reset the Touch chip.\n", __func__);
+	if (private_ts->pdata->g_customer_control_tp_reset == 1) {
+		/* please add control TP_EXT_RSTN function in here */
+		E("%s: unable control TP_EXT_RSTN, please check it\n", __func__);
+	} else {
+		himax_gpio_set(private_ts->rst_gpio, 0);
+		msleep(20);
+		himax_gpio_set(private_ts->rst_gpio, 1);
+		msleep(100);
+	}
+}
+
+void himax_mcu_hw_reset(bool int_off)
+{
+	struct himax_ts_data *ts = private_ts;
+
+	I("%s: int_off=%d\n", __func__, int_off);
+
+	if (ts->rst_gpio >= 0) {
+		if (int_off) {
+			himax_mcu_irq_switch(0);
+		}
+
+		himax_mcu_toggle_rst_gpio();
+
+		if (int_off) {
+			himax_mcu_irq_switch(1);
+		}
+	}
+#if defined(HIMAX_I2C_PLATFORM)
+	himax_mcu_interface_on();
+#endif
+}
+#elif (HX_RST_PIN_FUNC == 0x02)
+	/* Need Customer set TP reset pin and follow sequence time
+	 * Need at least two function control
+	 * 1.himax_mcu_tp_lcm_pin_reset control TP and LCM reset pin for AP recovery
+	 * 2.himax_mcu_toggle_rst_gpio simple tp hardware reset pin
+	 */
+#endif
+
+void himax_mcu_tp_reset(void)
+{
+	I("%s,Enter\n", __func__);
+#if (HX_RST_PIN_FUNC == 0x01)
+	himax_mcu_hw_reset(false);
+#elif (HX_RST_PIN_FUNC == 0x02)
+	/* Need Customer do TP reset pin */
+#else
+	himax_mcu_system_reset();
+#endif
+}
+/*-------------------------------------------------------------------------
+ *
+ *	Description: Compare DTS/FW/FIX_INFO data is match or not.
+ *
+ *	Parameters: void
+ *
+ *	Returns: void
+ *
+ */
+
+#if (HX_FIX_TOUCH_INFO == 0x01)
+void himax_mcu_information_check(void)
+{
+	uint8_t data[DATA_LEN_8] = { 0 };
+	uint8_t j, check_sum = 0, retry = 0;
+	uint8_t FW_MAX_PT = 0;
+	bool FW_INT_IS_EDGE = 0;
+	bool FW_IS_ID_EN = 0;
+	bool FW_ID_PALM_EN = 0;
+	uint16_t FW_Y_RES = 0;
+	uint16_t FW_X_RES = 0;
+	uint8_t FW_RX_NUM = 0;
+	uint8_t FW_TX_NUM = 0;
+	uint32_t fw_setting_addr = addr_fw_setting_start;
+	uint32_t addr = 0;
+
+	for (retry = 0; retry < 5U; retry++) {
+		himax_mcu_register_read(fw_setting_addr, DATA_LEN_4, data);
+		check_sum = data[2] + data[3];
+		fw_setting_addr += DATA_LEN_4;
+		for (addr = fw_setting_addr; addr < addr_fw_setting_end;
+			addr += DATA_LEN_4) {
+
+			himax_mcu_register_read(addr, DATA_LEN_4, data);
+			if (addr == addr_fw_define_chip_rx_tx_num) {
+				FW_RX_NUM = data[2];
+				FW_TX_NUM = data[3];
+			} else if (addr == addr_fw_define_maxpt) {
+				FW_MAX_PT = data[0];
+			} else if (addr == addr_fw_define_int_is_edge) {
+				FW_INT_IS_EDGE = ((data[1] & 0x01U) == 0x01U);
+			} else if (addr == addr_fw_HX_ID_EN) {
+				FW_IS_ID_EN = ((data[1] & 0x02U) == 0x02U);
+				FW_ID_PALM_EN = ((data[1] & 0x80U) == 0x80U);
+				ic_data->STOP_FW_BY_HOST_EN = ((data[1] & 0x01U) == 0x01U);
+			} else if (addr == addr_fw_define_xy_res) {
+				FW_Y_RES = ((uint16_t)data[2] << 8) | (uint16_t)data[3];
+				FW_X_RES = ((uint16_t)data[0] << 8) | (uint16_t)data[1];
+			} else {
+				/*do nothing*/
+			}
+			for (j = 0; j < DATA_LEN_4; j++) {
+				check_sum += data[j];
+			}
+		}
+		himax_mcu_register_read(addr, DATA_LEN_4, data);
+		check_sum += data[0];
+		check_sum = (uint8_t)(0x100U - check_sum);
+
+		if (check_sum == data[1]) {
+			I("%s:check_sum Pass\n", __func__);
+			break;
+		} else {
+			W("check_sum Fail 0x%02X\n", check_sum);
+		}
+	}
+
+	if (ic_data->HX_TX_NUM != FW_TX_NUM) {
+		W("%s: TX_NUM: %d mismatch with FW: %d\n", __func__,
+		ic_data->HX_TX_NUM, FW_TX_NUM);
+	}
+
+	if (ic_data->HX_RX_NUM != FW_RX_NUM) {
+		W("%s: RX_NUM: %d mismatch with FW: %d\n", __func__,
+		ic_data->HX_RX_NUM, FW_RX_NUM);
+	}
+
+	if (ic_data->HX_MAX_PT != FW_MAX_PT) {
+		W("%s: MAX_PT: %d mismatch with FW: %d\n", __func__,
+		ic_data->HX_MAX_PT, FW_MAX_PT);
+	}
+
+	if (ic_data->HX_INT_IS_EDGE != FW_INT_IS_EDGE) {
+		W("%s: INT_type: %d mismatch with FW: %d\n", __func__,
+		ic_data->HX_INT_IS_EDGE, FW_INT_IS_EDGE);
+	}
+
+	if (ic_data->HX_IS_ID_EN != FW_IS_ID_EN) {
+		W("%s: ID_EN: %d mismatch with FW: %d\n", __func__,
+		ic_data->HX_IS_ID_EN, FW_IS_ID_EN);
+	}
+
+	if (ic_data->HX_ID_PALM_EN != FW_ID_PALM_EN) {
+		W("%s: ID_PALM_EN: %d mismatch with FW: %d\n", __func__,
+		ic_data->HX_ID_PALM_EN, FW_ID_PALM_EN);
+	}
+
+	if (ic_data->HX_X_RES != FW_X_RES) {
+		W("%s: X_RES: %d mismatch with FW: %d\n", __func__,
+		ic_data->HX_X_RES, FW_X_RES);
+	}
+
+	if (ic_data->HX_Y_RES != FW_Y_RES) {
+		W("%s: Y_RES: %d mismatch with FW: %d\n", __func__,
+		ic_data->HX_Y_RES, FW_Y_RES);
+	}
+
+}
+#endif
+/*-------------------------------------------------------------------------
+ *
+ *	Description: Read related touch information from mcu or assign fixed values
+ *				to ic_data value.
+ *	Parameters: void
+ *
+ *	Returns: void
+ *
+ */
+void himax_mcu_touch_information(void)
+{
+	uint8_t data[DATA_LEN_8] = { 0 };
+#if (HX_FIX_TOUCH_INFO == 0x00)
+	uint32_t fw_setting_addr = addr_fw_setting_start;
+	uint32_t addr = 0;
+	uint8_t j = 0;
+	uint8_t	check_sum = 0;
+	uint8_t	retry = 0;
+
+	I("%s Enter\n", __func__);
+
+	for (retry = 0; retry < 5U; retry++) {
+		himax_mcu_register_read(fw_setting_addr, DATA_LEN_4, data);
+		check_sum = data[2] + data[3];
+		fw_setting_addr += DATA_LEN_4;
+		for (addr = fw_setting_addr; addr < addr_fw_setting_end;
+			addr += DATA_LEN_4) {
+
+			himax_mcu_register_read(addr, DATA_LEN_4, data);
+			if (addr == addr_fw_define_chip_rx_tx_num) {
+				ic_data->HX_RX_NUM = data[2];
+				ic_data->HX_TX_NUM = data[3];
+			} else if (addr == addr_fw_define_maxpt) {
+				ic_data->HX_MAX_PT = data[0];
+			} else if (addr == addr_fw_define_int_is_edge) {
+				ic_data->HX_INT_IS_EDGE = ((data[1] & 0x01U) == 0x01U);
+			} else if (addr == addr_fw_HX_ID_EN) {
+				ic_data->HX_IS_ID_EN = ((data[1] & 0x02U) == 0x02U);
+				ic_data->HX_ID_PALM_EN = ((data[1] & 0x80U) == 0x80U);
+				ic_data->STOP_FW_BY_HOST_EN = ((data[1] & 0x01U) == 0x01U);
+			} else if (addr == addr_fw_define_xy_res) {
+				ic_data->HX_Y_RES = ((uint16_t)data[2] << 8U);
+				ic_data->HX_Y_RES += (uint16_t)data[3];
+				ic_data->HX_X_RES = ((uint16_t)data[0] << 8U);
+				ic_data->HX_X_RES += (uint16_t)data[1];
+			} else {
+				/*do nothing*/
+			}
+			for (j = 0; j < DATA_LEN_4; j++) {
+				check_sum += data[j];
+			}
+		}
+		himax_mcu_register_read(addr, DATA_LEN_4, data);
+		check_sum += data[0];
+		check_sum = (uint8_t)(0x100U - check_sum);
+
+		if (check_sum == data[1]) {
+			I("%s:check_sum Pass\n", __func__);
+			break;
+		} else {
+			W("check_sum Fail 0x%02X\n", check_sum);
+		}
+	}
+
+#elif (HX_FIX_TOUCH_INFO == 0x01)
+	ic_data->HX_RX_NUM = (uint8_t)FIX_HX_RX_NUM;
+	ic_data->HX_TX_NUM = (uint8_t)FIX_HX_TX_NUM;
+	ic_data->HX_MAX_PT = (uint8_t)FIX_HX_MAX_PT;
+	ic_data->HX_INT_IS_EDGE = (uint8_t)FIX_HX_INT_IS_EDGE;
+	ic_data->HX_Y_RES = private_ts->pdata->screenHeight;
+	ic_data->HX_X_RES = private_ts->pdata->screenWidth;
+	ic_data->HX_IS_ID_EN = (uint8_t)FIX_HX_IS_ID_EN;
+	ic_data->HX_ID_PALM_EN = (uint8_t)FIX_HX_ID_PALM_EN;
+
+	himax_mcu_information_check();
+	himax_mcu_register_read(addr_fw_HX_ID_EN, DATA_LEN_4, data);
+	ic_data->STOP_FW_BY_HOST_EN = ((data[1] & 0x01U) == 0x01U);
+#endif
+
+	private_ts->nFinger_support = ic_data->HX_MAX_PT;
+	private_ts->pdata->abs_x_min = 0U;
+	private_ts->pdata->abs_x_max = ic_data->HX_X_RES;
+	private_ts->pdata->abs_y_min = 0U;
+	private_ts->pdata->abs_y_max = ic_data->HX_Y_RES;
+
+	I("%s:HX_RX_NUM =%d,HX_TX_NUM =%d\n", __func__,
+		ic_data->HX_RX_NUM,
+		ic_data->HX_TX_NUM);
+	I("%s:HX_Y_RES=%d,HX_X_RES =%d,HX_INT_IS_EDGE =%d,\n", __func__,
+		ic_data->HX_Y_RES,
+		ic_data->HX_X_RES,
+		ic_data->HX_INT_IS_EDGE);
+	I("%s:HX_IS_ID_EN=%d,HX_ID_PALM_EN =%d\n", __func__,
+		ic_data->HX_IS_ID_EN,
+		ic_data->HX_ID_PALM_EN);
+	I("%s:STOP_FW_BY_HOST_EN=%d\n", __func__,
+		ic_data->STOP_FW_BY_HOST_EN);
+
+}
+
+unsigned int himax_mcu_cal_data_len(unsigned int raw_cnt_rmd, uint8_t HX_MAX_PT, unsigned int raw_cnt_max)
+{
+	unsigned int RawDataLen;
+
+	if (raw_cnt_rmd != 0x00U) {
+		RawDataLen = MAX_I2C_TRANS_SZ -
+			     ((HX_MAX_PT + raw_cnt_max + 3U) * 4U) - 2U;
+	} else {
+		RawDataLen = MAX_I2C_TRANS_SZ -
+			     ((HX_MAX_PT + raw_cnt_max + 2U) * 4U) - 2U;
+	}
+
+	return RawDataLen;
+}
+
+bool himax_mcu_diag_check_sum(struct himax_report_data *hx_touch_data_tmp)
+{
+	uint16_t check_sum_cal = 0;
+	uint8_t i = 0;
+
+	/* Check 128th byte CRC */
+	for (i = 0; i < (hx_touch_data_tmp->touch_all_size -
+					    hx_touch_data_tmp->touch_info_size); i += 2U) {
+
+		check_sum_cal += ((hx_touch_data_tmp->hx_rawdata_buf[i + 1U] * FLASH_RW_MAX_LEN) +
+				  hx_touch_data_tmp->hx_rawdata_buf[i]);
+	}
+
+	if ((check_sum_cal % HX64K) != 0U) {
+		I("%s fail=%2X\n", __func__, check_sum_cal);
+		return 0;
+	}
+
+	return 1;
+}
+
+void himax_mcu_diag_parse_raw_data(struct himax_report_data *hx_touch_data_tmp,
+				   uint16_t mul_num, uint16_t self_num, uint8_t diag_cmd,
+				   int16_t *mutual_data, int16_t *self_data)
+{
+	diag_mcu_parse_raw_data(hx_touch_data_tmp, mul_num, self_num, diag_cmd,
+				mutual_data, self_data);
+}
+
+/*---------------------------------------------------------------------------------
+ *
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *	|      ID             |    BP     | WP | type | Lock code | delay time(ms)    |
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *	| 0/8                 | 2_3       |  7 |    1 | 0x8C      | 10/10             |
+ *	| 1/2/11/18/21/22/23  | 2_3_4     |  7 |    2 | 0x9C      | 1/10/0/1/2/2/2    |
+ *	| 9/10/12/13/17/19/20 | 2_3_4_5   |  7 |    3 | 0xBC      | 10/10/10/0/5/2/2  |
+ *	| 3/4/5/6/7/14/15/16  | 2_3_4_5_6 |  7 |    4 | 0xFC      | 5/5/5/40/30/8/8/8 |
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *
+ */
+void himax_disable_flash_protected_mode(void)
+{
+	struct himax_ts_data *ts = private_ts;
+	uint8_t data[DATA_LEN_4] = { 0 };
+	uint8_t lock_code = 0;
+	uint8_t loop_count = 0;
+	int ret = NO_ERR;
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83180) ||defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83181)
+	uint8_t byte_1st = 0x10;
+	uint8_t byte_2st = 0x10;
+#endif
+
+	ret = himax_mcu_flash_id_check();
+
+	if (ret == HX_FAIL) {
+		I("%s: Cannot recognize flash id type\n", __func__);
+	}
+
+	switch (flash_lock_type) {
+	case 1:
+		lock_code = 0x8CU;
+		break;
+	case 2:
+		lock_code = 0x9CU;
+		break;
+	case 3:
+		lock_code = 0xBCU;
+		break;
+	case 4:
+		lock_code = 0xFCU;
+		break;
+	default:
+		I("%s: Unknown lock type with value : 0x%02X\n", __func__,
+		  flash_lock_type);
+		break;
+	}
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83192) || defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83193)\
+	|| defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+
+	/*Decide disable WP type */
+	if (strnstr(ts->chip_name, HX_83192D_PWON, 30) != NULL) {
+		/*disable WP for HX83192D*/
+		himax_parse_assign_cmd(data_WP_disable_HX83192D, data, sizeof(data));
+		himax_mcu_register_write(addr_WP_pin_HX83192D, DATA_LEN_4, data);
+	} else {
+
+		if (strnstr(ts->chip_name, HX_83193A_PWON, 30) != NULL) {
+			/* WP pin pull high*/
+			himax_parse_assign_cmd(data_WP_disable_HX83193, data, sizeof(data));
+			himax_mcu_register_write(addr_WP_pin_HX83193, DATA_LEN_4, data);
+		}
+
+#if defined(WP_GPIO4)
+		/*disable WP by gpio4*/
+		himax_parse_assign_cmd(data_WP_gpio4_cmd_01, data, sizeof(data));
+		himax_mcu_register_write(addr_WP_pin_base, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_WP_gpio4_cmd_10, data, sizeof(data));
+		himax_mcu_register_write(addr_WP_gpio4_cmd_04, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_WP_gpio4_cmd_01, data, sizeof(data));
+		himax_mcu_register_write(addr_WP_gpio4_cmd_1C, DATA_LEN_4, data);
+
+#elif defined(WP_GPIO0)
+		/*disable WP by gpio0*/
+		himax_parse_assign_cmd(data_WP_gpio0_cmd_01, data, sizeof(data));
+		himax_mcu_register_write(addr_WP_pin_base, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_WP_gpio0_cmd_01, data, sizeof(data));
+		himax_mcu_register_write(addr_WP_gpio0_cmd_04, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_WP_gpio0_cmd_01, data, sizeof(data));
+		himax_mcu_register_write(addr_WP_gpio0_cmd_0C, DATA_LEN_4, data);
+#endif
+	}
+
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83194) || defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83195)
+
+	himax_parse_assign_cmd(data_WP_disable_HX83195, data, sizeof(data));
+	himax_mcu_register_write(addr_WP_pin_HX83195, DATA_LEN_4, data);
+
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83180) ||  defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83181)
+
+	himax_mcu_register_read(addr_WP_pin_HX83180, DATA_LEN_4, data);
+	data[1] = data[1] | byte_1st;
+	data[2] = data[2] | byte_2st;
+	himax_mcu_register_write(addr_WP_pin_HX83180, DATA_LEN_4, data);
+
+#endif
+
+	/*BP addr config */
+	himax_parse_assign_cmd(data_BP_lock_cmd_1, data, sizeof(data));
+	himax_mcu_register_write(addr_BP_lock_cmd_10, DATA_LEN_4, data);
+
+	himax_parse_assign_cmd(data_BP_lock_cmd_2, data, sizeof(data));
+	himax_mcu_register_write(addr_BP_lock_cmd_20, DATA_LEN_4, data);
+
+	himax_parse_assign_cmd(data_BP_lock_cmd_3, data, sizeof(data));
+	himax_mcu_register_write(addr_BP_lock_cmd_24, DATA_LEN_4, data);
+
+	himax_parse_assign_cmd(data_BP_lock_cmd_4, data, sizeof(data));
+	himax_mcu_register_write(addr_BP_lock_cmd_20, DATA_LEN_4, data);
+
+	himax_parse_assign_cmd(data_BP_lock_cmd_5, data, sizeof(data));
+	himax_mcu_register_write(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+
+	himax_parse_assign_cmd(data_BP_lock_cmd_6, data, sizeof(data));
+	himax_mcu_register_write(addr_BP_lock_cmd_24, DATA_LEN_4, data);
+
+	/*Delay as write status register cycle time, expect 20ms ~ 40ms*/
+	/*<20ms will cause trouble 0x8000002C wrong return value*/
+
+	/*Check BP addr */;
+	himax_parse_assign_cmd(data_BP_check_cmd_1, data, sizeof(data));
+	himax_mcu_register_write(addr_BP_lock_cmd_20, DATA_LEN_4, data);
+
+	himax_parse_assign_cmd(data_BP_check_cmd_2, data, sizeof(data));
+	himax_mcu_register_write(addr_BP_lock_cmd_24, DATA_LEN_4, data);
+
+	/*Read Addr*/
+	himax_mcu_register_read(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+
+	while (((data[0] & 0x03U) != 0x00U) && (loop_count != 30U)) {
+		himax_parse_assign_cmd(data_BP_check_cmd_2, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_24, DATA_LEN_4, data);
+
+		himax_mcu_register_read(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+		loop_count++;
+		if (loop_count == 30U) {
+			W("%s: disable WP BP lock with wrong return data :0x%02X, loop value : %d.\n",
+			  __func__, data[0], loop_count);
+		}
+		usleep_range(1000, 1100);
+	}
+
+	if (data[0] != 0x00U) {
+		W("%s: disable WP BP lock with wrong return data :0x%02X, loop value : %d.\n",
+		  __func__, data[0], loop_count);
+	}
+
+	I("%s: Disable WP BP lock finish.  value = 0x%02X, loop value %d.\n",
+	  __func__, data[0], loop_count);
+}
+
+/*---------------------------------------------------------------------------------
+ *
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *	|      ID             |    BP     | WP | type | Lock code | delay time(ms)    |
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *	| 0/8                 | 2_3       |  7 |    1 | 0x8C      | 10/10             |
+ *	| 1/2/11/18/21/22/23  | 2_3_4     |  7 |    2 | 0x9C      | 1/10/0/1/2/2/2    |
+ *	| 9/10/12/13/17/19/20 | 2_3_4_5   |  7 |    3 | 0xBC      | 10/10/10/0/5/2/2  |
+ *	| 3/4/5/6/7/14/15/16  | 2_3_4_5_6 |  7 |    4 | 0xFC      | 5/5/5/40/30/8/8/8 |
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *
+ */
+void himax_enable_flash_protected_mode(void)
+{
+	struct himax_ts_data *ts = private_ts;
+	uint8_t data[DATA_LEN_4] = { 0 };
+	uint8_t lock_code = 0;
+	uint8_t loop_count = 0;
+	int ret = NO_ERR;
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83180) || defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83181)
+	uint8_t byte_1st = 0xEF;
+	uint8_t byte_2st = 0x10;
+#endif
+
+	ret = himax_mcu_flash_id_check();
+
+	if (ret == HX_FAIL) {
+		I("%s: Cannot recognize flash id type\n", __func__);
+	} else {
+
+		switch (flash_lock_type) {
+		case 1:
+			lock_code = 0x8CU;
+			break;
+		case 2:
+			lock_code = 0x9CU;
+			break;
+		case 3:
+			lock_code = 0xBCU;
+			break;
+		case 4:
+			lock_code = 0xFCU;
+			break;
+		default:
+			I("%s: Unknown lock type with value : 0x%02X\n", __func__,
+			flash_lock_type);
+			break;
+		}
+
+		/*BP addr config */
+		himax_parse_assign_cmd(data_BP_lock_cmd_1, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_10, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_BP_lock_cmd_2, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_20, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_BP_lock_cmd_3, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_24, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_BP_lock_cmd_4, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_20, DATA_LEN_4, data);
+
+
+		switch (flash_lock_type) {
+		case 1:
+			himax_parse_assign_cmd(data_BP_lock_cmd_8C, data, sizeof(data));
+			himax_mcu_register_write(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+			break;
+		case 2:
+			himax_parse_assign_cmd(data_BP_lock_cmd_9C, data, sizeof(data));
+			himax_mcu_register_write(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+			break;
+		case 3:
+			himax_parse_assign_cmd(data_BP_lock_cmd_BC, data, sizeof(data));
+			himax_mcu_register_write(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+			break;
+		case 4:
+			himax_parse_assign_cmd(data_BP_lock_cmd_FC, data, sizeof(data));
+			himax_mcu_register_write(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+			break;
+		default:
+			I("%s: Write protected code, Unknown lock type with value : 0x%02X\n", __func__,
+			flash_lock_type);
+			break;
+		}
+
+
+		himax_parse_assign_cmd(data_BP_lock_cmd_6, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_24, DATA_LEN_4, data);
+
+		/*Delay as write status register cycle time, expect 20ms ~ 40ms*/
+		/*<20ms will cause trouble 0x8000002C wrong return value*/
+
+		/*Check BP */
+		himax_parse_assign_cmd(data_BP_check_cmd_1, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_20, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_BP_check_cmd_2, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_24, DATA_LEN_4, data);
+
+		/*Read Addr*/
+		himax_mcu_register_read(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+
+		while (((data[0] & 0x03U) != 0x00U) && (loop_count != 30U) && (flash_lock_type != 0xFFU)) {
+			himax_parse_assign_cmd(data_BP_check_cmd_2, data, sizeof(data));
+			himax_mcu_register_write(addr_BP_lock_cmd_24, DATA_LEN_4, data);
+
+			himax_mcu_register_read(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+			loop_count++;
+			if (loop_count == 30U) {
+				W("%s: enable WP BP lock with wrong data :0x%02X, lock code 0x%02X, loop value %d.\n",
+				__func__, data[0], lock_code, loop_count);
+				ret = HX_FAIL;
+			}
+			usleep_range(1000, 1100);
+		}
+
+		if (ret == HX_FAIL) {
+			W("%s: Cannot enable WP BP lock.\n", __func__);
+			/* Fail case */
+		} else {
+
+			if ((data[0] & lock_code) != lock_code) {
+				W("%s: enable WP BP lock with wrong data :0x%02X, lock code 0x%02X, loop value %d.\n",
+				__func__, data[0], lock_code, loop_count);
+				ret = HX_FAIL;
+			} else {
+				I("%s: Enable WP BP lock finish. value = 0x%02X, loop value %d.\n",
+				__func__, data[0], loop_count);
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83192) || defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83193)\
+	|| defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+				/*Decide enable WP type */
+				if (strnstr(ts->chip_name, HX_83192D_PWON, 30) != NULL) {
+					/*enable WP for HX83192D*/
+					himax_parse_assign_cmd(data_WP_enable_HX83192D, data, sizeof(data));
+					himax_mcu_register_write(addr_WP_pin_HX83192D, DATA_LEN_4, data);
+				} else {
+#if defined(WP_GPIO4)
+					/*enable WP by gpio4 */
+					himax_parse_assign_cmd(data_WP_gpio4_cmd_01, data, sizeof(data));
+					himax_mcu_register_write(addr_WP_pin_base, DATA_LEN_4, data);
+
+					himax_parse_assign_cmd(data_WP_gpio4_cmd_10, data, sizeof(data));
+					himax_mcu_register_write(addr_WP_gpio4_cmd_04, DATA_LEN_4, data);
+
+					himax_parse_assign_cmd(data_WP_gpio4_cmd_00, data, sizeof(data));
+					himax_mcu_register_write(addr_WP_gpio4_cmd_1C, DATA_LEN_4, data);
+#elif defined(WP_GPIO0)
+					/*enable WP by gpio0 */
+					himax_parse_assign_cmd(data_WP_gpio0_cmd_01, data, sizeof(data));
+					himax_mcu_register_write(addr_WP_pin_base, DATA_LEN_4, data);
+
+					himax_parse_assign_cmd(data_WP_gpio0_cmd_01, data, sizeof(data));
+					himax_mcu_register_write(addr_WP_gpio0_cmd_04, DATA_LEN_4, data);
+
+					himax_parse_assign_cmd(data_WP_gpio0_cmd_00, data, sizeof(data));
+					himax_mcu_register_write(addr_WP_gpio0_cmd_0C, DATA_LEN_4, data);
+#endif
+				}
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83194) || defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83195)
+
+				himax_parse_assign_cmd(data_WP_enable_HX83195, data, sizeof(data));
+				himax_mcu_register_write(addr_WP_pin_HX83195, DATA_LEN_4, data);
+
+#elif defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83180) ||  defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83181)
+
+				himax_mcu_register_read(addr_WP_pin_HX83180, DATA_LEN_4, data);
+				data[1] = data[1] & byte_1st;
+				data[2] = data[2] | byte_2st;
+				himax_mcu_register_write(addr_WP_pin_HX83180, DATA_LEN_4, data);
+#endif
+			}
+		}
+	}
+}
+
+/*---------------------------------------------------------------------------------
+ *
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *	|      ID             |    BP     | WP | type | Lock code | delay time(ms)    |
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *	| 0/8                 | 2_3       |  7 |    1 | 0x8C      | 10/10             |
+ *	| 1/2/11/18/21/22/23  | 2_3_4     |  7 |    2 | 0x9C      | 1/10/0/1/2/2/2    |
+ *	| 9/10/12/13/17/19/20 | 2_3_4_5   |  7 |    3 | 0xBC      | 10/10/10/0/5/2/2  |
+ *	| 3/4/5/6/7/14/15/16  | 2_3_4_5_6 |  7 |    4 | 0xFC      | 5/5/5/40/30/8/8/8 |
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *
+ */
+int himax_mcu_WP_BP_status(void)
+{
+	uint8_t data[DATA_LEN_4] = { 0 };
+	int ret = NO_ERR;
+	uint8_t lock_code = 0;
+
+	ret = himax_mcu_flash_id_check();
+
+	if (ret == HX_FAIL) {
+		E("%s: Cannot recognize flash id type\n", __func__);
+	} else {
+
+		switch (flash_lock_type) {
+		case 1:
+			lock_code = 0x8CU;
+			break;
+		case 2:
+			lock_code = 0x9CU;
+			break;
+		case 3:
+			lock_code = 0xBCU;
+			break;
+		case 4:
+			lock_code = 0xFCU;
+			break;
+		default:
+			I("%s: Unknown lock type with value : 0x%02X\n", __func__,
+			flash_lock_type);
+			break;
+		}
+
+		/*Check Addr 0x8000_002C value, if 0x9C BP is lock*/
+		himax_parse_assign_cmd(data_BP_lock_cmd_1, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_10, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_BP_check_cmd_1, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_20, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_BP_check_cmd_2, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_24, DATA_LEN_4, data);
+
+		himax_mcu_register_read(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+
+		if ((data[0] & lock_code) == lock_code) {
+			I("%s: WP BP lock status is lock, Addr 0x8000_002C, read value is 0x%02X, lock_code value is 0x%02X\n",
+			__func__, data[0], lock_code);
+			ret = HX_LOCK;
+		} else {
+			I("%s: WP BP lock status is unlock, Addr 0x8000_002C, read value is 0x%02X, lock_code value is 0x%02X\n",
+			__func__, data[0], lock_code);
+			ret = HX_UNLOCK;
+		}
+	}
+
+	return ret;
+
+}
+
+/*---------------------------------------------------------------------------------
+ *
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *	|      ID             |    BP     | WP | type | Lock code | delay time(ms)    |
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *	| 0/8                 | 2_3       |  7 |    1 | 0x8C      | 10/10             |
+ *	| 1/2/11/18/21/22/23  | 2_3_4     |  7 |    2 | 0x9C      | 1/10/0/1/2/2/2    |
+ *	| 9/10/12/13/17/19/20 | 2_3_4_5   |  7 |    3 | 0xBC      | 10/10/10/0/5/2/2  |
+ *	| 3/4/5/6/7/14/15/16  | 2_3_4_5_6 |  7 |    4 | 0xFC      | 5/5/5/40/30/8/8/8 |
+ *	+---------------------+-----------+----+------+-----------+-------------------+
+ *
+ */
+int himax_mcu_flash_id_check(void)
+{
+	uint8_t data[DATA_LEN_4] = { 0 };
+	uint8_t i;
+	uint8_t Flash_list_tmp[][3] = Flash_list;
+	size_t len = sizeof(Flash_list_tmp) / (sizeof(uint8_t) * 3U);
+	uint8_t flash_idx;
+	int result = NO_ERR;
+	int retry_count = 0;
+
+	flash_idx = 0xFFU;
+	flash_lock_type = 0xFFU;
+	do {
+		himax_parse_assign_cmd(data_BP_check_cmd_3, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_20, DATA_LEN_4, data);
+
+		himax_parse_assign_cmd(data_BP_check_cmd_4, data, sizeof(data));
+		himax_mcu_register_write(addr_BP_lock_cmd_24, DATA_LEN_4, data);
+
+		himax_mcu_register_read(addr_BP_lock_cmd_2C, DATA_LEN_4, data);
+
+		/*I("%s: FlashList len : %zd, Flash type ID data = %X,%X,%X\n", __func__,
+		 * len, data[0], data[1], data[2]);
+		 */
+
+		for (i = 0; i < len; i++) {
+			if ((Flash_list_tmp[i][0] == data[0]) &&
+				(Flash_list_tmp[i][1] == data[1]) &&
+				(Flash_list_tmp[i][2] == data[2])) {
+				flash_idx = i;
+				break;
+			}
+		}
+
+		switch (flash_idx) {
+		case 0U:
+		case 8U:
+			flash_lock_type = 1U;
+			break;
+
+		case 1U:
+		case 2U:
+		case 11U:
+		case 18U:
+		case 21U:
+		case 22U:
+		case 23U:
+			flash_lock_type = 2U;
+			break;
+
+		case 9U:
+		case 10U:
+		case 12U:
+		case 13U:
+		case 17U:
+		case 19U:
+		case 20U:
+			flash_lock_type = 3U;
+			break;
+
+		case 3U:
+		case 4U:
+		case 5U:
+		case 6U:
+		case 7U:
+		case 14U:
+		case 15U:
+		case 16U:
+			flash_lock_type = 4U;
+			break;
+
+		default:
+			flash_lock_type = 0xFFU;
+			result = HX_FAIL;
+			break;
+		}
+
+		if (flash_lock_type != 0xFFU) {
+
+			break;
+		}
+
+		usleep_range(10000, 11000);
+		retry_count++;
+	} while (retry_count < 3);
+
+	return result;
+}
+
+void himax_mcu_write_dd_reg_password(uint8_t ic_device)
+{
+	uint8_t data[DATA_LEN_4] = { 0 };
+	uint8_t check_STOP_FW = 0x6AU;
+	uint8_t cMax = 7U;
+	uint8_t cnt = 0U;
+#if defined(PANEL_ID_CHECK)
+#if defined(FW_baseline_status_ready)
+	uint8_t retry = 0;
+#endif
+#endif
+
+#if defined(PANEL_ID_CHECK)
+#if defined(FW_baseline_status_ready)
+	FW_ready = false;
+
+	do {
+		himax_mcu_register_read(addr_FW_baseline_ready, DATA_LEN_4, data);
+		if ((data[0] == 0x32U) || (data[0] == 0x35U) || (data[0] == 0x38U)) {
+			FW_ready = true;
+			break;
+		} else {
+			retry++;
+			usleep_range(20000, 21000);
+		}
+	} while (retry < 15U);
+
+	(void)memset(data, 0x00, sizeof(data));
+
+	if (FW_ready) {
+#endif
+#endif
+		if (ic_data->STOP_FW_BY_HOST_EN) {
+			do {
+				data[0] = 0x5AU;
+				himax_mcu_register_write(addr_ctrl_fw, DATA_LEN_4,
+							data);
+
+				usleep_range(20000, 21000);
+				himax_mcu_register_read(addr_ctrl_fw, DATA_LEN_4, data);
+				I("%s: Check 9000005C data[0]=0x%02X\n", __func__, data[0]);
+				cnt	+=	1U;
+				if (cnt >= cMax) {
+					break;
+				}
+			} while (data[0] != check_STOP_FW);
+			if (data[0] == check_STOP_FW) {
+				I("%s: STOP_FW_BY_HOST finished!\n", __func__);
+			} else {
+				W("%s: STOP_FW_BY_HOST Fail!\n", __func__);
+			}
+
+		} else {
+			g_core_fp.fp_sense_off();
+		}
+#if defined(PANEL_ID_CHECK)
+#if defined(FW_baseline_status_ready)
+	} else {
+		g_core_fp.fp_sense_off();
+	}
+#endif
+#endif
+	data[0] = 0xDDU;
+	data[1] = 0x00U;
+	data[2] = 0x00U;
+	data[3] = 0x00U;
+	if (ic_device == (uint8_t)IC_MASTER) {
+		himax_mcu_register_write(addr_osc_en, DATA_LEN_4, data);
+	} else {
+		himax_mcu_register_write_slave(ic_device, addr_osc_en, DATA_LEN_4, data);
+	}
+
+#if !defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83192) && !defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83193)
+
+	data[0] = 0xA5U;
+	data[1] = 0x00U;
+	data[2] = 0x00U;
+	data[3] = 0x00U;
+ 	if (ic_device == (uint8_t)IC_MASTER) {
+		himax_mcu_register_write(addr_osc_pw, DATA_LEN_4, data);
+	} else {
+		himax_mcu_register_write_slave(ic_device, addr_osc_pw, DATA_LEN_4, data);
+	}
+#endif
+	data[0] = 0x00U;
+	data[1] = 0x55U;
+	data[2] = 0x66U;
+	data[3] = 0xCCU;
+	himax_mcu_dd_reg_write(0xEB, 0, 4, data, 0, ic_device);
+}
+
+void himax_mcu_clear_dd_reg_password(uint8_t ic_device)
+{
+	uint8_t data[DATA_LEN_4] = { 0 };
+	uint8_t check_STOP_FW = 0x6AU;
+	uint8_t cMax = 7U;
+	uint8_t cnt = 0U;
+
+	data[0] = 0x00U;
+	data[1] = 0x00U;
+	data[2] = 0x00U;
+	data[3] = 0x00U;
+	himax_mcu_dd_reg_write(0xEB, 0, 4, data, 0, ic_device);
+
+#if !defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83192) && !defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83193)
+
+	data[0] = 0x00U;
+	data[1] = 0x00U;
+	data[2] = 0x00U;
+	data[3] = 0x00U;
+ 	if (ic_device == (uint8_t)IC_MASTER) {
+		himax_mcu_register_write(addr_osc_pw, DATA_LEN_4, data);
+	} else {
+		himax_mcu_register_write_slave(ic_device, addr_osc_pw, DATA_LEN_4, data);
+	}
+#endif
+
+	data[0] = 0x00U;
+	data[1] = 0x00U;
+	data[2] = 0x00U;
+	data[3] = 0x00U;
+	if (ic_device == (uint8_t)IC_MASTER) {
+		himax_mcu_register_write(addr_osc_en, DATA_LEN_4, data);
+	} else {
+		himax_mcu_register_write_slave(ic_device, addr_osc_en, DATA_LEN_4, data);
+	}
+#if defined(PANEL_ID_CHECK)
+#if defined(FW_baseline_status_ready)
+	if (FW_ready) {
+#endif
+#endif
+		if (ic_data->STOP_FW_BY_HOST_EN) {
+			do {
+				data[0] = 0x00U;
+				himax_mcu_register_write(addr_ctrl_fw, DATA_LEN_4,
+							data);
+
+				usleep_range(20000, 21000);
+				himax_mcu_register_read(addr_ctrl_fw, DATA_LEN_4, data);
+				I("%s: Check 9000005C data[0]=0x%02X\n", __func__, data[0]);
+				cnt += 1U;
+				if (cnt >= cMax) {
+					break;
+				}
+			} while (data[0] == check_STOP_FW);
+			if (data[0] != check_STOP_FW) {
+				I("%s: START_FW_BY_HOST finished!\n", __func__);
+			} else {
+				E("%s: START_FW_BY_HOST Fail!\n", __func__);
+			}
+
+		} else {
+			g_core_fp.fp_sense_on();
+		}
+#if defined(PANEL_ID_CHECK)
+#if defined(FW_baseline_status_ready)
+	} else {
+		g_core_fp.fp_sense_on();
+	}
+
+	FW_ready = false;
+#endif
+#endif
+}
+
+/* init end*/
+/* CORE_INIT */
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_mmi.mod linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_mmi.mod
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_mmi.mod	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_mmi.mod	2024-06-14 10:43:31.782186054 +0200
@@ -0,0 +1,2 @@
+drivers/input/touchscreen/hxchipset/himax_debug.o drivers/input/touchscreen/hxchipset/himax_self_test.o drivers/input/touchscreen/hxchipset/himax_ic_incell_core.o drivers/input/touchscreen/hxchipset/himax_ic_HX83193.o drivers/input/touchscreen/hxchipset/himax_common.o drivers/input/touchscreen/hxchipset/himax_platform.o
+
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_mmi.mod.c linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_mmi.mod.c
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_mmi.mod.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_mmi.mod.c	2024-06-14 10:43:31.782186054 +0200
@@ -0,0 +1,125 @@
+#include <linux/module.h>
+#define INCLUDE_VERMAGIC
+#include <linux/build-salt.h>
+#include <linux/vermagic.h>
+#include <linux/compiler.h>
+
+BUILD_SALT;
+
+MODULE_INFO(vermagic, VERMAGIC_STRING);
+MODULE_INFO(name, KBUILD_MODNAME);
+
+__visible struct module __this_module
+__section(".gnu.linkonce.this_module") = {
+	.name = KBUILD_MODNAME,
+	.init = init_module,
+#ifdef CONFIG_MODULE_UNLOAD
+	.exit = cleanup_module,
+#endif
+	.arch = MODULE_ARCH_INIT,
+};
+
+MODULE_INFO(intree, "Y");
+
+#ifdef CONFIG_RETPOLINE
+MODULE_INFO(retpoline, "Y");
+#endif
+
+static const struct modversion_info ____versions[]
+__used __section("__versions") = {
+	{ 0x3868185, "module_layout" },
+	{ 0x883dcf95, "kernel_write" },
+	{ 0x34c9bece, "kmalloc_caches" },
+	{ 0x2d6fcc06, "__kmalloc" },
+	{ 0xf9a482f9, "msleep" },
+	{ 0x349cba85, "strchr" },
+	{ 0x20f76309, "single_open" },
+	{ 0x97255bdf, "strlen" },
+	{ 0x80d68d3e, "fb_register_client" },
+	{ 0x27bbf221, "disable_irq_nosync" },
+	{ 0xf93983f6, "i2c_del_driver" },
+	{ 0x4a78bd38, "single_release" },
+	{ 0xfeff059e, "seq_puts" },
+	{ 0x695bf5e9, "hrtimer_cancel" },
+	{ 0xcfbba230, "i2c_transfer" },
+	{ 0x47229b5c, "gpio_request" },
+	{ 0xf7802486, "__aeabi_uidivmod" },
+	{ 0xc5e1beab, "gpio_to_desc" },
+	{ 0xffeedf6a, "delayed_work_timer_fn" },
+	{ 0x848b4a19, "seq_printf" },
+	{ 0x4205ad24, "cancel_work_sync" },
+	{ 0xd99a617, "remove_proc_entry" },
+	{ 0xe59c518b, "filp_close" },
+	{ 0x4c2ae700, "strnstr" },
+	{ 0xb1ad28e0, "__gnu_mcount_nc" },
+	{ 0xc6f46339, "init_timer_key" },
+	{ 0xae353d77, "arm_copy_from_user" },
+	{ 0x29d9f26e, "cancel_delayed_work_sync" },
+	{ 0x67ea780, "mutex_unlock" },
+	{ 0x85df9b6c, "strsep" },
+	{ 0xb3453dc4, "seq_read" },
+	{ 0xe2d5255a, "strcmp" },
+	{ 0x36c83d86, "input_set_abs_params" },
+	{ 0x666e4db, "input_event" },
+	{ 0xe707d823, "__aeabi_uidiv" },
+	{ 0xec523f88, "hrtimer_start_range_ns" },
+	{ 0x5f754e5a, "memset" },
+	{ 0xe5bd2475, "proc_mkdir" },
+	{ 0x11089ac7, "_ctype" },
+	{ 0xf3d0b495, "_raw_spin_unlock_irqrestore" },
+	{ 0xe346f67a, "__mutex_init" },
+	{ 0xc5850110, "printk" },
+	{ 0x9ec6ca96, "ktime_get_real_ts64" },
+	{ 0x1198ce0c, "of_find_property" },
+	{ 0x73e20c1c, "strlcpy" },
+	{ 0xc271c3be, "mutex_lock" },
+	{ 0x8c03d20c, "destroy_workqueue" },
+	{ 0xe3e779ad, "gpiod_direction_input" },
+	{ 0xc4601133, "input_mt_init_slots" },
+	{ 0x84f696ed, "gpiod_direction_output_raw" },
+	{ 0x92d5838e, "request_threaded_irq" },
+	{ 0x8c8569cb, "kstrtoint" },
+	{ 0x8e865d3c, "arm_delay_ops" },
+	{ 0x703f2486, "devm_kfree" },
+	{ 0x2196324, "__aeabi_idiv" },
+	{ 0xf4cb7bdc, "i2c_register_driver" },
+	{ 0x12a38747, "usleep_range" },
+	{ 0xcf86cdac, "queue_delayed_work_on" },
+	{ 0x86332725, "__stack_chk_fail" },
+	{ 0xa08087d9, "input_register_device" },
+	{ 0x668b595, "_kstrtoul" },
+	{ 0x3452d545, "input_free_device" },
+	{ 0xba69e61c, "of_get_named_gpio_flags" },
+	{ 0xbdd25cf8, "kmem_cache_alloc_trace" },
+	{ 0xde55e795, "_raw_spin_lock_irqsave" },
+	{ 0xfe990052, "gpio_free" },
+	{ 0x2cfde9a2, "warn_slowpath_fmt" },
+	{ 0xdd706452, "seq_lseek" },
+	{ 0xfcec0987, "enable_irq" },
+	{ 0x37a0cba, "kfree" },
+	{ 0x9d669763, "memcpy" },
+	{ 0xddf0885d, "input_unregister_device" },
+	{ 0x224efce8, "gpiod_to_irq" },
+	{ 0xa362bf8f, "hrtimer_init" },
+	{ 0x98365005, "input_mt_report_slot_state" },
+	{ 0xc1b164ca, "request_firmware" },
+	{ 0xb12cbacb, "fb_unregister_client" },
+	{ 0x8f678b07, "__stack_chk_guard" },
+	{ 0x676bbc0f, "_set_bit" },
+	{ 0xb2d48a2e, "queue_work_on" },
+	{ 0xc358aaf8, "snprintf" },
+	{ 0xf799ae1d, "proc_create" },
+	{ 0x2db72154, "gpiod_get_raw_value" },
+	{ 0x85fb927f, "of_property_read_variable_u32_array" },
+	{ 0x2915b3c8, "devm_kmalloc" },
+	{ 0xdf9208c0, "alloc_workqueue" },
+	{ 0xd0e9fb09, "release_firmware" },
+	{ 0xc1514a3b, "free_irq" },
+	{ 0x69b7ddf1, "filp_open" },
+	{ 0xc4ae314c, "input_allocate_device" },
+};
+
+MODULE_INFO(depends, "");
+
+
+MODULE_INFO(srcversion, "19B15D4F0C66FE0FBAB73A7");
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_platform.c linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_platform.c
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_platform.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_platform.c	2024-06-14 10:43:31.785519389 +0200
@@ -0,0 +1,1117 @@
+// SPDX-License-Identifier: GPL-2.0
+/*  Himax Android Driver Sample Code for QCT platform
+ *
+ *  Copyright (C) 2021 Himax Corporation.
+ *
+ *  This software is licensed under the terms of the GNU General Public
+ *  License version 2,  as published by the Free Software Foundation,  and
+ *  may be copied,  distributed,  and modified under those terms.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#include "himax_platform.h"
+#include "himax_common.h"
+
+/*------------------------- define block -------------------------------------*/
+/*------------------------- define block -------------------------------------*/
+/*------------------------- parameter block ----------------------------------*/
+
+static uint8_t *gp_rw_buf;
+static int g_tp_ext_rstn;
+
+/*------------------------- parameter block ----------------------------------*/
+/*------------------------- structure block ----------------------------------*/
+/*------------------------- structure block ----------------------------------*/
+int himax_bus_read(uint8_t command, uint8_t *data, uint32_t length,
+		   uint8_t toRetry);
+int himax_bus_write(uint8_t command, uint8_t *data, uint32_t length,
+		    uint8_t toRetry);
+int himax_bus_read_slave(uint8_t device, uint8_t command, uint8_t *data, uint32_t length,
+		   uint8_t toRetry);
+int himax_bus_write_slave(uint8_t device, uint8_t command, uint8_t *data, uint32_t length,
+		    uint8_t toRetry);
+void himax_int_enable(int enable);
+void himax_fail_det_enable(int enable);
+void himax_gpio_set(int pinnum, uint8_t value);
+uint8_t himax_int_gpio_read(int pinnum);
+int himax_interrupt_gpio_config(struct himax_i2c_platform_data *pdata);
+int himax_gpio_power_config(struct himax_i2c_platform_data *pdata);
+void himax_gpio_power_deconfig(struct himax_i2c_platform_data *pdata);
+irqreturn_t himax_ts_thread(int irq, void *ptr);
+irqreturn_t himax_fail_det_thread(int irq, void *ptr);
+int himax_int_en_set(void);
+int himax_fail_det_register_interrupt(void);
+int himax_ts_register_interrupt(void);
+int himax_ts_unregister_interrupt(void);
+
+#if (HX_RST_PIN_FUNC == 0x01)
+static void himax_tp_ext_rstn_reset(void)
+{
+	if (g_tp_ext_rstn > 0) {
+		gpio_direction_output(g_tp_ext_rstn, 0);
+		msleep(20);
+		gpio_direction_output(g_tp_ext_rstn, 1);
+		msleep(50);
+	} else {
+		E("%s: Invalid TP RST pin control\n", __func__);
+	}
+}
+#endif
+int himax_dev_set(struct himax_ts_data *ts)
+{
+	int ret = 0;
+
+	ts->input_dev = input_allocate_device();
+
+	if (ts->input_dev == NULL) {
+		ret = -ENOMEM;
+		E("%s: Failed to allocate input device-input_dev\n", __func__);
+		return ret;
+	}
+
+	ts->input_dev->name = "himax-touchscreen";
+
+	return ret;
+}
+int himax_input_register_device(struct input_dev *input_dev)
+{
+	return input_register_device(input_dev);
+}
+
+int himax_parse_dt(struct himax_ts_data *ts,
+		   struct himax_i2c_platform_data *pdata)
+{
+	struct device_node *dt = private_ts->client->dev.of_node;
+	u32 data = 0;
+	uint32_t coords[4] = { 0 };
+	int rc = 0;
+	int coords_size = 0;
+	int ret = 0;
+	struct property *prop;
+
+	UNUSED(ts);
+
+	prop = of_find_property(dt, "himax,panel-coords", NULL);
+	if (prop != NULL) {
+		coords_size = prop->length / sizeof(u32);
+		if (coords_size != 4) {
+			D(" %s:Invalid panel coords size %d\n", __func__,
+			  coords_size);
+		}
+	}
+	ret = of_property_read_u32_array(dt, "himax,panel-coords", coords,
+					 coords_size);
+	if (ret == 0) {
+		pdata->abs_x_min = coords[0];
+		pdata->abs_x_max = coords[1];
+		pdata->abs_y_min = coords[2];
+		pdata->abs_y_max = coords[3];
+		I(" DT:panel-coords = %d, %d, %d, %d\n", pdata->abs_x_min,
+		  pdata->abs_x_max, pdata->abs_y_min, pdata->abs_y_max);
+	}
+	prop = of_find_property(dt, "himax,display-coords", NULL);
+	if (prop != NULL) {
+		coords_size = prop->length / sizeof(u32);
+		if (coords_size != 4) {
+			D(" %s:Invalid display coords size %d\n", __func__,
+			  coords_size);
+		}
+	}
+	rc = of_property_read_u32_array(dt, "himax,display-coords", coords,
+					coords_size);
+	if ((rc != 0) && (rc != -EINVAL)) {
+		D(" %s:Fail to read display-coords %d\n", __func__, rc);
+		return rc;
+	}
+	pdata->screenWidth = (uint16_t)coords[1];
+	pdata->screenHeight = (uint16_t)coords[3];
+	I(" DT:display-coords = (%d, %d)\n", pdata->screenWidth,
+	  pdata->screenHeight);
+
+	pdata->TSIX = of_get_named_gpio(dt, "himax,TSIX", 0);
+
+	if (!gpio_is_valid(pdata->TSIX)) {
+		I(" DT:TSIX value is not valid\n");
+	}
+
+	pdata->fail_det = of_get_named_gpio(dt, "himax,FAIL-DET", 0);
+
+	if (!gpio_is_valid(pdata->fail_det)) {
+		I(" DT:FAIL-DET value is not valid\n");
+	}
+
+	pdata->tp_ext_rstn = of_get_named_gpio(dt, "himax,TP-EXT-RSTN", 0);
+	g_tp_ext_rstn = pdata->tp_ext_rstn;
+	if (!gpio_is_valid(pdata->tp_ext_rstn)) {
+		I(" DT:TP-EXT-RSTN value is not valid\n");
+	}
+
+	pdata->PON = of_get_named_gpio(dt, "himax,PON", 0);
+
+	if (!gpio_is_valid(pdata->PON)) {
+		I(" DT:PON value is not valid\n");
+	}
+
+	pdata->RESX = of_get_named_gpio(dt, "himax,RESX", 0);
+
+	if (!gpio_is_valid(pdata->RESX)) {
+		I(" DT:RESX value is not valid\n");
+	}
+
+	I(" DT:PON=%d, RESX=%d\n", pdata->PON, pdata->RESX);
+	I(" DT:TSIX=%d, TP-EXT-RSTN=%d\n", pdata->TSIX, pdata->tp_ext_rstn);
+	I(" DT:FAIL-DET=%d", pdata->fail_det);
+
+	if (of_property_read_u32(dt, "report_type", &data) == 0) {
+		pdata->protocol_type = (uint8_t) data;
+		I(" DT:protocol_type=%d\n", pdata->protocol_type);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(himax_parse_dt);
+
+int himax_bus_read(uint8_t command, uint8_t *data, uint32_t length,
+		   uint8_t toRetry)
+{
+	uint8_t retry;
+	int ret = 0;
+	struct i2c_client *client = private_ts->client;
+	struct i2c_msg msg[] = { {
+					 .addr = client->addr,
+					 .flags = 0,
+					 .len = 1,
+					 .buf = &command,
+				},
+				{
+					 .addr = client->addr,
+					 .flags = I2C_M_RD,
+					 .len = length,
+					 .buf = gp_rw_buf,
+				} };
+	mutex_lock(&private_ts->rw_lock);
+
+	for (retry = 0; retry < toRetry; retry++) {
+		ret = i2c_transfer(client->adapter, msg, 2);
+		if (ret == 2) {
+			(void)memcpy(data, gp_rw_buf, length);
+			break;
+		}
+		/*msleep(20);*/
+	}
+
+	if (retry == toRetry) {
+		E("%s: i2c_read_block retry over %d\n", __func__, toRetry);
+		mutex_unlock(&private_ts->rw_lock);
+#if (HX_RST_PIN_FUNC == 0x01)
+		himax_tp_ext_rstn_reset();
+#endif
+		return -EIO;
+	}
+
+	mutex_unlock(&private_ts->rw_lock);
+	return 0;
+}
+EXPORT_SYMBOL(himax_bus_read);
+
+int himax_bus_write(uint8_t command, uint8_t *data, uint32_t length,
+		    uint8_t toRetry)
+{
+	uint8_t retry;
+	int ret = 0;
+	struct i2c_client *client = private_ts->client;
+	struct i2c_msg msg[] = { {
+		.addr = client->addr,
+		.flags = 0,
+		.len = length + 1U,
+		.buf = gp_rw_buf,
+	} };
+
+	mutex_lock(&private_ts->rw_lock);
+	gp_rw_buf[0] = command;
+	if (data != NULL) {
+		(void)memcpy(&gp_rw_buf[1], data, length);
+	}
+
+	for (retry = 0; retry < toRetry; retry++) {
+		ret = i2c_transfer(client->adapter, msg, 1);
+		if (ret == 1) {
+			break;
+		}
+		msleep(20);
+	}
+
+	if (retry == toRetry) {
+		E("%s: i2c_write_block retry over %d\n", __func__, toRetry);
+		mutex_unlock(&private_ts->rw_lock);
+#if (HX_RST_PIN_FUNC == 0x01)
+		himax_tp_ext_rstn_reset();
+#endif
+		return -EIO;
+	}
+
+	mutex_unlock(&private_ts->rw_lock);
+	return 0;
+}
+EXPORT_SYMBOL(himax_bus_write);
+
+int himax_bus_read_slave(uint8_t device, uint8_t command, uint8_t *data, uint32_t length,
+		   uint8_t toRetry)
+{
+	uint8_t retry;
+	int ret = 0;
+	struct i2c_client *client = private_ts->client;
+	struct i2c_msg msg[] = { {
+					 .addr = (client->addr+device),
+					 .flags = 0,
+					 .len = 1,
+					 .buf = &command,
+				},
+				{
+					 .addr = (client->addr+device),
+					 .flags = I2C_M_RD,
+					 .len = length,
+					 .buf = gp_rw_buf,
+				} };
+	mutex_lock(&private_ts->rw_lock);
+
+	for (retry = 0; retry < toRetry; retry++) {
+		ret = i2c_transfer(client->adapter, msg, 2);
+		if (ret == 2) {
+			(void)memcpy(data, gp_rw_buf, length);
+			break;
+		}
+		/*msleep(20);*/
+	}
+
+	if (retry == toRetry) {
+		if (toRetry == HIMAX_I2C_RETRY_TIMES) {
+			E("%s: i2c_read_block retry over %d\n", __func__, toRetry);
+			mutex_unlock(&private_ts->rw_lock);
+#if (HX_RST_PIN_FUNC == 0x01)
+			himax_tp_ext_rstn_reset();
+#endif
+		} else {
+			mutex_unlock(&private_ts->rw_lock);
+		}
+		return -EIO;
+	}
+
+	mutex_unlock(&private_ts->rw_lock);
+	return 0;
+}
+EXPORT_SYMBOL(himax_bus_read_slave);
+
+int himax_bus_write_slave(uint8_t device, uint8_t command, uint8_t *data, uint32_t length,
+		    uint8_t toRetry)
+{
+	uint8_t retry;
+	int ret = 0;
+	struct i2c_client *client = private_ts->client;
+	struct i2c_msg msg[] = { {
+		.addr = (client->addr+device),
+		.flags = 0,
+		.len = length + 1U,
+		.buf = gp_rw_buf,
+	} };
+
+	mutex_lock(&private_ts->rw_lock);
+	gp_rw_buf[0] = command;
+	if (data != NULL) {
+		(void)memcpy(&gp_rw_buf[1], data, length);
+	}
+
+	for (retry = 0; retry < toRetry; retry++) {
+		ret = i2c_transfer(client->adapter, msg, 1);
+		if (ret == 1) {
+			break;
+		}
+		/*msleep(20);*/
+	}
+
+	if (retry == toRetry) {
+		E("%s: i2c_write_block retry over %d\n", __func__, toRetry);
+		mutex_unlock(&private_ts->rw_lock);
+#if (HX_RST_PIN_FUNC == 0x01)
+		himax_tp_ext_rstn_reset();
+#endif
+		return -EIO;
+	}
+
+	mutex_unlock(&private_ts->rw_lock);
+	return 0;
+}
+EXPORT_SYMBOL(himax_bus_write_slave);
+
+#if defined(Tp_inspect_mode_patch)
+static void himax_mcu_clear_inspect_mode(void)
+{
+	uint8_t cmd_byte[8] = {0x54, 0x74, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00};
+	uint8_t cmd_byte_2[8] = {0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00};
+	uint8_t data_byte[4] = {0xFF, 0xFF, 0xFF, 0xFF};
+	uint8_t i = 0;
+	int ret = 0;
+
+	cmd_byte_2[0] = addr_Tp_inspect_mode_cmd_current & 0xFFU;
+	cmd_byte_2[1] = (addr_Tp_inspect_mode_cmd_current >> 8U) & 0xFFU;
+	cmd_byte_2[2] = (addr_Tp_inspect_mode_cmd_current >> 16U) & 0xFFU;
+	cmd_byte_2[3] = (addr_Tp_inspect_mode_cmd_current >> 24U) & 0xFFU;
+
+	ret = himax_bus_read(0x80, data_byte, 4,
+		HIMAX_I2C_RETRY_TIMES);
+
+	/*inspect mode initial*/
+	do {
+		ret = himax_bus_write(0x00, cmd_byte, 8,
+			HIMAX_I2C_RETRY_TIMES);
+		if (ret < 0) {
+			E("%s: i2c access fail!\n", __func__);
+		}
+		usleep_range(1000, 1100);
+
+		ret = himax_bus_write(0x00, cmd_byte, 4,
+			HIMAX_I2C_RETRY_TIMES);
+		data_byte[0] = 0x00;
+		ret = himax_bus_write(0x0C, data_byte, 1,
+			HIMAX_I2C_RETRY_TIMES);
+		ret = himax_bus_read(0x08, data_byte, 4,
+			HIMAX_I2C_RETRY_TIMES);
+
+		I("%s: addr 10007454: %02X%02X%02X%02X\n", __func__,
+			data_byte[3], data_byte[2], data_byte[1], data_byte[0]);
+
+	} while ((i++ < 28U) && (data_byte[3] != 0U));
+
+	(void)memset(data_byte, 0xFF, 4);
+	i = 0;
+	/*clear addr_Tp_inspect_mode_cmd_current*/
+	do {
+		ret = himax_bus_write(0x00, cmd_byte_2, 8,
+			HIMAX_I2C_RETRY_TIMES);
+		if (ret < 0) {
+			E("%s: i2c access fail!\n", __func__);
+		}
+		usleep_range(1000, 1100);
+
+		ret = himax_bus_write(0x00, cmd_byte_2, 4,
+			HIMAX_I2C_RETRY_TIMES);
+		data_byte[0] = 0x00;
+		ret = himax_bus_write(0x0C, data_byte, 1,
+			HIMAX_I2C_RETRY_TIMES);
+		ret = himax_bus_read(0x08, data_byte, 4,
+			HIMAX_I2C_RETRY_TIMES);
+
+		I("%s: addr %08X: %02X%02X%02X%02X\n", __func__, addr_Tp_inspect_mode_cmd_current,
+			data_byte[3], data_byte[2], data_byte[1], data_byte[0]);
+
+	} while ((i++ < 28U) && (data_byte[3] != 0U));
+
+	I("%s: DONE!\n", __func__);
+}
+#endif
+void himax_int_enable(int enable)
+{
+	struct himax_ts_data *ts = private_ts;
+	unsigned long irqflags = 0;
+	int irqnum = ts->client->irq;
+
+	if (enable == 1) {
+		himax_mcu_clear_event_stack();
+	}
+
+	spin_lock_irqsave(&ts->irq_lock, irqflags);
+	I("%s: Entering!\n", __func__);
+	if ((enable == 1) && (atomic_read(&ts->irq_state) == 0)) {
+		atomic_set(&ts->irq_state, 1);
+		enable_irq(irqnum);
+		private_ts->irq_enabled = true;
+	} else if ((enable == 0) && (atomic_read(&ts->irq_state) == 1)) {
+		atomic_set(&ts->irq_state, 0);
+		disable_irq_nosync(irqnum);
+		private_ts->irq_enabled = false;
+	} else {
+		/* do nothing*/
+	}
+
+	I("enable = %d\n", enable);
+	spin_unlock_irqrestore(&ts->irq_lock, irqflags);
+}
+EXPORT_SYMBOL(himax_int_enable);
+
+void himax_fail_det_enable(int enable)
+{
+	struct himax_ts_data *ts = private_ts;
+	unsigned long faildet_flags = 0;
+
+	spin_lock_irqsave(&ts->fail_det_lock, faildet_flags);
+	I("%s: Entering!\n", __func__);
+	if ((enable == 1) && (atomic_read(&ts->fail_det_state) == 0)) {
+		atomic_set(&ts->fail_det_state, 1);
+		enable_irq(ts->hx_fail_det);
+	} else if ((enable == 0) && (atomic_read(&ts->fail_det_state) == 1)) {
+		atomic_set(&ts->fail_det_state, 0);
+		disable_irq_nosync(ts->hx_fail_det);
+	} else {
+		/* do nothing*/
+	}
+
+	I("enable = %d\n", enable);
+	spin_unlock_irqrestore(&ts->fail_det_lock, faildet_flags);
+}
+EXPORT_SYMBOL(himax_fail_det_enable);
+
+void himax_gpio_set(int pinnum, uint8_t value)
+{
+	gpio_direction_output(pinnum, value);
+}
+EXPORT_SYMBOL(himax_gpio_set);
+
+
+uint8_t himax_int_gpio_read(int pinnum)
+{
+	return gpio_get_value(pinnum);
+}
+
+int himax_interrupt_gpio_config(struct himax_i2c_platform_data *pdata)
+{
+	int ret = 0;
+	struct i2c_client *client = private_ts->client;
+
+	if (gpio_is_valid(pdata->TSIX) != 0) {
+		ret = gpio_request(pdata->TSIX, "TSIX");
+		if (ret != 0) {
+			E("unable to request TSIX [%d]\n", pdata->TSIX);
+			goto err_TSIX_req;
+		}
+		ret = gpio_direction_input(pdata->TSIX);
+		if (ret != 0) {
+			E("unable to set direction for TSIX [%d]\n",
+				pdata->TSIX);
+			goto err_TSIX_set_input;
+		}
+		client->irq = gpio_to_irq(pdata->TSIX);
+		if (client->irq < 0) {
+			E("fail to request IRQ: %d\n", client->irq);
+		}
+		private_ts->hx_irq = client->irq;
+	} else {
+		E("TSIX gpio not provided\n");
+		goto err_TSIX_req;
+	}
+	if (gpio_is_valid(pdata->fail_det) != 0) {
+		ret = gpio_request(pdata->fail_det, "FAIL-DET");
+		if (ret != 0) {
+			E("unable to request FAIL-DET [%d]\n", pdata->fail_det);
+		}
+		ret = gpio_direction_input(pdata->fail_det);
+		if (ret != 0) {
+			E("unable to set direction for FAIL-DET [%d]\n",
+			  pdata->fail_det);
+		}
+		private_ts->hx_fail_det = gpio_to_irq(pdata->fail_det);
+	} else {
+		I("FAIL-DET not provided\n");
+	}
+	return ret;
+
+err_TSIX_set_input:
+	if (gpio_is_valid(pdata->TSIX) != 0) {
+		gpio_free(pdata->TSIX);
+	}
+err_TSIX_req:
+	return ret;
+}
+
+int himax_gpio_power_config(struct himax_i2c_platform_data *pdata)
+{
+	int error = 0;
+
+#if (HX_RST_PIN_FUNC == 0x01)
+	if (pdata->tp_ext_rstn >= 0) {
+		error = gpio_request(pdata->tp_ext_rstn, "tp_ext_rstn");
+
+		if (error < 0) {
+			E("%s: request tp-reset pin failed\n", __func__);
+			goto err_tp_ext_rstn_req;
+		}
+
+		error = gpio_direction_output(pdata->tp_ext_rstn, 0);
+
+		if (error != 0) {
+			E("unable to set direction for tp-reset [%d]\n",
+			  pdata->tp_ext_rstn);
+			goto err_tp_ext_rstn_dir;
+		}
+		usleep_range(10000, 11000);
+		if (gpio_get_value(pdata->tp_ext_rstn) == 1) {
+			E("unable control TP_EXT_RSTN, please check it\n");
+			pdata->g_customer_control_tp_reset = 1;
+		} else {
+			pdata->g_customer_control_tp_reset = 0;
+		}
+	}
+#elif (HX_RST_PIN_FUNC == 0x02)
+	/* Need Customer pull TP reset pin low */
+#endif
+
+	if (pdata->RESX >= 0) {
+		error = gpio_request(pdata->RESX, "RESX");
+
+		if (error < 0) {
+			E("%s: request RESX pin failed\n", __func__);
+			goto err_RESX_req;
+		}
+
+		error = gpio_direction_output(pdata->RESX, 0);
+		if (error != 0) {
+			E("unable to set direction for RESX [%d]\n",
+			  pdata->RESX);
+			goto err_RESX_dir;
+		}
+	}
+
+	if (gpio_is_valid(pdata->PON) != 0) {
+		error = gpio_request(pdata->PON, "PON");
+
+		if (error != 0) {
+			E("unable to request PON [%d]\n", pdata->PON);
+			goto err_PON_req;
+		}
+
+		error = gpio_direction_output(pdata->PON, 0);
+
+		if (error != 0) {
+			E("unable to set direction for PON [%d]\n", pdata->PON);
+			goto err_PON_dir;
+		}
+	}
+
+	usleep_range(6000, 6100);
+
+	if (pdata->RESX >= 0) {
+		error = gpio_direction_output(pdata->RESX, 1);
+
+		if (error != 0) {
+			E("RESX unable to set direction for RESX [%d]\n",
+			  pdata->RESX);
+			goto err_lcm_reset_set_high;
+		}
+	}
+	usleep_range(1000, 1100);
+
+#if (HX_RST_PIN_FUNC == 0x01)
+
+	if (pdata->tp_ext_rstn >= 0) {
+		error = gpio_direction_output(pdata->tp_ext_rstn, 1);
+
+		if (error != 0) {
+			E("unable to set direction for tp_ext_rstn [%d]\n",
+			  pdata->tp_ext_rstn);
+			goto err_tp_ext_rstn_set_high;
+		}
+	}
+#elif (HX_RST_PIN_FUNC == 0x02)
+	/* Need Customer pull TP reset pin high */
+#endif
+#if defined(Tp_inspect_mode_patch)
+	himax_mcu_clear_inspect_mode();
+#endif
+	msleep(95);
+
+	if (gpio_is_valid(pdata->PON) != 0) {
+		error = gpio_direction_output(pdata->PON, 1);
+
+		if (error != 0) {
+			E("PON unable to set direction for PON [%d]\n",
+			  pdata->PON);
+			goto err_PON_set_high;
+		}
+	}
+	I("%s: DONE!\n", __func__);
+	return error;
+
+err_PON_set_high:
+#if (HX_RST_PIN_FUNC == 0x01)
+err_tp_ext_rstn_set_high:
+#endif
+err_lcm_reset_set_high:
+err_PON_dir:
+	if (gpio_is_valid(pdata->PON) != 0) {
+		gpio_free(pdata->PON);
+	}
+err_PON_req:
+err_RESX_dir:
+	if (gpio_is_valid(pdata->RESX) != 0) {
+		gpio_free(pdata->RESX);
+	}
+err_RESX_req:
+
+#if (HX_RST_PIN_FUNC == 0x01)
+err_tp_ext_rstn_dir:
+	if (pdata->tp_ext_rstn >= 0) {
+		gpio_free(pdata->tp_ext_rstn);
+	}
+err_tp_ext_rstn_req:
+#endif
+	return error;
+}
+
+void himax_gpio_power_deconfig(struct himax_i2c_platform_data *pdata)
+{
+	int error = 0;
+
+	if (gpio_is_valid(pdata->PON) != 0) {
+		error = gpio_direction_output(pdata->PON, 0);
+
+		if (error != 0) {
+			E("unable to set direction for PON [%d]\n", pdata->PON);
+		}
+	}
+
+#if (HX_RST_PIN_FUNC == 0x01)
+	if (pdata->tp_ext_rstn >= 0) {
+		error = gpio_direction_output(pdata->tp_ext_rstn, 0);
+
+		if (error != 0) {
+			E("unable to set direction for tp-reset [%d]\n",
+			  pdata->tp_ext_rstn);
+		}
+	}
+#elif (HX_RST_PIN_FUNC == 0x02)
+	/* Need Customer pull TP reset pin low */
+#endif
+
+	if (pdata->RESX >= 0) {
+		error = gpio_direction_output(pdata->RESX, 0);
+		if (error != 0) {
+			E("unable to set direction for RESX [%d]\n",
+			  pdata->RESX);
+		}
+	}
+
+	if (gpio_is_valid(pdata->TSIX) != 0) {
+		gpio_free(pdata->TSIX);
+	}
+	if (gpio_is_valid(pdata->fail_det) != 0) {
+		gpio_free(pdata->fail_det);
+	}
+#if (HX_RST_PIN_FUNC == 0x01)
+	if (gpio_is_valid(pdata->tp_ext_rstn) != 0) {
+		gpio_free(pdata->tp_ext_rstn);
+	}
+#endif
+	if (gpio_is_valid(pdata->PON) != 0) {
+		gpio_free(pdata->PON);
+	}
+	if (gpio_is_valid(pdata->RESX) != 0) {
+		gpio_free(pdata->RESX);
+	}
+}
+
+static void himax_ts_isr_func(struct himax_ts_data *ts)
+{
+	himax_ts_work(ts);
+}
+
+irqreturn_t himax_ts_thread(int irq, void *ptr)
+{
+	UNUSED(irq);
+
+	himax_ts_isr_func((struct himax_ts_data *)ptr);
+
+	return IRQ_HANDLED;
+}
+
+void himax_ts_work_func(struct work_struct *work)
+{
+	struct himax_ts_data *ts =
+		container_of(work, struct himax_ts_data, work);
+
+	himax_ts_work(ts);
+}
+
+irqreturn_t himax_fail_det_thread(int irq, void *ptr)
+{
+	UNUSED(irq);
+	UNUSED(ptr);
+
+	himax_fail_det_work();
+
+	return IRQ_HANDLED;
+}
+
+static int himax_int_register_trigger(void)
+{
+	int ret = 0;
+	struct himax_ts_data *ts = private_ts;
+	struct i2c_client *client = private_ts->client;
+
+	if (ic_data->HX_INT_IS_EDGE) {
+		I("%s edge trigger falling\n", __func__);
+		ret = request_threaded_irq(client->irq, NULL, himax_ts_thread,
+					   IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+					   client->name, ts);
+	} else {
+		I("%s level trigger low\n", __func__);
+		ret = request_threaded_irq(client->irq, NULL, himax_ts_thread,
+					   IRQF_TRIGGER_LOW | IRQF_ONESHOT,
+					   client->name, ts);
+	}
+
+	return ret;
+}
+
+static int himax_fail_det_int_register_trigger(void)
+{
+	int ret = 0;
+	struct himax_ts_data *ts = private_ts;
+	const char *hx_fail_det_name = "hx_fail_det";
+
+	I("%s edge trigger rising\n", __func__);
+	ret = request_threaded_irq(ts->hx_fail_det, NULL, himax_fail_det_thread,
+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT,
+				   hx_fail_det_name, (void *)0);
+
+	return ret;
+}
+
+int himax_int_en_set(void)
+{
+	int ret = NO_ERR;
+
+	ret = himax_int_register_trigger();
+	return ret;
+}
+
+int himax_fail_det_register_interrupt(void)
+{
+	int ret = 0;
+	struct himax_ts_data *ts = private_ts;
+
+	if (ts->hx_fail_det > 0) {
+		ret = himax_fail_det_int_register_trigger();
+
+		if (ret == 0) {
+			atomic_set(&ts->fail_det_state, 1);
+			I("%s: fail_det enabled at gpio: %d\n", __func__,
+			  ts->hx_fail_det);
+		} else {
+			E("%s: request fail_det failed\n", __func__);
+		}
+
+	} else {
+		I("%s: hx_fail_det is empty.\n", __func__);
+	}
+
+	return ret;
+}
+
+int himax_ts_register_interrupt(void)
+{
+	struct himax_ts_data *ts = private_ts;
+	struct i2c_client *client = private_ts->client;
+	int ret = 0;
+
+	ts->irq_enabled = false;
+
+	/* Work functon */
+	if (client->irq && (private_ts->hx_irq > 0)) { /*INT mode*/
+		ts->use_irq = true;
+		ret = himax_int_register_trigger();
+
+		if (ret == 0) {
+			ts->irq_enabled = true;
+			atomic_set(&ts->irq_state, 1);
+			I("%s: irq enabled at gpio: %d\n", __func__,
+			  client->irq);
+		} else {
+			ts->use_irq = false;
+			E("%s: request_irq failed\n", __func__);
+		}
+	} else {
+		I("%s: client->irq is empty, use polling mode.\n", __func__);
+	}
+
+	/*if use polling mode need to disable HX_ESD_RECOVERY function*/
+	if (!ts->use_irq) {
+		ts->himax_wq = create_singlethread_workqueue("himax_touch");
+		INIT_WORK(&ts->work, himax_ts_work_func);
+		hrtimer_init(&ts->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+		ts->timer.function = himax_ts_timer_func;
+		hrtimer_start(&ts->timer, ktime_set(1, 0), HRTIMER_MODE_REL);
+		I("%s: polling mode enabled\n", __func__);
+	}
+
+	return ret;
+}
+
+int himax_ts_unregister_interrupt(void)
+{
+	struct himax_ts_data *ts = private_ts;
+	int ret = 0;
+
+	I("%s: entered.\n", __func__);
+
+	/* Work functon */
+	if ((private_ts->hx_irq > 0) && ts->use_irq) { /*INT mode*/
+
+		free_irq(ts->hx_irq, ts);
+		I("%s: irq disabled at qpio: %d\n", __func__,
+		  private_ts->hx_irq);
+	}
+	if (ts->hx_fail_det > 0) {
+		free_irq(ts->hx_fail_det, NULL);
+		I("%s: irq disabled at qpio: %d\n", __func__, ts->hx_fail_det);
+	}
+	/*if use polling mode need to disable HX_ESD_RECOVERY function*/
+	if (!ts->use_irq) {
+		hrtimer_cancel(&ts->timer);
+		cancel_work_sync(&ts->work);
+		if (ts->himax_wq != NULL) {
+			destroy_workqueue(ts->himax_wq);
+		}
+		I("%s: polling mode destroyed", __func__);
+	}
+
+	return ret;
+}
+
+void himax_common_suspend(struct device *dev)
+{
+	struct himax_ts_data *ts = dev_get_drvdata(dev);
+
+	I("%s: enter\n", __func__);
+#if defined(HX_CONFIG_DRM) && !defined(HX_CONFIG_FB)
+	if (!ts->initialized) {
+		return;
+	}
+#endif
+	himax_chip_common_suspend(ts);
+}
+
+void himax_common_resume(struct device *dev)
+{
+	struct himax_ts_data *ts = dev_get_drvdata(dev);
+
+	I("%s: enter\n", __func__);
+#if defined(HX_CONFIG_DRM) && !defined(HX_CONFIG_FB)
+	/*
+	 *	wait until device resume for TDDI
+	 *	TDDI: Touch and display Driver IC
+	 */
+	if (!ts->initialized) {
+		if (himax_chip_common_init() != 0) {
+			return;
+		}
+	}
+#endif
+	himax_chip_common_resume(ts);
+}
+
+#if defined(HX_CONFIG_FB)
+int fb_notifier_callback(struct notifier_block *self, unsigned long event,
+			 void *data)
+{
+	struct fb_event *evdata = data;
+	int *blank;
+	struct himax_ts_data *ts =
+		container_of(self, struct himax_ts_data, fb_notif);
+
+	I(" %s\n", __func__);
+
+	if (evdata && evdata->data && (event == FB_EVENT_BLANK) && ts &&
+	    ts->client) {
+		blank = evdata->data;
+
+		switch (*blank) {
+		case FB_BLANK_UNBLANK:
+			himax_common_resume(&ts->client->dev);
+			break;
+		case FB_BLANK_POWERDOWN:
+		case FB_BLANK_HSYNC_SUSPEND:
+		case FB_BLANK_VSYNC_SUSPEND:
+		case FB_BLANK_NORMAL:
+			himax_common_suspend(&ts->client->dev);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+#elif defined(HX_CONFIG_DRM)
+int drm_notifier_callback(struct notifier_block *self, unsigned long event,
+			  void *data)
+{
+	struct msm_drm_notifier *evdata = data;
+	int *blank;
+	struct himax_ts_data *ts =
+		container_of(self, struct himax_ts_data, fb_notif);
+
+	if (!evdata || (evdata->id != 0)) {
+		return 0;
+	}
+
+	D("DRM  %s\n", __func__);
+
+	if (evdata->data && (event == MSM_DRM_EARLY_EVENT_BLANK) && ts &&
+	    ts->client) {
+		blank = evdata->data;
+		switch (*blank) {
+		case MSM_DRM_BLANK_POWERDOWN:
+			if (!ts->initialized) {
+				return -ECANCELED;
+			}
+			himax_common_suspend(&ts->client->dev);
+			break;
+		default:
+			break;
+		}
+	}
+
+	if (evdata->data && (event == MSM_DRM_EVENT_BLANK) && ts && ts->client) {
+		blank = evdata->data;
+		switch (*blank) {
+		case MSM_DRM_BLANK_UNBLANK:
+			himax_common_resume(&ts->client->dev);
+			break;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+#endif
+
+int himax_chip_common_probe(struct i2c_client *client,
+			    const struct i2c_device_id *id)
+{
+	int ret = 0;
+	struct himax_ts_data *ts;
+
+	UNUSED(id);
+
+	gp_rw_buf = kcalloc(BUS_RW_MAX_LEN, sizeof(uint8_t), GFP_KERNEL);
+	if (gp_rw_buf == NULL) {
+		E("Allocate I2C RW Buffer failed\n");
+		ret = -ENODEV;
+		goto err_alloc_rw_buf_failed;
+	}
+
+	/* Check I2C functionality */
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		E("%s: i2c check functionality error\n", __func__);
+		ret = -ENODEV;
+		goto err_i2c_functionality_failed;
+	}
+
+	ts = kzalloc(sizeof(struct himax_ts_data), GFP_KERNEL);
+	if (ts == NULL) {
+		E("%s: allocate himax_ts_data failed\n", __func__);
+		ret = -ENOMEM;
+		goto err_alloc_data_failed;
+	}
+
+	i2c_set_clientdata(client, ts);
+	ts->client = client;
+	ts->dev = &client->dev;
+	mutex_init(&ts->rw_lock);
+	private_ts = ts;
+
+	I("%s: %d-bit I2C address: 0x%02hx\n", __func__,
+	  (client->flags & I2C_CLIENT_TEN) ? 10 : 7, client->addr);
+
+	ts->initialized = false;
+	ret = himax_chip_common_init();
+	if (ret < 0) {
+		goto err_common_init_failed;
+	}
+
+	return ret;
+
+err_common_init_failed:
+	kfree(ts);
+	ts = NULL;
+err_alloc_data_failed:
+err_i2c_functionality_failed:
+	kfree(gp_rw_buf);
+	gp_rw_buf = NULL;
+err_alloc_rw_buf_failed:
+
+	return ret;
+}
+
+#if !defined(KERNEL_VER_6_01)
+int himax_chip_common_remove(struct i2c_client *client)
+#else
+void himax_chip_common_remove(struct i2c_client *client)
+#endif
+{
+    UNUSED(client);
+
+    if (g_hx_chip_inited == true) {
+        himax_chip_common_deinit();
+    }
+
+    kfree(gp_rw_buf);
+    gp_rw_buf = NULL;
+#if !defined(KERNEL_VER_6_01)
+    return 0;
+#endif
+}
+
+static const struct i2c_device_id himax_common_ts_id[] = { { HIMAX_common_NAME,
+							     0 },
+							   {} };
+
+#if defined(CONFIG_OF)
+static const struct of_device_id himax_match_table[] = {
+	{ .compatible = "himax,hxcommon" },
+	{},
+};
+#else
+#define himax_match_table NULL
+#endif
+
+static struct i2c_driver himax_common_driver = {
+	.id_table	= himax_common_ts_id,
+	.probe		= himax_chip_common_probe,
+	.remove		= himax_chip_common_remove,
+	.driver		= {
+		.name = HIMAX_common_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table = himax_match_table,
+	},
+};
+
+int __init himax_common_init(void)
+{
+	I("Himax common touch panel driver init\n");
+	if (g_mmi_refcnt > 0U) {
+		I("Himax driver has been loaded! ignoring....\n");
+		return 0;
+	} else {
+		I("Himax driver loading...\n");
+		g_mmi_refcnt = 1U;
+	}
+	i2c_add_driver(&himax_common_driver);
+
+	return 0;
+}
+
+void __exit himax_common_exit(void)
+{
+	i2c_del_driver(&himax_common_driver);
+}
+
+module_init(himax_common_init);
+module_exit(himax_common_exit);
+
+MODULE_DESCRIPTION("Himax_common driver");
+MODULE_LICENSE("GPL");
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_platform.h linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_platform.h
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_platform.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_platform.h	2024-06-14 10:43:31.785519389 +0200
@@ -0,0 +1,111 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*  Himax Android Driver Sample Code for QCT platform
+ *
+ *  Copyright (C) 2024 Himax Corporation.
+ *
+ *  This software is licensed under the terms of the GNU General Public
+ *  License version 2,  as published by the Free Software Foundation,  and
+ *  may be copied,  distributed,  and modified under those terms.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef HIMAX_PLATFORM_H
+#define HIMAX_PLATFORM_H
+
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/gpio.h>
+#include <linux/types.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+
+struct himax_i2c_platform_data {
+	uint32_t abs_x_min;
+	uint32_t abs_x_max;
+	uint32_t abs_x_fuzz;
+	uint32_t abs_y_min;
+	uint32_t abs_y_max;
+	uint32_t abs_y_fuzz;
+	uint32_t abs_pressure_min;
+	uint32_t abs_pressure_max;
+	uint32_t abs_pressure_fuzz;
+	uint32_t abs_width_min;
+	uint32_t abs_width_max;
+	uint16_t screenWidth;
+	uint16_t screenHeight;
+	uint8_t protocol_type;
+	int TSIX;
+	int fail_det;
+	int tp_ext_rstn;
+	int PON;
+	int RESX;
+	int (*power)(int on);
+	void (*reset)(void);
+	int g_customer_control_tp_reset;
+};
+
+#define HIMAX_I2C_PLATFORM
+#define HIMAX_I2C_RETRY_TIMES 3U
+#define BUS_RW_MAX_LEN 256
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_DEBUG)
+#define D(x...) pr_info("[HXTP][DEBUG] " x)
+#define I(x...) pr_info("[HXTP] " x)
+#define W(x...) pr_warn("[HXTP][WARNING] " x)
+#define E(x...) pr_err("[HXTP][ERROR] " x)
+#define DIF(x...)                                                              \
+	do {                                                                   \
+		if (debug_flag)                                                \
+			pr_debug("[HXTP][DEBUG] " x)                           \
+	} while (0)
+#else
+
+#define D(x...)
+#define I(x...)
+#define W(x...)
+#define E(x...)
+#define DIF(x...)
+#endif
+
+#define HIMAX_common_NAME "himax_tp"
+#define INPUT_DEV_NAME "himax-touchscreen"
+
+extern int himax_bus_read(uint8_t command, uint8_t *data, uint32_t length,
+			  uint8_t toRetry);
+extern int himax_bus_write(uint8_t command, uint8_t *data, uint32_t length,
+			   uint8_t toRetry);
+extern int himax_bus_read_slave(uint8_t device, uint8_t command, uint8_t *data, uint32_t length,
+			  uint8_t toRetry);
+extern int himax_bus_write_slave(uint8_t device, uint8_t command, uint8_t *data, uint32_t length,
+			   uint8_t toRetry);
+extern void himax_int_enable(int enable);
+extern void himax_fail_det_enable(int enable);
+extern int himax_ts_register_interrupt(void);
+extern int himax_fail_det_register_interrupt(void);
+extern int himax_gpio_power_config(struct himax_i2c_platform_data *pdata);
+extern int himax_interrupt_gpio_config(struct himax_i2c_platform_data *pdata);
+#if defined(HX_CONFIG_FB)
+extern int fb_notifier_callback(struct notifier_block *self,
+				unsigned long event, void *data);
+#elif defined(HX_CONFIG_DRM)
+extern int drm_notifier_callback(struct notifier_block *self,
+				 unsigned long event, void *data);
+#endif
+extern void himax_fail_det_work(void);
+extern enum hrtimer_restart himax_ts_timer_func(struct hrtimer *timer);
+extern int himax_chip_common_init(void);
+extern void himax_chip_common_deinit(void);
+extern void himax_gpio_set(int pinnum, uint8_t value);
+extern int himax_int_en_set(void);
+extern int himax_ts_unregister_interrupt(void);
+uint8_t himax_int_gpio_read(int pinnum);
+void himax_gpio_power_deconfig(struct himax_i2c_platform_data *pdata);
+irqreturn_t himax_ts_thread(int irq, void *ptr);
+irqreturn_t himax_fail_det_thread(int irq, void *ptr);
+
+
+#endif
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_self_test.c linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_self_test.c
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_self_test.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_self_test.c	2024-06-14 10:43:31.785519389 +0200
@@ -0,0 +1,2035 @@
+// SPDX-License-Identifier: GPL-2.0
+/*  Himax Android Driver Sample Code for self_test functions
+ *
+ *  Copyright (C) 2024 Himax Corporation.
+ *
+ *  This software is licensed under the terms of the GNU General Public
+ *  License version 2,  as published by the Free Software Foundation,  and
+ *  may be copied,  distributed,  and modified under those terms.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#include "himax_self_test.h"
+#include "himax_common.h"
+
+/*------------------------- define block -------------------------------------*/
+/*------------------------- define block -------------------------------------*/
+/*------------------------- parameter block ----------------------------------*/
+
+static uint32_t g_dc_max;
+static unsigned int g_1kind_raw_size;
+static int NOISEMAX;
+static int g_recal_thx;
+static int arraydata_max1;
+static int arraydata_max2;
+static int arraydata_max3;
+static int arraydata_min1;
+static int arraydata_min2;
+static int arraydata_min3;
+
+char *g_rslt_data;
+static uint32_t g_rslt_data_len;
+static int16_t **g_self_test_criteria;
+static int *g_inspt_crtra_flag;
+static bool *g_test_item_flag;
+static unsigned int HX_CRITERIA_ITEM;
+static unsigned int HX_CRITERIA_SIZE;
+static bool file_w_flag;
+static char *g_file_path;
+static char *g_start_log;
+static uint32_t block_num;
+static uint32_t mutual_block_num;
+static uint32_t self_block_num;
+
+/*Need to map THP_self_test_ENUM*/
+static char *g_himax_self_test_mode[] = { "HIMAX_OPEN",	"HIMAX_MICRO_OPEN",
+				   "HIMAX_SHORT",	"HIMAX_WEIGHT_NOISE", "HIMAX_NOISE",
+				   "HIMAX_RAWDATA",	"HIMAX_BPN_RAWDATA",
+				   "HIMAX_SBP_RAWDATA",	"HIMAX_SC",
+				   "HIMAX_SORTING",	"HIMAX_GAPTEST_RAW",
+				   "HIMAX_BACK_NORMAL",	NULL };
+
+/* for criteria */
+static char *g_hx_inspt_crtra_name[] = {
+	"CRITERIA_RAW_MIN",	"CRITERIA_RAW_MAX",
+	"CRITERIA_RAW_BPN_MIN",	"CRITERIA_RAW_BPN_MAX",
+	"CRITERIA_RAW_SBP_MIN",	"CRITERIA_RAW_SBP_MAX",
+	"CRITERIA_SC_MIN",	"CRITERIA_SC_MAX",
+	"CRITERIA_SC_GOLDEN",	"CRITERIA_SHORT_MIN",
+	"CRITERIA_SHORT_MAX",	"CRITERIA_OPEN_MIN",
+	"CRITERIA_OPEN_MAX",	"CRITERIA_MICRO_OPEN_MIN",
+	"CRITERIA_MICRO_OPEN_MAX",	"CRITERIA_NOISE_WT_MIN",
+	"CRITERIA_NOISE_WT_MAX",	"CRITERIA_NOISE_MIN",
+	"CRITERIA_NOISE_MAX",	"CRITERIA_SORT_MIN",
+	"CRITERIA_SORT_MAX",	NULL
+};
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+static char *default_item_and_criteria[] = {
+	"CRITERIA_RAW_MIN:NULL",	"CRITERIA_RAW_MAX:NULL",
+	"CRITERIA_RAW_BPN_MIN:NULL",	"CRITERIA_RAW_BPN_MAX:NULL",
+	"CRITERIA_RAW_SBP_MIN:NULL",	"CRITERIA_RAW_SBP_MAX:NULL",
+	"CRITERIA_SC_MIN:NULL",	"CRITERIA_SC_MAX:NULL",
+	"CRITERIA_SC_GOLDEN:NULL",
+	"CRITERIA_SHORT_MIN:0",	"CRITERIA_SHORT_MAX:100",
+	"CRITERIA_OPEN_MIN:50",	"CRITERIA_OPEN_MAX:500",
+	"CRITERIA_MICRO_OPEN_MIN:0",	"CRITERIA_MICRO_OPEN_MAX:100",
+	"CRITERIA_NOISE_WT_MIN:NULL",	"CRITERIA_NOISE_WT_MAX:NULL",
+	"CRITERIA_NOISE_MIN:NULL",	"CRITERIA_NOISE_MAX:NULL",
+	"CRITERIA_SORT_MIN:NULL",	"CRITERIA_SORT_MAX:NULL",
+	NULL
+};
+#else
+static char *default_item_and_criteria[] = {
+	"CRITERIA_RAW_MIN:NULL",	"CRITERIA_RAW_MAX:NULL",
+	"CRITERIA_RAW_BPN_MIN:5",	"CRITERIA_RAW_BPN_MAX:65",
+	"CRITERIA_RAW_SBP_MIN:20",	"CRITERIA_RAW_SBP_MAX:90",
+	"CRITERIA_SC_MIN:NULL",	"CRITERIA_SC_MAX:NULL",
+	"CRITERIA_SC_GOLDEN:NULL",
+	"CRITERIA_SHORT_MIN:0",	"CRITERIA_SHORT_MAX:100",
+	"CRITERIA_OPEN_MIN:50",	"CRITERIA_OPEN_MAX:500",
+	"CRITERIA_MICRO_OPEN_MIN:0",	"CRITERIA_MICRO_OPEN_MAX:100",
+	"CRITERIA_NOISE_WT_MIN:NULL",	"CRITERIA_NOISE_WT_MAX:NULL",
+	"CRITERIA_NOISE_MIN:-80",	"CRITERIA_NOISE_MAX:250",
+	"CRITERIA_SORT_MIN:NULL",	"CRITERIA_SORT_MAX:NULL",
+	NULL
+};
+#endif
+/*------------------------- parameter block ----------------------------------*/
+/*------------------------- structure block ----------------------------------*/
+/*------------------------- structure block ----------------------------------*/
+static void himax_get_arraydata_edge(int16_t *RAW)
+{
+	int temp;
+	int *ArrayData;
+	uint32_t i;
+	uint32_t j;
+	uint32_t len = (uint32_t)ic_data->HX_RX_NUM
+					* (uint32_t)ic_data->HX_TX_NUM;
+
+	ArrayData = kcalloc(len, sizeof(int), GFP_KERNEL);
+	if (ArrayData == NULL) {
+		E("%s: allocate ArrayData failed\n", __func__);
+		return;
+	}
+
+	for (i = 0; i < len; i++) {
+		ArrayData[i] = RAW[i];
+	}
+	for (j = len - 1U; j > 0U; j--) { /*min to max*/
+		for (i = 0; i < j; i++) {
+			if (ArrayData[i] > ArrayData[i + 1U]) {
+				temp = ArrayData[i];
+				ArrayData[i] = ArrayData[i + 1U];
+				ArrayData[i + 1U] = temp;
+			}
+		}
+	}
+
+	arraydata_min1 = ArrayData[0];
+	arraydata_min2 = ArrayData[1];
+	arraydata_min3 = ArrayData[2];
+	arraydata_max1 = ArrayData[len - 3U];
+	arraydata_max2 = ArrayData[len - 2U];
+	arraydata_max3 = ArrayData[len - 1U];
+
+	kfree(ArrayData);
+	ArrayData = NULL;
+}
+
+static void hx_test_data_get(int16_t RAW[], char *start_log, char *result,
+			    int now_item)
+{
+	int len = 0;
+	char *testdata = NULL;
+	int SZ_SIZE = (int) g_1kind_raw_size;
+	uint32_t i;
+
+	I("%s: Entering, Now type=%s!\n", __func__,
+	  g_himax_self_test_mode[now_item]);
+
+	testdata = kzalloc(sizeof(char) * g_1kind_raw_size, GFP_KERNEL);
+	if (testdata == NULL) {
+		E("%s: Memory allocation falied!\n", __func__);
+		return;
+	}
+
+	len += snprintf(&testdata[len], SZ_SIZE - len, "%s", start_log);
+
+	for (i = 0; i < block_num; i++) {
+		if (i < mutual_block_num) {
+			if ((i > 1U) && (((i + 1U) % (uint32_t)ic_data->HX_RX_NUM) == 0U)) {
+				len += snprintf(&testdata[len], SZ_SIZE - len,
+						"%5d,\n", RAW[i]);
+			} else {
+				len += snprintf(&testdata[len], SZ_SIZE - len, "%5d,",
+						RAW[i]);
+			}
+		} else {
+			if (i == mutual_block_num) {
+				len += snprintf(&testdata[len], SZ_SIZE - len, "Self_RX:");
+			} else if (i == (mutual_block_num + (uint32_t)ic_data->HX_RX_NUM)) {
+				len += snprintf(&testdata[len], SZ_SIZE - len, "\nSelf_TX:");
+			}  else {
+				/* do nothing*/
+			}
+			len += snprintf(&testdata[len], SZ_SIZE - len, "%5d,",
+						RAW[i]);
+		}
+	}
+
+	len += snprintf(&testdata[len], SZ_SIZE - len, "\n%s", result);
+	(void)memcpy(&g_rslt_data[0], testdata, len);
+	g_rslt_data_len = (uint32_t)len;
+	I("%s: g_rslt_data_len=%d!\n", __func__, g_rslt_data_len);
+
+	/* dbg */
+	/* for(i = 0; i < SZ_SIZE; i++)
+	 * {
+	 *	I("0x%04X, ", g_rslt_data[i + (now_item * SZ_SIZE)]);
+	 *	if(i > 0 && (i % 16 == 15))
+	 *		PI("\n");
+	 * }
+	 */
+
+	kfree(testdata);
+	testdata = NULL;
+
+	return;
+}
+
+static void himax_switch_mode_self_test(uint8_t mode)
+{
+	uint8_t tmp_data[4] = { 0 };
+
+	I("%s: Entering\n", __func__);
+
+	/*Stop Handshaking*/
+	himax_mcu_stop_DSRAM_output();
+
+	/*Swtich Mode*/
+	switch (mode) {
+	case HX_SORTING:
+		tmp_data[3] = 0x00;
+		tmp_data[2] = 0x00;
+		tmp_data[1] = PWD_SORTING_START;
+		tmp_data[0] = PWD_SORTING_START;
+		break;
+	case HX_OPEN:
+		tmp_data[3] = 0x00;
+		tmp_data[2] = 0x00;
+		tmp_data[1] = PWD_OPEN_START;
+		tmp_data[0] = PWD_OPEN_START;
+		break;
+	case HX_MICRO_OPEN:
+		tmp_data[3] = 0x00;
+		tmp_data[2] = 0x00;
+		tmp_data[1] = PWD_MICRO_OPEN_START;
+		tmp_data[0] = PWD_MICRO_OPEN_START;
+		break;
+	case HX_SHORT:
+		tmp_data[3] = 0x00;
+		tmp_data[2] = 0x00;
+		tmp_data[1] = PWD_SHORT_START;
+		tmp_data[0] = PWD_SHORT_START;
+		break;
+
+	case HX_GAPTEST_RAW:
+	case HX_RAWDATA:
+	case HX_BPN_RAWDATA:
+	case HX_SBP_RAWDATA:
+	case HX_SC:
+		tmp_data[3] = 0x00;
+		tmp_data[2] = 0x00;
+		tmp_data[1] = PWD_RAWDATA_START;
+		tmp_data[0] = PWD_RAWDATA_START;
+		break;
+
+	case HX_WT_NOISE:
+	case HX_NOISE:
+		tmp_data[3] = 0x00;
+		tmp_data[2] = 0x00;
+		tmp_data[1] = PWD_NOISE_START;
+		tmp_data[0] = PWD_NOISE_START;
+		break;
+
+	default:
+		I("%s,Nothing to be done!\n", __func__);
+		break;
+	}
+
+	himax_mcu_assign_sorting_mode(tmp_data);
+	I("%s: End of setting!\n", __func__);
+
+}
+
+static uint32_t himax_get_rawdata(int16_t RAW[], uint32_t datalen)
+{
+	uint8_t *tmp_rawdata;
+	bool get_raw_rlst;
+	uint8_t retry = 0;
+	uint16_t tmp_val = 0;
+	uint32_t i = 0;
+	uint32_t j = 0;
+	uint32_t index = 0;
+	int32_t Min_DATA = 0x7FFFFFFF;
+	int32_t Max_DATA = 0x00000000;
+
+	/* We use two bytes to combine a value of rawdata.*/
+	tmp_rawdata = kzalloc(sizeof(uint8_t) * (datalen * 2U), GFP_KERNEL);
+	if (tmp_rawdata == NULL) {
+		E("%s: Memory allocation falied!\n", __func__);
+		return HX_INSP_MEMALLCTFAIL;
+	}
+
+	while (retry < 200U) {
+		get_raw_rlst = g_core_fp.fp_get_DSRAM_data(tmp_rawdata);
+		if (get_raw_rlst) {
+			break;
+		}
+		retry += 1U;
+	}
+
+	if (retry >= 200U) {
+		goto DIRECT_END;
+	}
+
+	/* Copy Data*/
+	for (i = 0; i < block_num; i++) {
+		tmp_val = ((uint16_t)tmp_rawdata[(i * 2U) + 1U] * 256U)
+					+ (uint16_t)tmp_rawdata[i * 2U];
+		RAW[i + index] = (int16_t)tmp_val;
+	}
+
+	if ((private_ts->debug_log_level & BIT(3)) != 0U) {
+		for (j = 0; j < ic_data->HX_RX_NUM; j++) {
+			if (j == 0U) {
+				I("      RX%2d", j + 1U);
+			} else {
+				PI("  RX%2d", j + 1U);
+			}
+		}
+		I("\n");
+
+		for (i = 0; i < (uint32_t)ic_data->HX_TX_NUM; i++) {
+			if ((private_ts->debug_log_level & BIT(3)) != 0U) {
+				I("TX%2d", i + 1U);
+			}
+			for (j = 0; j < (uint32_t)ic_data->HX_RX_NUM; j++) {
+				if ((private_ts->debug_log_level & BIT(3)) != 0U) {
+					PI("%5d ", RAW[index]);
+				}
+				if (RAW[index] > Max_DATA) {
+					Max_DATA = RAW[index];
+				}
+				if (RAW[index] < Min_DATA) {
+					Min_DATA = RAW[index];
+				}
+
+				index++;
+			}
+			if ((private_ts->debug_log_level & BIT(3)) != 0U) {
+				PI("\n");
+			}
+		}
+		I("Max = %5d, Min = %5d\n", Max_DATA, Min_DATA);
+	}
+
+DIRECT_END:
+	kfree(tmp_rawdata);
+	tmp_rawdata = NULL;
+
+	if (get_raw_rlst) {
+		return HX_INSP_OK;
+	} else {
+		return HX_INSP_EGETRAW;
+	}
+}
+
+static void himax_switch_data_type(uint8_t checktype)
+{
+	uint8_t datatype = 0x00;
+
+	switch (checktype) {
+	case HX_SORTING:
+		datatype = DATA_SORTING;
+		break;
+	case HX_OPEN:
+		datatype = DATA_OPEN;
+		break;
+	case HX_MICRO_OPEN:
+		datatype = DATA_MICRO_OPEN;
+		break;
+	case HX_SHORT:
+		datatype = DATA_SHORT;
+		break;
+	case HX_RAWDATA:
+	case HX_BPN_RAWDATA:
+	case HX_SC:
+	case HX_GAPTEST_RAW:
+		datatype = DATA_RAWDATA;
+		break;
+	case HX_SBP_RAWDATA:
+		datatype = DATA_Self_test_RAWDATA;
+		break;
+	case HX_WT_NOISE:
+	case HX_NOISE:
+		datatype = DATA_NOISE;
+		break;
+	case HX_BACK_NORMAL:
+		datatype = DATA_BACK_NORMAL;
+		break;
+	default:
+		E("Wrong type=%d\n", checktype);
+		break;
+	}
+	himax_mcu_diag_register_set(datatype, IC_MASTER);
+}
+
+static void himax_neg_noise_sup(uint8_t *data)
+{
+	uint8_t tmp_data[4];
+
+	/*0x10007FD8 Check support negative value or not */
+	himax_mcu_register_read(addr_neg_noise_sup, DATA_LEN_4, tmp_data);
+
+	if ((tmp_data[3] & 0x04U) == 0x04U) {
+		himax_parse_assign_cmd(data_neg_noise, tmp_data,
+				       sizeof(tmp_data));
+		data[2] = tmp_data[2];
+		data[3] = tmp_data[3];
+	} else {
+		I("%s Not support negative noise\n", __func__);
+	}
+}
+
+static void himax_get_noise_base(uint8_t checktype) /*Normal Threshold*/
+{
+	uint8_t tmp_data[4];
+
+	switch (checktype) {
+	case HX_WT_NOISE:
+		/*normal : 0x1000708F, LPWUG:0x10007093*/
+		himax_mcu_register_read(addr_normal_noise_thx, DATA_LEN_4,
+					tmp_data);
+		break;
+
+	default:
+		I("%s Not support type\n", __func__);
+		break;
+	}
+
+	NOISEMAX = (int)tmp_data[3];
+
+	himax_mcu_register_read(addr_recal_thx, DATA_LEN_4, tmp_data);
+	g_recal_thx = (int)tmp_data[2]; /*0x10007092*/
+	I("%s: NOISEMAX=%d, g_recal_thx = %d\n", __func__, NOISEMAX,
+	  g_recal_thx);
+}
+
+static void himax_set_N_frame(uint16_t Nframe, uint8_t checktype)
+{
+	uint8_t tmp_data[4] = { 0 };
+
+	/*IIR MAX - 0x10007294*/
+	tmp_data[3] = 0x00;
+	tmp_data[2] = 0x00;
+	tmp_data[1] = (uint8_t)((Nframe & 0xFF00U) >> 8U);
+	tmp_data[0] = (uint8_t)(Nframe & 0x00FFU);
+
+	if (checktype == (uint8_t)HX_NOISE) {
+		himax_neg_noise_sup(tmp_data);
+	}
+
+	himax_mcu_register_write(addr_set_frame_addr, 4, tmp_data);
+
+	himax_set_BS_UDT_frame(checktype);
+
+	if ((checktype == (uint8_t)HX_WT_NOISE) || (checktype == (uint8_t)HX_NOISE)) {
+		himax_get_noise_base(checktype);
+	}
+
+}
+
+static uint16_t himax_get_palm_num(void) /*Palm Number*/
+{
+	uint8_t tmp_data[4];
+	uint16_t palm_num;
+
+	himax_mcu_register_read(addr_palm_num, DATA_LEN_4, tmp_data);
+	palm_num = tmp_data[3]; /*0x100070AB*/
+	I("%s: palm_num = %d ", __func__, palm_num);
+
+	return palm_num;
+}
+
+static int himax_get_noise_weight_test(uint8_t checktype)
+{
+	uint8_t tmp_data[4];
+	uint16_t weight = 0;
+	uint16_t value = 0;
+
+	/*0x100072C8 weighting value*/
+	himax_mcu_register_read(addr_weight_sup, DATA_LEN_4, tmp_data);
+	if ((tmp_data[3] != (uint8_t)((addr_weight_sup >> 8U) & 0x000000FFU))
+		|| (tmp_data[2] != (uint8_t)(addr_weight_sup & 0x000000FFU))) {
+		return FW_NOT_READY;
+	}
+
+	value = ((uint16_t)tmp_data[1] << 8) | (uint16_t)tmp_data[0];
+	I("%s: value = %d, %d, %d ", __func__, value, tmp_data[2], tmp_data[3]);
+
+	switch (checktype) {
+	case HX_WT_NOISE:
+		/*Normal:0x1000709C, LPWUG:0x100070A0 weighting threshold*/
+		himax_mcu_register_read(addr_normal_weight_a, DATA_LEN_4,
+					tmp_data);
+		break;
+	default:
+		I("%s Not support type\n", __func__);
+		break;
+	}
+
+	weight = (uint16_t)tmp_data[0];
+
+	himax_mcu_register_read(addr_weight_b, DATA_LEN_4, tmp_data);
+	weight = (uint16_t)tmp_data[1] * (uint16_t)weight; /*0x10007095 weighting threshold*/
+	I("%s: weight = %d ", __func__, weight);
+
+	if (value > weight) {
+		return ERR_TEST_FAIL;
+	} else {
+		return 0;
+	}
+}
+
+static uint32_t himax_check_mode(uint8_t checktype)
+{
+	uint8_t tmp_data[4] = { 0 };
+	uint8_t wait_pwd[2] = { 0 };
+
+	switch (checktype) {
+	case HX_SORTING:
+		wait_pwd[0] = PWD_SORTING_END;
+		wait_pwd[1] = PWD_SORTING_END;
+		break;
+	case HX_OPEN:
+		wait_pwd[0] = PWD_OPEN_END;
+		wait_pwd[1] = PWD_OPEN_END;
+		break;
+	case HX_MICRO_OPEN:
+		wait_pwd[0] = PWD_MICRO_OPEN_END;
+		wait_pwd[1] = PWD_MICRO_OPEN_END;
+		break;
+	case HX_SHORT:
+		wait_pwd[0] = PWD_SHORT_END;
+		wait_pwd[1] = PWD_SHORT_END;
+		break;
+	case HX_RAWDATA:
+	case HX_BPN_RAWDATA:
+	case HX_SBP_RAWDATA:
+	case HX_SC:
+	case HX_GAPTEST_RAW:
+		wait_pwd[0] = PWD_RAWDATA_END;
+		wait_pwd[1] = PWD_RAWDATA_END;
+		break;
+
+	case HX_WT_NOISE:
+	case HX_NOISE:
+		wait_pwd[0] = PWD_NOISE_END;
+		wait_pwd[1] = PWD_NOISE_END;
+		break;
+
+	default:
+		E("Wrong type=%d\n", checktype);
+		break;
+	}
+
+	if ((checktype == (uint8_t)HX_NOISE) || (checktype == (uint8_t)HX_WT_NOISE)) {
+		I("%s: NOISE check n frame\n", __func__);
+		himax_mcu_check_N_frame(tmp_data);
+		if (tmp_data[0] != NOISEFRAME) {
+			tmp_data[0] = NOISEFRAME;
+			himax_mcu_register_write(addr_set_frame_addr, DATA_LEN_4, tmp_data);
+			return 1;
+		}
+	}
+
+	himax_mcu_check_sorting_mode(tmp_data);
+
+	if (wait_pwd[0] == tmp_data[0]) {
+		if (wait_pwd[1] == tmp_data[1]) {
+			I("%s: Already in %s mode\n", __func__,
+				g_himax_self_test_mode[checktype]);
+		}
+		return 0;
+	} else {
+		return 1;
+	}
+}
+
+static uint32_t himax_wait_sorting_mode(uint8_t checktype)
+{
+	uint8_t tmp_data[4] = { 0 };
+	uint8_t wait_pwd[2] = { 0 };
+	uint16_t count = 0;
+
+	switch (checktype) {
+	case HX_SORTING:
+		wait_pwd[0] = PWD_SORTING_END;
+		wait_pwd[1] = PWD_SORTING_END;
+		break;
+	case HX_OPEN:
+		wait_pwd[0] = PWD_OPEN_END;
+		wait_pwd[1] = PWD_OPEN_END;
+		break;
+	case HX_MICRO_OPEN:
+		wait_pwd[0] = PWD_MICRO_OPEN_END;
+		wait_pwd[1] = PWD_MICRO_OPEN_END;
+		break;
+	case HX_SHORT:
+		wait_pwd[0] = PWD_SHORT_END;
+		wait_pwd[1] = PWD_SHORT_END;
+		break;
+	case HX_RAWDATA:
+	case HX_BPN_RAWDATA:
+	case HX_SBP_RAWDATA:
+	case HX_SC:
+	case HX_GAPTEST_RAW:
+		wait_pwd[0] = PWD_RAWDATA_END;
+		wait_pwd[1] = PWD_RAWDATA_END;
+		break;
+	case HX_WT_NOISE:
+	case HX_NOISE:
+		wait_pwd[0] = PWD_NOISE_END;
+		wait_pwd[1] = PWD_NOISE_END;
+		break;
+	default:
+		I("No Change Mode and now type=%d\n", checktype);
+		break;
+	}
+
+	do {
+		himax_mcu_check_sorting_mode(tmp_data);
+		if ((wait_pwd[0] == tmp_data[0]) &&
+		    (wait_pwd[1] == tmp_data[1])) {
+			I("Retry %d times!\n", count);
+			return HX_INSP_OK;
+		}
+		if ((count % 10U) == 0U) {
+			himax_mcu_register_read(addr_cs_central_state, DATA_LEN_4,
+						tmp_data);
+			I(TEMP_LOG, __func__, "0x900000A8", tmp_data[0], tmp_data[1],
+			  tmp_data[2], tmp_data[3]);
+
+			himax_mcu_register_read(addr_flag_reset_event, DATA_LEN_4,
+						tmp_data);
+			I(TEMP_LOG, __func__, "0x900000E4", tmp_data[0], tmp_data[1],
+			  tmp_data[2], tmp_data[3]);
+
+			himax_mcu_register_read(addr_fw_dbg_msg_addr, DATA_LEN_4,
+						tmp_data);
+			I(TEMP_LOG, __func__, "0x10007F40", tmp_data[0], tmp_data[1],
+			  tmp_data[2], tmp_data[3]);
+		}
+		msleep(50);
+		count += 1U;
+	} while (count < 200U);
+
+	return HX_INSP_ESWITCHMODE;
+}
+
+static void himax_data_compare(uint8_t checktype, int16_t *RAW,
+				   uint32_t *ret_val)
+{
+	uint32_t i = 0;
+	uint32_t j = 0;
+	uint32_t index = 0;
+	uint8_t idx_max = 0;
+	uint8_t idx_min = 0;
+	int16_t Min_DATA = 0x7FFF;
+	int16_t Max_DATA = 0x0000;
+	uint16_t palm_num = 0;
+	uint16_t noise_count = 0;
+	int16_t tmp_RAW = 0;
+	int16_t tmp_criteria = 0;
+	uint32_t tmp_BP = 0U;
+
+	switch (checktype) {
+	case HX_SORTING:
+		idx_min = IDX_SORTMIN;
+		break;
+	case HX_OPEN:
+		idx_max = IDX_OPENMAX;
+		idx_min = IDX_OPENMIN;
+		break;
+	case HX_MICRO_OPEN:
+		idx_max = IDX_M_OPENMAX;
+		idx_min = IDX_M_OPENMIN;
+		break;
+	case HX_SHORT:
+		idx_max = IDX_SHORTMAX;
+		idx_min = IDX_SHORTMIN;
+		break;
+	case HX_RAWDATA:
+		idx_max = IDX_RAWMAX;
+		idx_min = IDX_RAWMIN;
+		break;
+	case HX_BPN_RAWDATA:
+		idx_max = IDX_BPN_RAWMAX;
+		idx_min = IDX_BPN_RAWMIN;
+		break;
+	case HX_SBP_RAWDATA:
+		idx_max = IDX_SBP_RAWMAX;
+		idx_min = IDX_SBP_RAWMIN;
+		break;
+	case HX_SC:
+		idx_max = IDX_SCMAX;
+		idx_min = IDX_SCMIN;
+		break;
+	case HX_WT_NOISE:
+		idx_max = IDX_WT_NOISEMAX;
+		idx_min = IDX_WT_NOISEMIN;
+		break;
+	case HX_NOISE:
+		idx_max = IDX_NOISEMAX;
+		idx_min = IDX_NOISEMIN;
+		break;
+	case HX_GAPTEST_RAW:
+		break;
+	default:
+		E("Wrong type=%d\n", checktype);
+		break;
+	}
+
+	/*data process*/
+	switch (checktype) {
+	case HX_SORTING:
+		for (i = 0; i < block_num; i++) {
+			g_self_test_criteria[idx_max][i] = 0x7FFF;
+		}
+		break;
+	case HX_BPN_RAWDATA:
+	case HX_SBP_RAWDATA:
+		for (i = 0; i < block_num; i++) {
+			tmp_BP = (uint32_t)RAW[i];
+			tmp_BP = (tmp_BP * 100U / g_dc_max);
+			RAW[i] = (int16_t)tmp_BP;
+		}
+		break;
+	case HX_SC:
+		for (i = 0; i < block_num; i++) {
+			tmp_RAW = RAW[i];
+			tmp_criteria =
+				g_self_test_criteria[IDX_SC_GOLDEN][i];
+			RAW[i] = tmp_RAW - tmp_criteria;
+			RAW[i] =  RAW[i] * 100 / tmp_criteria;
+		}
+		break;
+	default:
+		/*do nothing*/
+		break;
+	}
+
+	/*data compare*/
+	switch (checktype) {
+	case HX_WT_NOISE:
+		noise_count = 0;
+		himax_get_noise_base(checktype);
+		palm_num = himax_get_palm_num();
+		for (i = 0; i < block_num; i++) {
+			if (RAW[i] > NOISEMAX) {
+				noise_count++;
+			}
+		}
+		I("noise_count=%d\n", noise_count);
+		if (noise_count > palm_num) {
+			E("%s: noise test FAIL\n", __func__);
+			*ret_val |= (uint32_t)0x01U << (checktype + ERR_SFT);
+			break;
+		}
+		(void)snprintf(g_start_log, 256U * sizeof(char), "\n Threshold = %d\n",
+			NOISEMAX);
+		/*Check weightingt*/
+		if (himax_get_noise_weight_test(checktype) < 0) {
+			I("%s: %s FAIL 0x%02X\n", __func__,
+			g_himax_self_test_mode[checktype], *ret_val);
+			*ret_val |= (uint32_t)0x01U << (checktype + ERR_SFT);
+			break;
+		}
+		/*Check negative side noise*/
+		for (i = 0; i < block_num; i++) {
+			if ((RAW[i] > (g_self_test_criteria[idx_max][i] *
+					(NOISEMAX / 100))) ||
+				(RAW[i] < (g_self_test_criteria[idx_min][i] *
+					(g_recal_thx / 100)))
+			) {
+				E(FAIL_IN_INDEX, __func__,
+				g_himax_self_test_mode[checktype], i);
+				*ret_val |= (uint32_t)0x01U << (checktype + ERR_SFT);
+				break;
+			}
+		}
+		break;
+	case HX_SORTING:
+	case HX_OPEN:
+	case HX_MICRO_OPEN:
+	case HX_SHORT:
+	case HX_RAWDATA:
+	case HX_BPN_RAWDATA:
+	case HX_SBP_RAWDATA:
+	case HX_SC:
+	case HX_NOISE:
+		for (i = 0; i < block_num; i++) {
+			if ((RAW[i] > g_self_test_criteria[idx_max][i]) ||
+				(RAW[i] < g_self_test_criteria[idx_min][i])) {
+				E(FAIL_IN_INDEX, __func__,
+				g_himax_self_test_mode[checktype], i);
+				*ret_val |= (uint32_t)0x01U << (checktype + ERR_SFT);
+				break;
+			}
+		}
+		break;
+	default:
+		E("Wrong type=%d\n", checktype);
+		break;
+	}
+	if ((private_ts->debug_log_level & BIT(3)) != 0U) {
+		for (j = 0; j < ic_data->HX_RX_NUM; j++) {
+			if (j == 0U) {
+				I("      RX%2d", j + 1U);
+			} else {
+				PI("  RX%2d", j + 1U);
+			}
+		}
+		PI("\n");
+	}
+	if ((private_ts->debug_log_level & BIT(3)) != 0U) {
+		for (i = 0; i < (uint32_t)ic_data->HX_TX_NUM; i++) {
+			I("TX%2d", i + 1U);
+			for (j = 0; j < (uint32_t)ic_data->HX_RX_NUM; j++) {
+				if (RAW[index] > g_self_test_criteria[idx_max][index]) {
+					PI("%5d>", RAW[index]);
+				} else if (RAW[index] < g_self_test_criteria[idx_min][index]) {
+					PI("%5d<", RAW[index]);
+				} else {
+					PI("%5d ", RAW[index]);
+				}
+				if (RAW[index] > Max_DATA) {
+					Max_DATA = RAW[index];
+				}
+				if (RAW[index] < Min_DATA) {
+					Min_DATA = RAW[index];
+				}
+
+				index++;
+			}
+			PI("\n");
+		}
+		I("Max = %5d, Min = %5d\n", Max_DATA, Min_DATA);
+	}
+	I("%s: %s %s\n", __func__, g_himax_self_test_mode[checktype],
+	  (*ret_val == (uint32_t)HX_INSP_OK) ? "PASS" : "FAIL");
+
+}
+
+static uint32_t himax_get_max_dc(void)
+{
+	uint8_t tmp_data[DATA_LEN_4];
+	uint32_t dc_max = 0;
+
+	himax_mcu_register_read(addr_max_dc, DATA_LEN_4, tmp_data);
+	/*I("%s: tmp_data[0]=0x%02X,tmp_data[1]=0x%02X\n", __func__, tmp_data[0],
+	 * tmp_data[1]);
+	 */
+
+	dc_max = ((uint32_t)tmp_data[3] << 24U)
+			+ ((uint32_t)tmp_data[2] << 16U)
+			+ ((uint32_t)tmp_data[1] << 8U)
+			+ (uint32_t)tmp_data[0];
+
+	I("%s: dc max = %d\n", __func__, dc_max);
+	return dc_max;
+}
+
+/*	 HX_GAP END*/
+static uint32_t mpTestFunc(uint8_t checktype, uint32_t datalen,
+			   struct seq_file *s)
+{
+	char g_rslt_log[256];
+	size_t len = 0;
+	int16_t *RAW = NULL;
+	uint16_t n_frame = 0;
+	uint32_t ret_val = HX_INSP_OK;
+	struct time_var timeStart;
+	struct time_var timeEnd;
+	struct time_var timeDelta;
+
+	I("%s, Check type = %d\n", __func__, checktype);
+	time_func(&timeStart);
+	RAW = kcalloc(datalen, sizeof(int16_t), GFP_KERNEL);
+
+	if (RAW == NULL) {
+		E("%s, Failed to allocate memory\n", __func__);
+		return HX_INSP_MEMALLCTFAIL;
+	}
+
+	if (himax_check_mode(checktype) != 0U) {
+		/*himax_check_mode(checktype);*/
+
+		I("Need Change Mode ,target=%s\n",
+		  g_himax_self_test_mode[checktype]);
+
+		g_core_fp.fp_sense_off();
+
+		himax_mcu_config_reload_disable();
+
+		himax_switch_mode_self_test(checktype);
+
+		switch (checktype) {
+		case HX_WT_NOISE:
+		case HX_NOISE:
+			n_frame = (uint16_t)NOISEFRAME;
+			break;
+		default:
+			n_frame = (uint16_t)OTHERSFRAME;
+			break;
+		}
+		himax_set_N_frame(n_frame, checktype);
+#if !defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83194)
+		himax_mcu_rawdata_normalize_disable(1);
+#endif
+		g_core_fp.fp_sense_on();
+
+	}
+	ret_val |= himax_wait_sorting_mode(checktype);
+	if (ret_val != 0U) {
+		E("%s: himax_wait_sorting_mode FAIL\n", __func__);
+		ret_val |= (1U << ((uint32_t)checktype + ERR_SFT));
+		goto fail_wait_sorting_mode;
+	}
+	himax_switch_data_type(checktype);
+
+	usleep_range(40000, 41000);
+
+	ret_val |= himax_get_rawdata(RAW, datalen);
+	if (ret_val != 0U) {
+		E("%s: himax_get_rawdata FAIL\n", __func__);
+		ret_val |= (1U << ((uint32_t)checktype + ERR_SFT));
+		goto fail_get_rawdata;
+	}
+	time_func(&timeEnd);
+	timeDelta = time_diff(timeStart, timeEnd);
+#if defined(KERNEL_VER_5_10)
+	seq_printf(s, "\t%s :  %lld.%ld s\n", g_himax_self_test_mode[checktype], timeDelta.tv_sec, timeDelta.tv_nsec);
+#else
+	seq_printf(s, "\t%s :  %ld.%ld s\n", g_himax_self_test_mode[checktype], timeDelta.tv_sec, timeDelta.tv_nsec);
+#endif
+
+	/*get Max DC from FW*/
+	g_dc_max = himax_get_max_dc();
+
+	/* back to normal */
+	himax_switch_data_type(HX_BACK_NORMAL);
+
+	len += (size_t)snprintf(&g_start_log[len], sizeof(g_rslt_log), "\n%s%s\n",
+			g_himax_self_test_mode[checktype],
+			": data as follow!\n");
+
+	himax_data_compare(checktype, RAW, &ret_val);
+
+	himax_get_arraydata_edge(RAW);
+
+	len += (size_t)snprintf(&g_start_log[len], sizeof(g_rslt_log) - len,
+			"\n arraydata_min1 = %d,", arraydata_min1);
+	len += (size_t)snprintf(&g_start_log[len], sizeof(g_rslt_log) - len,
+			"  arraydata_min2 = %d,", arraydata_min2);
+	len += (size_t)snprintf(&g_start_log[len], sizeof(g_rslt_log) - len,
+			"  arraydata_min3 = %d,", arraydata_min3);
+	len += (size_t)snprintf(&g_start_log[len], sizeof(g_rslt_log) - len,
+			"\n arraydata_max1 = %d,", arraydata_max1);
+	len += (size_t)snprintf(&g_start_log[len], sizeof(g_rslt_log) - len,
+			"  arraydata_max2 = %d,", arraydata_max2);
+	len += (size_t)snprintf(&g_start_log[len], sizeof(g_rslt_log) - len,
+			"  arraydata_max3 = %d\n", arraydata_max3);
+
+	if (ret_val == HX_INSP_OK) { /*PASS*/
+		len += (size_t)snprintf(g_rslt_log, sizeof(g_rslt_log), "\n%s%s\n",
+			 g_himax_self_test_mode[checktype], ":Test Pass!");
+	} else { /*FAIL*/
+		len += (size_t)snprintf(g_rslt_log, sizeof(g_rslt_log), "\n%s%s\n",
+			 g_himax_self_test_mode[checktype], ":Test Fail!");
+	}
+
+	hx_test_data_get(RAW, g_start_log, g_rslt_log, (int)checktype);
+fail_get_rawdata:
+fail_wait_sorting_mode:
+	kfree(RAW);
+	RAW = NULL;
+	return ret_val;
+}
+
+/* get idx of criteria whe parsing file */
+static int hx_find_crtra_id(char *input)
+{
+	unsigned int i = 0;
+	int result = 0;
+
+	for (i = 0; i < HX_CRITERIA_SIZE; i++) {
+		if (strcmp(g_hx_inspt_crtra_name[i], input) == 0) {
+			result = (int)i;
+			I("find the str=%s,idx=%d\n", g_hx_inspt_crtra_name[i],
+			  i);
+			break;
+		}
+	}
+	if (i > (HX_CRITERIA_SIZE - 1U)) {
+		E("%s: find Fail!\n", __func__);
+		result = LENGTH_FAIL;
+	}
+
+	return result;
+}
+
+static void hx_print_crtra_after_parsing(void)
+{
+	uint32_t i = 0;
+	uint32_t j = 0;
+
+	for (i = 0; i < HX_CRITERIA_SIZE; i++) {
+		I("Now is %s\n", g_hx_inspt_crtra_name[i]);
+		if (g_inspt_crtra_flag[i] == 1) {
+			for (j = 0; j < block_num; j++) {
+				I("%d, ", g_self_test_criteria[i][j]);
+				if ((j % 16U) == 15U) {
+					PI("\n");
+				}
+			}
+		} else {
+			I("No this Item in this criteria file!\n");
+		}
+		PI("\n");
+	}
+
+}
+
+static uint32_t hx_criteria_collect(char *critera_str, uint16_t himax_count_type, int comprae_data)
+{
+	int result = 0;
+	uint32_t ret = HX_INSP_OK;
+
+	if (kstrtoint(critera_str, 10, &result) == 0) {
+		g_self_test_criteria[himax_count_type][comprae_data] = (int16_t)result;
+	} else {
+		I("Failed to convert string '%s' to integer\n", critera_str);
+		I("himax_count_type = %d, comprae_data index = %d \n", himax_count_type, comprae_data);
+		ret = HX_INSP_EFILE;
+		if ((private_ts->debug_log_level & BIT(4)) != 0U) {
+			/* dbg:print all of criteria from parsing file */
+			hx_print_crtra_after_parsing();
+		} else {
+			/*do nothing*/
+		}
+	}
+
+	return ret;
+}
+
+static uint32_t hx_check_criteria_in_csv(uintptr_t end_ptr, char *curr_byte, int crtra_id)
+{
+	uint32_t ret = HX_INSP_OK;
+	int rx_count = 0;
+	int tx_count = 0;
+	size_t i = 0;
+	char str_buff[8] = { 0 };
+	size_t str_len = 0;
+	uintptr_t curr_ptr;
+
+	do {
+		if (curr_byte[i] == '-') {
+			str_len++;
+		} else if (isdigit(curr_byte[i]) != 0) {
+			str_len++;
+		} else if (curr_byte[i] == ',') {
+			(void)memset(str_buff, '\0', sizeof(str_buff));
+			(void)memcpy(&str_buff[0], &curr_byte[i - str_len], str_len);
+			if (str_len > 0U) {
+				ret = hx_criteria_collect(str_buff, (uint16_t)crtra_id, rx_count);
+			}
+			rx_count++;
+			str_len = 0;
+		} else if (curr_byte[i] == '\n') {
+			/* do nothing */
+		} else if (curr_byte[i] == '\r') {
+			(void)memset(str_buff, '\0', sizeof(str_buff));
+			(void)memcpy(&str_buff[0], &curr_byte[i - str_len], str_len);
+			if (str_len > 0U) {
+				ret = hx_criteria_collect(str_buff, (uint16_t)crtra_id, rx_count);
+			}
+			tx_count++;
+			str_len = 0;
+		} else {
+			I("%s, character: %c\n", __func__,
+			  curr_byte[i]);
+			break;
+		}
+		i++;
+		curr_ptr = (uintptr_t)&curr_byte[i];
+	} while (curr_ptr < end_ptr);
+
+	rx_count++;
+	if (tx_count != 0) {
+		rx_count = (rx_count / tx_count);
+	}
+	if ((uint8_t)rx_count != ic_data->HX_RX_NUM) {
+		E("%s,Parsing RX: %d, it should be %d\n", __func__,
+		  rx_count, ic_data->HX_RX_NUM);
+		ret = HX_INSP_EFILE;
+	} else if ((uint8_t)tx_count != ic_data->HX_TX_NUM) {
+		E("%s,Parsing TX: %d, it should be %d\n", __func__,
+			  tx_count, ic_data->HX_TX_NUM);
+		ret = HX_INSP_EFILE;
+	} else {
+		/* Parsing */
+		I("%s:Parsed TX: %d, RX: %d\n", __func__, tx_count, rx_count);
+	}
+
+	return ret;
+}
+
+static uint32_t himax_parse_criteria_str(char *str_ptr, uint32_t hx_str_len,
+				    const struct firmware *csv_file)
+{
+	uint32_t ret = HX_INSP_OK;
+	char str_rslt[100] = { 0 };
+	int crtra_id = 0;
+	char *curr_ptr = NULL;
+	const uint8_t *csv_end = csv_file->data + csv_file->size - 1U;
+	uintptr_t end_ptr = (uintptr_t)&csv_end[0];
+
+	I("%s,Entering\n", __func__);
+
+	(void)memcpy(&str_rslt[0], str_ptr, hx_str_len);
+
+	crtra_id = hx_find_crtra_id(str_rslt);
+	if (crtra_id == LENGTH_FAIL) {
+		E("Please check criteria file again!\n");
+		ret = HX_INSP_EFILE;
+	} else {
+		g_inspt_crtra_flag[crtra_id] = 1;
+		curr_ptr = &str_ptr[hx_str_len + 1U];
+		ret = hx_check_criteria_in_csv(end_ptr, curr_ptr, crtra_id);
+	}
+	return ret;
+}
+
+static uint32_t himax_parse_criteria(const struct firmware *csv_file)
+{
+	uint32_t ret = HX_INSP_OK;
+	int i = 0;
+	char *str_ptr = NULL;
+
+	I("%s: enter, %d\n", __func__, __LINE__);
+
+	while (g_hx_inspt_crtra_name[i] != NULL) {
+		str_ptr = strnstr(csv_file->data, g_hx_inspt_crtra_name[i],
+				    csv_file->size);
+		if (str_ptr != NULL) {
+			I("g_hx_inspt_crtra_name[%d] = %s\n", i,
+			  g_hx_inspt_crtra_name[i]);
+			ret |= himax_parse_criteria_str(str_ptr,
+							(uint32_t)strlen(g_hx_inspt_crtra_name[i]),
+							csv_file);
+			if (ret >= HX_INSP_EFILE) {
+				break;
+			}
+		}
+		i++;
+	}
+	return ret;
+}
+
+static void himax_test_item_chk(void)
+{
+	unsigned int i = 0;
+
+	for (i = 0; i < (HX_CRITERIA_ITEM - 1U); i++) {
+		g_test_item_flag[i] = false;
+	}
+
+	g_test_item_flag[HX_OPEN] =
+		((g_inspt_crtra_flag[IDX_OPENMIN] == 1) &&
+		(g_inspt_crtra_flag[IDX_OPENMAX] == 1)) ?
+		true : false;
+
+	g_test_item_flag[HX_MICRO_OPEN] =
+		((g_inspt_crtra_flag[IDX_M_OPENMIN] == 1) &&
+		 (g_inspt_crtra_flag[IDX_M_OPENMAX] == 1)) ?
+		true : false;
+
+	g_test_item_flag[HX_SHORT] =
+		((g_inspt_crtra_flag[IDX_SHORTMIN] == 1) &&
+		(g_inspt_crtra_flag[IDX_SHORTMAX] == 1)) ?
+		true : false;
+
+	g_test_item_flag[HX_RAWDATA] =
+		((g_inspt_crtra_flag[IDX_RAWMIN] == 1) &&
+		(g_inspt_crtra_flag[IDX_RAWMAX] == 1)) ?
+		true : false;
+
+	g_test_item_flag[HX_BPN_RAWDATA] =
+		((g_inspt_crtra_flag[IDX_BPN_RAWMIN] == 1) &&
+		 (g_inspt_crtra_flag[IDX_BPN_RAWMAX] == 1)) ?
+		true : false;
+
+	g_test_item_flag[HX_SBP_RAWDATA] =
+		((g_inspt_crtra_flag[IDX_SBP_RAWMIN] == 1) &&
+		 (g_inspt_crtra_flag[IDX_SBP_RAWMAX] == 1)) ?
+		true : false;
+
+	g_test_item_flag[HX_SC] = ((g_inspt_crtra_flag[IDX_SCMIN] == 1) &&
+		(g_inspt_crtra_flag[IDX_SCMAX] == 1) &&
+		(g_inspt_crtra_flag[IDX_SC_GOLDEN] == 1)) ?
+		true : false;
+
+	g_test_item_flag[HX_WT_NOISE] =
+		((g_inspt_crtra_flag[IDX_WT_NOISEMIN] == 1) &&
+		 (g_inspt_crtra_flag[IDX_WT_NOISEMAX] == 1)) ?
+		true : false;
+
+	g_test_item_flag[HX_NOISE] =
+		((g_inspt_crtra_flag[IDX_NOISEMIN] == 1) &&
+		 (g_inspt_crtra_flag[IDX_NOISEMAX] == 1)) ?
+		true : false;
+
+	g_test_item_flag[HX_SORTING] =
+		((g_inspt_crtra_flag[IDX_SORTMIN] == 1) &&
+		(g_inspt_crtra_flag[IDX_SORTMAX] == 1)) ?
+		true : false;
+
+	g_test_item_flag[HX_GAPTEST_RAW] =
+		((g_inspt_crtra_flag[IDX_GAP_HOR_RAWMAX] == 1) &&
+		 (g_inspt_crtra_flag[IDX_GAP_HOR_RAWMIN] == 1) &&
+		 (g_inspt_crtra_flag[IDX_GAP_VER_RAWMAX] == 1) &&
+		 (g_inspt_crtra_flag[IDX_GAP_VER_RAWMIN] == 1)) ?
+		true : false;
+
+	for (i = 0; i < (HX_CRITERIA_ITEM - 1U); i++) {
+		I("g_test_item_flag[%d] = %d\n", i, g_test_item_flag[i]);
+	}
+}
+
+unsigned int hx_get_size_str_arr(char **input)
+{
+	unsigned int i = 0;
+
+	while (input[i] != NULL) {
+		i++;
+	}
+
+	if ((private_ts->debug_log_level & BIT(4)) != 0U) {
+		I("There is %d in [0]=%s\n", i, input[0]);
+	}
+
+	return i;
+}
+
+static void hx_print_ic_id(void)
+{
+	int len = 0;
+	char *prt_data = NULL;
+	char data[12] = { 0 };
+	uint16_t cid = 0;
+	unsigned int i = 0;
+
+	prt_data = kzalloc(sizeof(char) * HX1K, GFP_KERNEL);
+	if (prt_data == NULL) {
+		E("%s: Memory allocation falied!\n", __func__);
+		return;
+	}
+	cid = ((uint16_t)ic_data->vendor_cid_maj_ver << 8);
+	cid += ic_data->vendor_cid_min_ver;
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len, "IC = %s\n",
+			private_ts->chip_name);
+
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len,
+			"FW Architecture Version : %X\n",
+			ic_data->vendor_arch_ver);
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len, "CID : %04X\n",
+			cid);
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len,
+			"FW Algorithm Version : A%02X\n",
+			ic_data->vendor_display_cfg_ver);
+#else
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len,
+			"FW Display Config Version : D%02X\n",
+			ic_data->vendor_display_cfg_ver);
+#endif
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len,
+			"FW Touch Config Version : C%02X\n",
+			ic_data->vendor_touch_cfg_ver);
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len,
+			"Panel Version : 0x%02X\n", ic_data->vendor_panel_ver);
+
+	if (ic_data->vendor_arch_ver >= 0x8098U) {
+		(void)memcpy(data, (char *)ic_data->vendor_remark1, sizeof(data));
+		len += snprintf(&prt_data[len], HX_SZ_ICID - len, "Remark 1 = %s\n",
+			data);
+		(void)memcpy(data, (char *)ic_data->vendor_remark2, sizeof(data));
+		len += snprintf(&prt_data[len], HX_SZ_ICID - len, "Remark 2 = %s\n",
+			data);
+		(void)memcpy(data, (char *)ic_data->vendor_ticket, sizeof(data));
+		len += snprintf(&prt_data[len], HX_SZ_ICID - len, "Himax Ticket = %s\n",
+			data);
+	}
+	(void)memcpy(data, (char *)ic_data->vendor_config_date, sizeof(data));
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len, "FW Config Date = %s\n",
+			data);
+	(void)memcpy(data, (char *)ic_data->vendor_proj_info, sizeof(data));
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len, "Project = %s\n",
+			data);
+	(void)memcpy(data, (char *)ic_data->vendor_cus_info, sizeof(data));
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len, "Customer = %s\n",
+			data);
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len,
+			"Himax Touch Driver Version = %s\n", HIMAX_DRIVER_VER);
+
+	len += snprintf(&prt_data[len], HX_SZ_ICID - len,
+			"\nSelf test item critera:\n");
+	for (i = 0; i < HX_CRITERIA_SIZE; i++) {
+		if (g_inspt_crtra_flag[i] == 1) {
+			len += snprintf(&prt_data[len], HX_SZ_ICID - len,
+					"Item %s\n", g_hx_inspt_crtra_name[i]);
+			len += snprintf(&prt_data[len], HX_SZ_ICID - len,
+					"%d\n", g_self_test_criteria[i][0]);
+		}
+	}
+
+	(void)memcpy(&g_rslt_data[0], prt_data, len);
+	g_rslt_data_len = (uint32_t)len;
+	I("%s: g_rslt_data_len=%d!\n", __func__, g_rslt_data_len);
+
+	kfree(prt_data);
+	prt_data = NULL;
+}
+
+static void hx_print_normalize_status(void)
+{
+	int len = 0;
+	char *prt_data = NULL;
+	uint8_t data[DATA_LEN_4] = { 0 };
+
+	prt_data = kzalloc(sizeof(char) * 60U, GFP_KERNEL);
+	if (prt_data == NULL) {
+		E("%s: Memory allocation falied!\n", __func__);
+		return;
+	}
+	himax_mcu_register_read(addr_fw_define_rawdata_normalize, DATA_LEN_4,
+				data);
+	if ((data[3] & (0x80U >> 7U)) != 0U) {/*normalize enable*/
+		len += snprintf(&prt_data[len], 60 - len,
+				"\n***Rawdata Normalize Status : Enable\n");
+	} else { /*normalize disable*/
+		len += snprintf(&prt_data[len], 60 - len,
+				"\n***Rawdata Normalize Status : Disable\n");
+	}
+
+	(void)memcpy(&g_rslt_data[0], prt_data, len);
+	g_rslt_data_len = (uint32_t)len;
+	I("%s: g_rslt_data_len=%d!\n", __func__, g_rslt_data_len);
+
+	kfree(prt_data);
+	prt_data = NULL;
+}
+
+static uint32_t hx_create_criteria_array(char *critera_str, unsigned int id)
+{
+	uint32_t i = 0;
+	int result = 0;
+	uint32_t ret = HX_INSP_OK;
+
+	if (kstrtoint(critera_str, 10, &result) == 0) {
+		for (i = 0; i < block_num; i++) {
+			g_self_test_criteria[id][i] = (int16_t)result;
+		}
+	} else {
+		I("Failed to convert string '%s' to integer\n", critera_str);
+		ret = HX_INSP_EFILE;
+	}
+
+	return ret;
+}
+
+static uint32_t himax_default_item_and_criteria(void)
+{
+	unsigned int i = 0;
+	unsigned int j = 0;
+	unsigned int size;
+	char *buf;
+	char str_buf[10] = { 0 };
+	uint32_t ret = HX_INSP_OK;
+
+	I("%s: enter\n", __func__);
+	size = hx_get_size_str_arr(default_item_and_criteria);
+	for (i = 0; i < size; i++) {
+		for (j = 0; j < HX_CRITERIA_SIZE; j++) {
+			buf = strnstr(default_item_and_criteria[i], g_hx_inspt_crtra_name[j], strlen(default_item_and_criteria[i]));
+			if (buf != NULL) {
+				buf = strstr(default_item_and_criteria[i], ":");
+				if (strcmp(&buf[1], "NULL") != 0) {
+					ret = hx_create_criteria_array(&buf[1], j);
+					if (ret > 0U) {
+						E("%s: please check %s\n", __func__, default_item_and_criteria[i]);
+						return ret;
+					}
+					g_inspt_crtra_flag[j] = 1;
+				}
+			}
+			(void)memset(str_buf, '\0', sizeof(str_buf));
+		}
+	}
+	I("%s: end\n", __func__);
+	return ret;
+}
+
+static uint32_t himax_self_test_data_init(void)
+{
+	const struct firmware *csv_file = NULL;
+	struct himax_ts_data *ts = private_ts;
+	char file_name_2[30];
+	uint32_t ret = HX_INSP_OK;
+	int err = 0;
+	unsigned int i = 0;
+	struct time_var timeStart;
+	int size = 0;
+	char out_file[100];
+
+	mutual_block_num = (uint32_t)ic_data->HX_TX_NUM
+					* (uint32_t)ic_data->HX_RX_NUM;
+	self_block_num = (uint32_t)ic_data->HX_TX_NUM
+					+ (uint32_t)ic_data->HX_RX_NUM;
+
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+	block_num = mutual_block_num + self_block_num;
+#else
+	block_num = mutual_block_num;
+#endif
+
+	(void)strcpy(file_name_2, "hx_criteria.csv");
+
+	if (ts->self_test_file_ch[0] != (char)0) {
+		(void)memset(file_name_2, 0, sizeof(file_name_2));
+		(void)memcpy(file_name_2, ts->self_test_file_ch, strlen(ts->self_test_file_ch));
+		I("%s: hx_criteria file name change to |%s|\n", __func__, file_name_2);
+	}
+
+	/*
+	 * 5: one value will not over than 99999, so get this size of string
+	 * 2: get twice size
+	 */
+	g_1kind_raw_size = 5U * block_num * 2U;
+
+	/* get test item and its items of criteria*/
+	HX_CRITERIA_ITEM = hx_get_size_str_arr(g_himax_self_test_mode);
+	HX_CRITERIA_SIZE = hx_get_size_str_arr(g_hx_inspt_crtra_name);
+	I("There is %d HX_CRITERIA_ITEM and %d HX_CRITERIA_SIZE\n",
+	  HX_CRITERIA_ITEM, HX_CRITERIA_SIZE);
+
+	/* init criteria data*/
+	g_test_item_flag = kcalloc(HX_CRITERIA_ITEM, sizeof(int), GFP_KERNEL);
+	if (g_test_item_flag == NULL) {
+		E("%s,%d: Memory allocation falied!\n", __func__, __LINE__);
+		ret = HX_INSP_MEMALLCTFAIL;
+		goto err_malloc_test_item_flag;
+	}
+
+	g_inspt_crtra_flag = kcalloc(HX_CRITERIA_SIZE, sizeof(int), GFP_KERNEL);
+	if (g_inspt_crtra_flag == NULL) {
+		E("%s,%d: Memory allocation falied!\n", __func__, __LINE__);
+		ret = HX_INSP_MEMALLCTFAIL;
+		goto err_malloc_inspt_crtra_flag;
+	}
+
+	g_self_test_criteria =
+		kcalloc(HX_CRITERIA_SIZE, sizeof(int *), GFP_KERNEL);
+	if (g_self_test_criteria == NULL) {
+		E("%s,%d: Memory allocation falied!\n", __func__, __LINE__);
+		ret = HX_INSP_MEMALLCTFAIL;
+		goto err_malloc_self_test_criteria;
+	}
+
+	for (i = 0; i < HX_CRITERIA_SIZE; i++) {
+		g_self_test_criteria[i] =
+			kcalloc((ic_data->HX_TX_NUM * ic_data->HX_RX_NUM),
+				sizeof(int), GFP_KERNEL);
+		if (g_self_test_criteria[i] == NULL) {
+			E("%s,%d: Memory allocation %d falied!\n", __func__,
+			  __LINE__, i);
+			ret = HX_INSP_MEMALLCTFAIL;
+			goto err_malloc_self_test_criteria2;
+		}
+	}
+
+	g_rslt_data_len = 0;
+	if (g_rslt_data == NULL) {
+		g_rslt_data =
+			kcalloc(g_1kind_raw_size, sizeof(char), GFP_KERNEL);
+		if (g_rslt_data == NULL) {
+			E("%s,%d: Memory allocation falied!\n", __func__,
+			  __LINE__);
+			ret = HX_INSP_MEMALLCTFAIL;
+			goto err_malloc_rslt_data;
+		}
+	}
+	I("%s: initialize g_rslt_data, length = %d\n", __func__,
+	  g_1kind_raw_size);
+	(void)memset(g_rslt_data, 0x00, g_1kind_raw_size * sizeof(char));
+
+	if (g_start_log == NULL) {
+		g_start_log =
+			kcalloc(512, sizeof(char), GFP_KERNEL);
+		if (g_start_log == NULL) {
+			E("%s,%d: Memory allocation falied!\n", __func__,
+			  __LINE__);
+			ret = HX_INSP_MEMALLCTFAIL;
+			goto err_malloc_start_log;
+		}
+	}
+
+	if (g_file_path == NULL) {
+		g_file_path =
+			kcalloc(256, sizeof(char), GFP_KERNEL);
+		if (g_file_path == NULL) {
+			E("%s,%d: Memory allocation falied!\n", __func__,
+			  __LINE__);
+			ret = HX_INSP_MEMALLCTFAIL;
+			goto err_malloc_file_path;
+		}
+	}
+
+	/* default path is /system/etc/firmware */
+	/* request criteria file*/
+
+	err = request_firmware(&csv_file, file_name_2, ts->dev);
+	if (err < 0) {
+		I("%s,Fail to get %s\n", __func__, file_name_2);
+		I("%s: No criteria file\n", __func__);
+		I("%s: Change to use default criteria(default_item_and_criteria)\n", __func__);
+		ret = himax_default_item_and_criteria();
+		if (ret > 0U) {
+			goto err_open_criteria_file;
+		}
+	} else {
+		I("%s,Success to get %s\n", __func__, file_name_2);
+		/* parsing criteria from file .csv*/
+		ret = himax_parse_criteria(csv_file);
+		release_firmware(csv_file);
+		if (ret > 0U) {
+			I("%s,err_open_criteria_file\n", __func__);
+			goto err_open_criteria_file;
+		}
+	}
+	himax_test_item_chk();
+
+	if ((private_ts->debug_log_level & BIT(4)) != 0U) {
+		/* print get criteria string */
+		for (i = 0; i < HX_CRITERIA_SIZE; i++) {
+			if (g_inspt_crtra_flag[i] != 0) {
+				I("%s: [%d]There is String=%s\n", __func__, i,
+				  g_hx_inspt_crtra_name[i]);
+			}
+		}
+	}
+
+	time_func(&timeStart);
+#if defined(KERNEL_VER_5_10)
+	size = snprintf(out_file, sizeof(out_file), "hx_test_result_%lld.txt", timeStart.tv_sec);
+#else
+	size = snprintf(out_file, sizeof(out_file), "hx_test_result_%ld.txt", timeStart.tv_sec);
+#endif
+
+	(void)snprintf(g_file_path,
+		 (strlen(HX_RSLT_OUT_PATH) + strlen(out_file) + 1U), "%s%s",
+		 HX_RSLT_OUT_PATH, out_file);
+
+	file_w_flag = true;
+	for (i = 0; i < HX_CRITERIA_SIZE; i++) {
+		if (g_inspt_crtra_flag[i] == 1) {
+			I("[%s]\n", default_item_and_criteria[i]);
+		}
+	}
+	return ret;
+
+err_open_criteria_file:
+	kfree(g_file_path);
+	g_file_path = NULL;
+err_malloc_file_path:
+	kfree(g_start_log);
+	g_start_log = NULL;
+err_malloc_start_log:
+	kfree(g_rslt_data);
+	g_rslt_data = NULL;
+err_malloc_rslt_data:
+
+err_malloc_self_test_criteria2:
+	for (i = 0; i < HX_CRITERIA_SIZE; i++) {
+		if (g_self_test_criteria[i] != NULL) {
+			kfree(g_self_test_criteria[i]);
+			g_self_test_criteria[i] = NULL;
+		}
+	}
+	kfree(g_self_test_criteria);
+	g_self_test_criteria = NULL;
+err_malloc_self_test_criteria:
+	kfree(g_inspt_crtra_flag);
+	g_inspt_crtra_flag = NULL;
+err_malloc_inspt_crtra_flag:
+	kfree(g_test_item_flag);
+	g_test_item_flag = NULL;
+err_malloc_test_item_flag:
+	return ret;
+}
+
+static void himax_self_test_data_deinit(void)
+{
+	unsigned int i = 0;
+
+	/*dbg*/
+	/* for (i = 0; i < HX_CRITERIA_ITEM; i++)
+	 *	I("%s:[%d]%d\n", __func__, i, g_self_test_criteria[i]);
+	 */
+
+	I("%s: release allocated memory\n", __func__);
+
+	for (i = 0; i < HX_CRITERIA_SIZE; i++) {
+		if (g_self_test_criteria[i] != NULL) {
+			kfree(g_self_test_criteria[i]);
+			g_self_test_criteria[i] = NULL;
+		}
+	}
+	kfree(g_self_test_criteria);
+	g_self_test_criteria = NULL;
+
+	kfree(g_inspt_crtra_flag);
+	g_inspt_crtra_flag = NULL;
+
+	kfree(g_test_item_flag);
+	g_test_item_flag = NULL;
+	I("%s: release finished\n", __func__);
+}
+
+#if (HX_RST_PIN_FUNC == 0x01)
+/*
+ *+------------+------------+--------+----------------------------+
+ *|   State1   |   State2   | Result |            Info            |
+ *+------------+------------+--------+----------------------------+
+ *| 0x05       | != 0x3776  | OK     | Reset Pin OK               |
+ *| Dont Care | == 0x3776  | Fail   | Reset Pin Fail : Keep High |
+ *| 0xFF       | Dont Care | Fail   | Reset Pin Fail : Keep Low  |
+ *| Others     | Others     | Fail   | Unknown Fail               |
+ *+------------+------------+--------+----------------------------+
+ */
+
+static bool himax_mpap_test_tp_rst(void)
+{
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	uint8_t count = 0;
+	uint16_t State2 = 0;
+
+	g_core_fp.fp_sense_off();
+
+	tmp_data[3] = 0x00;
+	tmp_data[2] = 0x00;
+	tmp_data[1] = 0x37;
+	tmp_data[0] = 0x76;
+
+	himax_mcu_register_write(addr_mpap_rst_test, 4, tmp_data);
+
+	himax_mcu_toggle_rst_gpio();
+
+	do {
+
+		himax_mcu_register_read(addr_cs_central_state, DATA_LEN_4,	tmp_data);
+		usleep_range(1000, 1100);
+		count++;
+
+	} while ((tmp_data[0] == 0x04U) && (count < 100U));
+
+	if (tmp_data[0] == 0x05U) {
+		himax_mcu_register_read(addr_mpap_rst_test, DATA_LEN_4,	tmp_data);
+		State2 = ((uint16_t)tmp_data[1] << 8U) + (uint16_t)tmp_data[0];
+		if (State2 != 0x3776U) {
+			I("%s:MPAP TP RST test pass\n", __func__);
+			return true;
+		}
+	}
+
+	return false;
+}
+#endif
+
+static bool himax_mpap_test_int(void)
+{
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	bool ret = true;
+	uint8_t int_status = 0;
+
+	g_core_fp.fp_sense_off();
+
+	tmp_data[3] = 0x00;
+	tmp_data[2] = 0x00;
+	tmp_data[1] = 0x00;
+	tmp_data[0] = 0x02;
+	himax_mcu_register_write(addr_mpap_int_test_base, 4, tmp_data);
+
+	tmp_data[0] = 0x01;
+	himax_mcu_register_write(addr_mpap_int_test_cmd_1, 4, tmp_data);
+
+	tmp_data[0] = 0x00;
+	himax_mcu_register_write(addr_mpap_int_test_cmd_2, 4, tmp_data);
+
+	/*MPAP test int pin low*/
+	int_status = himax_int_gpio_read(private_ts->pdata->TSIX);
+	if (int_status != 0U) {
+		ret = false;
+		E("%s:MPAP INT pin low test fail\n", __func__);
+	}
+
+	tmp_data[0] = 0x02;
+	himax_mcu_register_write(addr_mpap_int_test_base, 4, tmp_data);
+
+	tmp_data[0] = 0x01;
+	himax_mcu_register_write(addr_mpap_int_test_cmd_1, 4, tmp_data);
+
+	tmp_data[0] = 0x01;
+	himax_mcu_register_write(addr_mpap_int_test_cmd_2, 4, tmp_data);
+
+	/*MPAP test int pin high*/
+	int_status = himax_int_gpio_read(private_ts->pdata->TSIX);
+	if (int_status != 1U) {
+		ret = false;
+		E("%s:MPAP INT pin high test fail\n", __func__);
+	}
+
+	g_core_fp.fp_sense_on();
+
+	if (ret) {
+		I("%s:MPAP INT test pass\n", __func__);
+	}
+
+	return ret;
+}
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+static bool himax_mpap_test_fail_det(void)
+{
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	uint8_t pswd[DATA_LEN_4] = { 0 };
+	bool ret = false;
+	uint8_t gpio_status = 0U;
+	uint8_t counter = 0U;
+
+	himax_mcu_register_read(addr_cs_central_state, DATA_LEN_4, tmp_data);
+
+	if (tmp_data[0] != 0x05U) {
+		E("%s: 9000005C data[0]=0x%02X, \n", __func__,
+		  tmp_data[0]);
+	} else {
+
+		while (counter < 10U) {
+			himax_mcu_register_read(addr_chk_fw_reload2,
+					DATA_LEN_4, tmp_data);
+			pswd[1] = (uint8_t)((addr_chk_fw_reload2 & 0xFF00U) >> 8U);
+			pswd[0] = (uint8_t)(addr_chk_fw_reload2 & 0xFFU);
+			if ((tmp_data[1] == pswd[1]) && (tmp_data[0] == pswd[0])) {
+				I("%s: reload done takes %d times\n", __func__,
+			 		counter);
+				ret = true;
+				break;
+			} else {
+				counter++;
+				usleep_range(10000, 11000);
+			}
+		}
+
+		if(ret) {
+			himax_parse_assign_cmd(data_mpap_fail_det_test_L, tmp_data,
+							sizeof(tmp_data));
+			himax_mcu_register_write(addr_mpap_fail_det_test, 4, tmp_data);
+
+			gpio_status = himax_int_gpio_read(private_ts->pdata->fail_det);
+			if (gpio_status != 0U) {
+				ret = false;
+				E("%s:MPAP Fail_det pin Low test fail\n", __func__);
+			}
+		}
+
+		if(ret) {
+			himax_parse_assign_cmd(data_mpap_fail_det_test_H, tmp_data,
+							sizeof(tmp_data));
+			himax_mcu_register_write(addr_mpap_fail_det_test, 4, tmp_data);
+			msleep(50);
+			gpio_status = himax_int_gpio_read(private_ts->pdata->fail_det);
+			if (gpio_status != 1U) {
+				ret = false;
+				E("%s:MPAP Fail_det pin High test fail\n", __func__);
+			}
+		}
+	}
+
+	if (ret) {
+		I("%s:MPAP Fail_det pin test pass\n", __func__);
+	}
+
+	himax_parse_assign_cmd(0x00000000, tmp_data,
+					sizeof(tmp_data));
+	himax_mcu_register_write(addr_mpap_fail_det_test, 4, tmp_data);
+
+	return ret;
+}
+
+static bool himax_mpap_check_Vsync(void) {
+	uint8_t tmp_data[DATA_LEN_4] = { 0 };
+	bool ret = false;
+	uint8_t counter = 0U;
+	uint32_t addr_Vsync_status = 0x130074F8U;
+
+	himax_mcu_register_read(addr_cs_central_state, DATA_LEN_4, tmp_data);
+
+	if (tmp_data[0] != 0x05U) {
+		E("%s: 9000005C data[0]=0x%02X, \n", __func__,
+		  tmp_data[0]);
+	} else {
+		while (counter < 50U) {
+			himax_mcu_check_sorting_mode(tmp_data);
+			if ((tmp_data[0] == 0x99U) &&
+				(tmp_data[1] == 0x99U)) {
+
+				msleep(50);
+				himax_mcu_register_read(addr_Vsync_status,
+					DATA_LEN_4, tmp_data);
+				if ((tmp_data[0] & 0x01U) == 0x00U) {
+					ret = true;
+				}
+				break;
+			}
+			counter += 1U;
+			I("Retry %d times!\n", counter);
+		}
+	}
+
+	if (ret) {
+		I("%s:MPAP check_Vsync Pass\n", __func__);
+	} else {
+		I("%s:MPAP check_Vsync Fail\n", __func__);
+	}
+
+	return ret;
+}
+#endif
+
+void himax_chip_self_test(struct seq_file *s, void *v)
+{
+	uint32_t ret = HX_INSP_OK;
+	uint32_t i = 0;
+	uint8_t tmp_data[DATA_LEN_4] = { 0x01, 0x00, 0x00, 0x00 };
+	struct file *raw_file = NULL;
+	/*struct filename *vts_name = NULL;*/
+#if !defined(KERNEL_VER_5_18)
+    mm_segment_t fs;
+#endif
+	loff_t pos = 0;
+	uint32_t rslt = HX_INSP_OK;
+	char write_buffer[512] = { 0 };
+	int len = 0;
+
+	UNUSED(v);
+
+	private_ts->suspend_resume_done = 0;
+
+	ret = himax_self_test_data_init();
+	if (ret > 0U) {
+		E("%s: initialize self test failed\n", __func__);
+		goto END;
+	}
+
+	if (raw_file == NULL) {
+		raw_file = filp_open(g_file_path, (O_TRUNC | O_CREAT | O_RDWR),
+				     (S_IRGRP | S_IWGRP | S_IRUSR | S_IWUSR));
+
+		if (IS_ERR(raw_file) != 0) {
+			E("%s open file failed = %ld\n", __func__,
+			  PTR_ERR(raw_file));
+			file_w_flag = false;
+		}
+	}
+
+#if !defined(KERNEL_VER_5_18)
+    fs = get_fs();
+    set_fs(KERNEL_DS);
+#endif
+	hx_print_ic_id();
+	if (file_w_flag) {
+#ifdef KERNEL_VER_ABOVE_4_14
+		kernel_write(raw_file, g_rslt_data, g_rslt_data_len, &pos);
+#else
+		vfs_write(raw_file, g_rslt_data, g_rslt_data_len, &pos);
+#endif
+	}
+
+	I("%s: enter, %d\n", __func__, __LINE__);
+	seq_puts(s, "Self_Test Duration==>\n");
+	/*Do normal test items*/
+	for (i = 0; i < HX_CRITERIA_ITEM; i++) {
+		if (g_test_item_flag[i]) {
+			I("%d. %s Start\n", i,
+				g_himax_self_test_mode[i]);
+			rslt = mpTestFunc((uint8_t)i, (mutual_block_num + self_block_num), s);
+			if (file_w_flag &&
+				((rslt & HX_INSP_EGETRAW) == 0U) &&
+				((rslt & HX_INSP_ESWITCHMODE) == 0U)) {
+#ifdef KERNEL_VER_ABOVE_4_14
+				kernel_write(raw_file, g_rslt_data,
+							g_rslt_data_len, &pos);
+#else
+				vfs_write(raw_file, g_rslt_data,
+						g_rslt_data_len, &pos);
+#endif
+			}
+			ret |= rslt;
+
+			I("%d. %s End, ret = %d\n", i,
+				g_himax_self_test_mode[i], ret);
+		}
+	}
+	I("%s: enter, %d\n", __func__, __LINE__);
+
+	hx_print_normalize_status();
+	if (file_w_flag) {
+#ifdef KERNEL_VER_ABOVE_4_14
+		kernel_write(raw_file, g_rslt_data, g_rslt_data_len, &pos);
+#else
+		vfs_write(raw_file, g_rslt_data, g_rslt_data_len, &pos);
+#endif
+	}
+
+	g_core_fp.fp_sense_off();
+	/*himax_set_N_frame(1, HX_self_test_WT_NOISE);*/
+	/* set N frame back to default value 1*/
+	himax_mcu_register_write(addr_set_frame_addr, 4, tmp_data);
+
+	himax_mcu_config_reload_enable();
+#if !defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX83194)
+	himax_mcu_rawdata_normalize_disable(0);
+#endif
+
+	if (himax_check_mode(HX_RAWDATA) != 0U) {
+		I("%s:try to  Need to back to Normal!\n", __func__);
+		himax_switch_mode_self_test(HX_RAWDATA);
+		g_core_fp.fp_sense_on();
+		(void)himax_wait_sorting_mode(HX_RAWDATA);
+	} else {
+		I("%s: It has been in Normal!\n", __func__);
+		g_core_fp.fp_sense_on();
+	}
+
+	if (ret == HX_INSP_OK) {
+		seq_puts(s, "Self_Test Pass==>\n");
+	} else {
+		seq_puts(s, "Self_Test Fail==>\n");
+	}
+
+	for (i = 0; i < (HX_CRITERIA_ITEM - 1U); i++) {
+		if (g_test_item_flag[i]) {
+			seq_printf(s, "\t%s : %s\n", g_himax_self_test_mode[i],
+				   ((ret & (1U << (i + ERR_SFT))) ==
+				    (1U << (i + ERR_SFT))) ?
+					   "Fail" :
+						 "OK");
+		}
+	}
+
+	himax_self_test_data_deinit();
+
+
+	if (private_ts->chip_test_mpap_flag) {
+		len += snprintf(&write_buffer[len], 512 - len,
+		"\n\n---------------------------MPAP items test start----------------------------\n\n");
+#if (HX_RST_PIN_FUNC == 0x01)
+		if (himax_mpap_test_tp_rst()) {
+			seq_puts(s, "MPAP tp rst test Pass\n");
+			len += snprintf(&write_buffer[len], 512 - len, "MPAP tp rst test Pass\n");
+		} else {
+			seq_puts(s, "MPAP tp rst test Fail\n");
+			len += snprintf(&write_buffer[len], 512 - len, "MPAP tp rst test Fail\n");
+		}
+#else
+		seq_puts(s, "Need config TP RST pin!!!\n");
+		seq_puts(s, "Software tp reset not support MPAP tp rst test item\n");
+#endif
+
+		if (himax_mpap_test_int()) {
+			seq_puts(s, "MPAP int test Pass\n");
+			len += snprintf(&write_buffer[len], 512 - len, "MPAP int test Pass\n");
+		} else {
+			seq_puts(s, "MPAP int test Fail\n");
+			len += snprintf(&write_buffer[len], 512 - len, "MPAP int test Fail\n");
+		}
+#if defined(CONFIG_TOUCHSCREEN_HIMAX_IC_HX8530)
+		if (himax_mpap_test_fail_det()) {
+			seq_puts(s, "MPAP fail_det test Pass\n");
+			len += snprintf(&write_buffer[len], 512 - len, "MPAP fail_det test Pass\n");
+		} else {
+			seq_puts(s, "MPAP fail_det test Fail\n");
+			len += snprintf(&write_buffer[len], 512 - len, "MPAP fail_det test Fail\n");
+		}
+		if (himax_mpap_check_Vsync()) {
+			seq_puts(s, "MPAP check_Vsync Pass\n");
+			len += snprintf(&write_buffer[len], 512 - len, "MPAP check_Vsync Pass\n");
+		} else {
+			seq_puts(s, "MPAP check_Vsync Fail\n");
+			len += snprintf(&write_buffer[len], 512 - len, "MPAP check_Vsync Fail\n");
+		}
+#endif
+		if (file_w_flag) {
+#ifdef KERNEL_VER_ABOVE_4_14
+			kernel_write(raw_file, write_buffer, len, &pos);
+#else
+			vfs_write(raw_file, write_buffer, len, &pos);
+#endif
+		}
+
+	}
+
+	if (file_w_flag) {
+		filp_close(raw_file, NULL);
+	}
+#if !defined(KERNEL_VER_5_18)
+    set_fs(fs);
+#endif
+
+END:
+	I("running status = 0x%02X\n", ret);
+
+	I("%s:output file to path : %s\n", __func__, g_file_path);
+}
+
+void himax_self_test_data_clear(void)
+{
+	if (g_rslt_data != NULL) {
+		kfree(g_rslt_data);
+		g_rslt_data = NULL;
+	}
+	if (g_start_log != NULL) {
+		kfree(g_start_log);
+		g_start_log = NULL;
+	}
+	if (g_file_path != NULL) {
+		kfree(g_file_path);
+		g_file_path = NULL;
+	}
+}
+
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_self_test.h linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_self_test.h
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/himax_self_test.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/himax_self_test.h	2024-06-14 10:43:31.785519389 +0200
@@ -0,0 +1,158 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*  Himax Android Driver Sample Code for self_test functions
+ *
+ *  Copyright (C) 2024 Himax Corporation.
+ *
+ *  This software is licensed under the terms of the GNU General Public
+ *  License version 2,  as published by the Free Software Foundation,  and
+ *  may be copied,  distributed,  and modified under those terms.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ */
+
+#ifndef H_HIMAX_SELF_TEST
+#define H_HIMAX_SELF_TEST
+
+#include "himax_platform.h"
+#include "himax_common.h"
+#include "himax_ic_core.h"
+
+/*-------------------------------------- define block ---------------------------------------------*/
+
+/* enum THP_self_test_ENUM */
+#define	HX_OPEN				0x00U
+#define	HX_MICRO_OPEN		0x01U
+#define	HX_SHORT			0x02U
+#define	HX_WT_NOISE			0x03U
+#define	HX_NOISE			0x04U
+#define	HX_RAWDATA			0x05U
+#define	HX_BPN_RAWDATA		0x06U
+#define	HX_SBP_RAWDATA		0x07U
+#define	HX_SC				0x08U
+#define	HX_SORTING			0x09U
+#define	HX_GAPTEST_RAW		0x0AU
+/*Must put in the end*/
+#define	HX_BACK_NORMAL		0x0BU
+
+
+/* enum HX_CRITERIA_ENUM */
+#define	IDX_RAWMIN			0U
+#define	IDX_RAWMAX			1U
+#define	IDX_BPN_RAWMIN		2U
+#define	IDX_BPN_RAWMAX		3U
+#define	IDX_SBP_RAWMIN		4U
+#define	IDX_SBP_RAWMAX		5U
+#define	IDX_SCMIN			6U
+#define	IDX_SCMAX			7U
+#define	IDX_SC_GOLDEN		8U
+#define	IDX_SHORTMIN		9U
+#define	IDX_SHORTMAX		10U
+#define	IDX_OPENMIN			11U
+#define	IDX_OPENMAX			12U
+#define	IDX_M_OPENMIN		13U
+#define	IDX_M_OPENMAX		14U
+#define	IDX_WT_NOISEMIN		15U
+#define	IDX_WT_NOISEMAX		16U
+#define	IDX_NOISEMIN		17U
+#define	IDX_NOISEMAX		18U
+#define	IDX_SORTMIN			19U
+#define	IDX_SORTMAX			20U
+#define	IDX_GAP_HOR_RAWMAX	21U
+#define	IDX_GAP_HOR_RAWMIN	22U
+#define	IDX_GAP_VER_RAWMAX	23U
+#define	IDX_GAP_VER_RAWMIN	24U
+#define	IDX_ACT_IDLE_NOISE_MIN		25U
+#define	IDX_ACT_IDLE_NOISE_MAX		26U
+#define	IDX_ACT_IDLE_RAWDATA_MIN	27U
+#define	IDX_ACT_IDLE_RAWDATA_MAX	28U
+#define	IDX_ACT_IDLE_RAW_BPN_MIN	29U
+#define	IDX_ACT_IDLE_RAW_BPN_MAX	30U
+#define	IDX_LP_WT_NOISEMIN			31U
+#define	IDX_LP_WT_NOISEMAX			32U
+#define	IDX_LP_NOISE_ABS_MIN		33U
+#define	IDX_LP_NOISE_ABS_MAX		34U
+#define	IDX_LP_RAWDATA_MIN			35U
+#define	IDX_LP_RAWDATA_MAX			36U
+#define	IDX_LP_RAW_BPN_MIN			37U
+#define	IDX_LP_RAW_BPN_MAX			38U
+#define	IDX_LP_IDLE_NOISE_MIN		39U
+#define	IDX_LP_IDLE_NOISE_MAX		40U
+#define	IDX_LP_IDLE_RAWDATA_MIN		41U
+#define	IDX_LP_IDLE_RAWDATA_MAX		42U
+#define	IDX_LP_IDLE_RAW_BPN_MIN		43U
+#define	IDX_LP_IDLE_RAW_BPN_MAX		44U
+
+#define ERR_SFT 5U
+/* Error code of self_test */
+	/* OK */
+#define	HX_INSP_OK				0x00U
+	/* Criteria file error*/
+#define	HX_INSP_EFILE			0x01U
+	/* Get raw data errors */
+#define	HX_INSP_EGETRAW			0x02U
+	/* Memory allocate errors */
+#define	HX_INSP_MEMALLCTFAIL	0x03U
+	/* Switch mode error*/
+#define	HX_INSP_ESWITCHMODE		0x04U
+
+#define	HX_RSLT_OUT_PATH	"/sdcard/"
+#define	HX_SZ_ICID			1024
+#define PI(x...) pr_cont(x)
+
+#define	BS_RAWDATA			8U
+#define	BS_NOISE			8U
+#define	BS_OPENSHORT		1U
+#define	BS_INSPECT_MODE		1U
+#define	NOISEFRAME			200U
+#define	OTHERSFRAME			1U
+
+/*Himax MP Password*/
+#define	PWD_OPEN_START			0x77U
+#define	PWD_OPEN_END			0x88U
+#define	PWD_MICRO_OPEN_START	0x6BU
+#define	PWD_MICRO_OPEN_END		0x70U
+#define	PWD_SHORT_START			0x11U
+#define	PWD_SHORT_END			0x33U
+#define	PWD_RAWDATA_START		0x00U
+#define	PWD_RAWDATA_END			0x99U
+#define	PWD_NOISE_START			0x00U
+#define	PWD_NOISE_END			0x99U
+#define	PWD_SORTING_START		0xAAU
+#define	PWD_SORTING_END			0xCCU
+
+/*Himax DataType*/
+#define	DATA_SORTING			0x0AU
+#define	DATA_OPEN				0x0BU
+#define	DATA_MICRO_OPEN			0x0AU
+#define	DATA_SHORT				0x0AU
+#define	DATA_RAWDATA			0x0AU
+#define	DATA_Self_test_RAWDATA	0x0BU
+#define	DATA_NOISE				0x0FU
+#define	DATA_BACK_NORMAL		0x00U
+
+/*self_test register*/
+#define	addr_normal_noise_thx	(addr_CFG_base + 0x1000708CU)
+#define	addr_recal_thx			(addr_CFG_base + 0x10007090U)
+#define	addr_palm_num			(addr_CFG_base + 0x100070A8U)
+#define	addr_weight_sup			(addr_CFG_base + 0x100072C8U)
+#define	addr_normal_weight_a	(addr_CFG_base + 0x1000709CU)
+#define	addr_weight_b			(addr_CFG_base + 0x10007094U)
+#define	addr_max_dc				(addr_CFG_base + 0x10007FC8U)
+#define	addr_skip_frame			(addr_CFG_base + 0x100070F4U)
+#define	addr_neg_noise_sup		(addr_CFG_base + 0x10007FD8U)
+#define	data_neg_noise			0x7F0C0000U
+
+#define	HX_INSPECT_MODE			0xFFU
+/*Need to map *g_himax_self_test_mode[]*/
+
+#define FAIL_IN_INDEX "%s: %s FAIL in index %d\n"
+extern char *g_rslt_data;
+
+
+void himax_self_test_data_clear(void);
+
+
+#endif
diff -ruN linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/modules.order linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/modules.order
--- linux-17f135b742c4edb340afb365873c3a574f7e16cb/drivers/input/touchscreen/hxchipset/modules.order	1970-01-01 01:00:00.000000000 +0100
+++ linux-17f135b742c4edb340afb365873c3a574f7e16cb-himax/drivers/input/touchscreen/hxchipset/modules.order	2024-06-14 10:43:31.785519389 +0200
@@ -0,0 +1 @@
+drivers/input/touchscreen/hxchipset/himax_mmi.ko
